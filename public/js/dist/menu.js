// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"h9ZBw":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = 1234;
var HMR_SECURE = false;
var HMR_ENV_HASH = "e6578ada3c54fe22";
module.bundle.HMR_BUNDLE_ID = "e539b65d4bf31ee1";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, globalThis, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets, assetsToDispose, assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? "wss" : "ws";
    var ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/"); // Web extension context
    var extCtx = typeof chrome === "undefined" ? typeof browser === "undefined" ? null : browser : chrome; // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    } // $FlowFixMe
    ws.onmessage = async function(event) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        assetsToDispose = [];
        var data = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH); // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear(); // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets); // Dispose all old assets.
                let processedAssets = {} /*: {|[string]: boolean|} */ ;
                for(let i = 0; i < assetsToDispose.length; i++){
                    let id = assetsToDispose[i][1];
                    if (!processedAssets[id]) {
                        hmrDispose(assetsToDispose[i][0], id);
                        processedAssets[id] = true;
                    }
                } // Run accept callbacks. This will also re-execute other disposed assets in topological order.
                processedAssets = {};
                for(let i = 0; i < assetsToAccept.length; i++){
                    let id = assetsToAccept[i][1];
                    if (!processedAssets[id]) {
                        hmrAccept(assetsToAccept[i][0], id);
                        processedAssets[id] = true;
                    }
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] ✨ Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          🚨 ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>📝 <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", link.getAttribute("href").split("?")[0] + "?" + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension bugfix for Chromium
                    // https://bugs.chromium.org/p/chromium/issues/detail?id=1255412#c12
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3) {
                        if (typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                            extCtx.runtime.reload();
                            return;
                        }
                        asset.url = extCtx.runtime.getURL("/__parcel_hmr_proxy__?url=" + encodeURIComponent(asset.url + "?t=" + Date.now()));
                        return hmrDownload(asset);
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
             // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id]; // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
     // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
}
function hmrDispose(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle, id) {
    // Execute the module.
    bundle(id); // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) {
            assetsToAlsoAccept.forEach(function(a) {
                hmrDispose(a[0], a[1]);
            }); // $FlowFixMe[method-unbinding]
            assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
        }
    });
}

},{}],"bzv6s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _defineProperty = require("@babel/runtime/helpers/defineProperty");
var _definePropertyDefault = parcelHelpers.interopDefault(_defineProperty);
var _preact = require("preact");
var _hooks = require("preact/hooks");
var _compat = require("preact/compat");
var _classnames = require("classnames");
var _classnamesDefault = parcelHelpers.interopDefault(_classnames);
var _reactMasonryCss = require("react-masonry-css");
var _reactMasonryCssDefault = parcelHelpers.interopDefault(_reactMasonryCss);
var _preactContextMenu = require("preact-context-menu");
var _css = require("@emotion/css");
var _dayjs = require("dayjs");
var _utc = require("dayjs/plugin/utc");
var _reactLottiePlayer = require("react-lottie-player");
var _reactLottiePlayerDefault = parcelHelpers.interopDefault(_reactLottiePlayer);
var _reactAnimateHeight = require("react-animate-height");
var _reactAnimateHeightDefault = parcelHelpers.interopDefault(_reactAnimateHeight);
var _reactResponsiveMasonry = require("react-responsive-masonry");
var _reactResponsiveMasonryDefault = parcelHelpers.interopDefault(_reactResponsiveMasonry);
var _reactInfiniteScrollHook = require("react-infinite-scroll-hook");
var _reactInfiniteScrollHookDefault = parcelHelpers.interopDefault(_reactInfiniteScrollHook);
var _useDebounce = require("use-debounce");
var _reactHowler = require("react-howler");
var _reactHowlerDefault = parcelHelpers.interopDefault(_reactHowler);
var _reactDeviceDetect = require("react-device-detect"); // stop playing audio when you leave the tab
_dayjs.extend(_utc);
const projectsInitItem = "projects";
const Context = (0, _preact.createContext)({});
class Tabs extends (0, _preact.Component) {
    constructor(props){
        super(props);
        (0, _definePropertyDefault.default)(this, "state", {
            activeItem: projectsInitItem,
            openItem: null,
            draggingItemId: null,
            portalMenu: false,
            adding: [],
            accordionOpenIds: [],
            accordionInitialOpenIds: [],
            // prevents loading data before accordion open
            creatingFolder: false
        });
        (0, _definePropertyDefault.default)(this, "onMenuClick", (item)=>{
            this.activeItem = item.name;
            this.setState({
                activeItem: item.name,
                openItem: null
            });
            this.closeAllAccordions();
            this.getData(item);
            this.updateMenuState();
            let exampleData = {
                title: "",
                vimeoId: "",
                description: "",
                thumbUrl: ""
            };
        });
        (0, _definePropertyDefault.default)(this, "addingToMy", (id)=>this.isAddingId(id));
        (0, _definePropertyDefault.default)(this, "isAccordionIdOpen", (id)=>this.state.accordionOpenIds.indexOf(id) > -1);
        (0, _definePropertyDefault.default)(this, "isAccordionIdInitialOpen", (id)=>this.state.accordionInitialOpenIds.indexOf(id) > -1);
        this.activeItem = projectsInitItem;
        this.data = {};
    }
    componentDidMount() {
        this.updateMenuState();
        $(document).on("top-menu-change", ()=>{
            this.updateMenuState(true);
        }); // menuItems.map((item, index) => {
    //   setTimeout(()=> {
    //     this.onMenuClick(item);
    //     setTimeout(()=>this.onMenuClick(item), 100);
    //   }, 100 * index);
    // });
    }
    updateMenuState(init) {
        const assetsMenuSelected = true; //$(".tab-item[data-target=js-accordion-assets]").hasClass("active")
        this.setState({
            portalMenu: assetsMenuSelected
        });
        if (assetsMenuSelected && (init || this.activeItem === projectsInitItem)) {
            this.setState({
                activeItem: projectsInitItem
            });
            $("#tab-project").addClass("open"); // this.onMenuClick(menuItems[4]) // for testing
        } else $("#tab-project").removeClass("open");
    }
    // data
    getData(item) {
        this.setState({
            loading: true
        });
        if (item.name === "video") {
            this.data[item.name] = [
                {
                    name: "pixabay",
                    pixabay: true
                }
            ];
            if (this.state[item.name]) {
                setTimeout(()=>{
                    this.setState({
                        loading: false
                    });
                }, 500);
                return;
            }
            this.getMyData();
            return;
        }
        if (!item.url) return;
        if (this.state[item.name]) {
            setTimeout(()=>{
                this.setState({
                    loading: false
                });
            }, 500);
            return;
        }
        $.get(item.url, (data)=>{
            data = parseData(data);
            if (item.name === "images") data = insert(data, 0, {
                name: "unsplash",
                unsplash: true
            });
            this.data[item.name] = data;
            this.getMyData();
        });
    }
    getMyName() {
        return menuItems.find((i)=>i.name === this.activeItem).myName;
    }
    getMyData(cb) {
        const name = this.activeItem;
        if (name === projectsInitItem) return;
        $.get("/asset/my-" + this.getMyName(), (myData)=>{
            this.setState({
                [name]: [
                    {
                        my: true,
                        name: "My " + name,
                        accordion: true,
                        items: myData
                    },
                    ...this.data[name].filter((i)=>!i.my)
                ]
            });
            setTimeout(()=>{
                this.setState({
                    loading: false
                });
            }, 500);
            typeof cb === "function" && cb();
        });
    }
    addToMy(e, id) {
        const name = this.getMyName();
        if (this.isMyDataContains(id) || this.isAddingId(id)) return;
        this.startSpinnerId(id);
        $.post(`/asset/my-${name}/add`, {
            id,
            folderId: 0
        }, ()=>{
            this.getMyData(()=>{
                this.stopSpinnerId(id);
            });
        });
    }
    uploadToMy(e, type, url, id) {
        if (this.isMyDataContains(id) || this.isAddingId(id)) return;
        this.startSpinnerId(id);
        let fileName = new URL(url).pathname.split("/").pop();
        if (type === "Image") {
            const ext = url.match(/fm=([^&]*)&/)[1];
            fileName += "." + ext;
        }
        fetch(url).then((res)=>res.blob()).then((blob)=>{
            const file = new File([
                blob
            ], fileName, {
                type: blob.type
            });
            const formData = new FormData();
            formData.append("type", type);
            formData.append("file", file);
            fetch(`/asset/my-${type}/upload`, {
                method: "POST",
                body: formData
            }).then((res)=>{
                this.getMyData(()=>{
                    this.stopSpinnerId(id);
                });
            });
        }).catch((err)=>{
            this.stopSpinnerId(id);
            console.error(err);
        });
    }
    deleteFromMy(e, id) {
        const name = this.getMyName();
        this.startSpinnerId(id);
        $.post(`/asset/my-${name}/delete`, {
            id
        }, ()=>{
            this.getMyData(()=>{
                this.stopSpinnerId(id);
            });
        });
    }
    isAddingId(id) {
        return this.state.adding.find((a)=>a.name === this.getMyName() && a.id === id);
    }
    startSpinnerId(id) {
        this.setState({
            adding: [
                ...this.state.adding,
                {
                    name: this.getMyName(),
                    id
                }
            ]
        });
    }
    stopSpinnerId(id) {
        this.setState({
            adding: this.state.adding.filter((a)=>!(a.name === this.getMyName() && a.id === id))
        });
    }
    toggleAccordion(id) {
        if (this.isAccordionIdOpen(id)) this.closeAccordion(id);
        else this.openAccordion(id);
    }
    openAccordion(id) {
        this.setState({
            accordionOpenIds: [
                ...this.state.accordionOpenIds,
                id
            ],
            accordionInitialOpenIds: [
                ...this.state.accordionInitialOpenIds,
                id
            ]
        });
    }
    closeAllAccordions() {
        this.setState({
            accordionOpenIds: []
        });
    }
    closeAccordion(id) {
        this.setState({
            accordionOpenIds: this.state.accordionOpenIds.filter((openId)=>openId !== id)
        });
    }
    isMyDataContains(id) {
        const data = this.state[this.state.activeItem];
        if (!data) return false;
        return data[0].items.find((folder)=>folder.items.find((d)=>d[this.getMyName() + "Id"] === id));
    }
    isMyDataOpened() {
        return this.state.openItem && this.state.openItem.startsWith("My");
    }
    getContext() {
        const { adding , activeItem , openItem , accordionOpenIds  } = this.state;
        const myName = this.getMyName();
        return {
            myName,
            myDataContains: (id)=>this.isMyDataContains(id),
            addingToMy: (id)=>this.addingToMy(id),
            onAddToMyClick: (e, id)=>{
                if (this.isMyDataOpened()) return;
                this.addToMy(e, id);
            },
            uploadToMy: (e, type, url, id)=>this.uploadToMy(e, type, url, id),
            onDeleteClick: (id)=>{
                $.post("/folder/delete/" + id, ()=>{
                    this.getMyData();
                });
            },
            isAccordionIdOpen: (id)=>this.isAccordionIdOpen(id),
            isAccordionIdInitialOpen: (id)=>this.isAccordionIdInitialOpen(id),
            activeItem: activeItem,
            isMyItemOpened: this.isMyDataOpened(),
            toggleAccordion: (id)=>this.toggleAccordion(id),
            onDragStart: (draggingItemId)=>{
                setTimeout(()=>{
                    this.closeAllAccordions();
                    this.setState({
                        draggingItemId
                    });
                }, 1);
            },
            deleteFromMy: (e, id)=>this.deleteFromMy(e, id)
        };
    }
    renderData() {
        const { openItem , activeItem , loading , creatingFolder  } = this.state; // projects
        if (activeItem === projectsInitItem) return;
        if (loading) return; // return <div>Loading...</div>
        // list of initial items
        if (!openItem) {
            if ($(".tab-item.js-accordion-item." + activeItem + " .js-accordion-body").html() == "") (0, _preact.render)(this.renderCategories(), $(".tab-item.js-accordion-item." + activeItem + " .js-accordion-body")[0]);
            return;
        }
        const data = this.state[this.state.activeItem];
        const data1 = data.find(({ name  })=>name === openItem); // item with different types of data
        $("#js-accordion-menu").css("display", "none");
        $("#js-accordion-assets-context").css("display", "flex");
        (0, _preact.render)((0, _preact.h)("div", {
            style: {
                display: "flex",
                flexDirection: "column",
                overflow: "hidden",
                height: "100%"
            }
        }, (0, _preact.h)(TopButtons, {
            onGoBackClick: ()=>setTimeout(()=>{
                    this.setState({
                        openItem: null
                    });
                    $("#js-accordion-menu").css("display", "flex");
                    $("#js-accordion-assets-context").css("display", "none");
                }, 1),
            showCreateFolderButton: data1.my,
            onCreateFolderClick: ()=>{
                this.setState({
                    creatingFolder: true
                });
                $.post("/folder/create", {
                    type: this.getMyName(),
                    name: "Untitled"
                }, ()=>{
                    this.getMyData(()=>{
                        this.setState({
                            creatingFolder: false
                        });
                    });
                });
            },
            onImport: (e)=>{
                const formData = new FormData();
                let folderId = $(".AccordionList .accordionItem.active").data("id");
                if (!folderId) return;
                formData.append("type", "Geometry");
                formData.append("folderId", folderId);
                const files = e.target.files;
                for(let i = 0; i < files.length; i++)formData.append(`file`, files[i]);
                fetch("/asset/my-geometry/upload", {
                    method: "POST",
                    body: formData
                }).then((response)=>this.getMyData());
            },
            creatingFolder: creatingFolder,
            enableImport: data1.my && data1.name !== "My materials"
        }), (0, _preact.h)(Context.Provider, {
            value: this.getContext()
        }, this.renderOpenCategory())), $("#js-accordion-assets-context")[0]);
        return (0, _preact.h)("div", null);
    }
    renderCategories() {
        const data = this.state[this.state.activeItem];
        if (!data) return;
        return (0, _preact.h)(Context.Provider, {
            value: this.getContext()
        }, (0, _preact.h)("div", {
            class: (0, _classnamesDefault.default)("categories", (0, _css.css)`
              display: grid;
              --n: ${(0, _reactDeviceDetect.isBrowser) ? "4" : "1"};
              grid-template-columns: repeat(auto-fill, minmax(max(200px, 100% / var(--n)), 1fr));
            `)
        }, data.map(({ id , name , my , thumbUrl ="https://assets.website-files.com/616a041ea72c58e139ed3c8e/616a041ea72c58999ded3dc1_my-heartdrive.png"  })=>{
            const thumbs = {
                "99sounds": "https://arcadestudio-assets.s3.us-east-2.amazonaws.com/gallery/audio/99sounds.png",
                unsplash: "https://arcadestudio-assets.s3.us-east-2.amazonaws.com/gallery/images/unsplash.png",
                Kane: "https://arcadestudio-assets.s3.us-east-2.amazonaws.com/gallery/images/kane-gallery.png",
                pixabay: "https://arcadestudio-assets.s3.us-east-2.amazonaws.com/gallery/video/pixabay.png",
                Lottie: "https://arcadestudio-assets.s3.us-east-2.amazonaws.com/gallery/animations/lottie.png"
            };
            if (thumbs[name]) thumbUrl = thumbs[name];
            if (this.addingToMy(id)) return (0, _preact.h)(Spinner, null);
            return (0, _preact.h)(CategoriesItem, {
                id: id,
                name: name,
                thumbUrl: thumbUrl,
                onOpenItemClick: (e)=>{
                    e.stopPropagation();
                    e.preventDefault();
                    if (this.activeItem === "environment" && name !== "My environment") {
                        this.addToMy(e, id);
                        return;
                    }
                    this.setState({
                        openItem: name
                    });
                },
                isMyData: my
            });
        })));
    }
    renderOpenCategory() {
        const data = this.state[this.state.activeItem];
        const data1 = data.find(({ name  })=>name === this.state.openItem);
        if (data1.unsplash) return (0, _preact.h)(Unsplash, null);
        if (data1.pixabay) return (0, _preact.h)(Pixabay, null); // render items
        if (!data1.accordion) return (0, _preact.h)("div", {
            class: (0, _css.css)`
            padding-top: 30px;
          `
        }, (0, _preact.h)(Items, {
            data: data1,
            noneBorder: true
        }));
         // render accordion
        return (0, _preact.h)("div", {
            class: (0, _css.css)`
          padding-top: 30px;
          overflow: scroll;
          height: 100%;
        `
        }, data1.items.map((data2)=>{
            return (0, _preact.h)("div", {
                class: "AccordionList",
                onClick: ()=>{
                    $(".slide-menu").hide();
                }
            }, (0, _preact.h)(AccordionHead, {
                data: data2,
                onItemDrop: (e)=>{
                    const folderId = data2.id;
                    $(e.target.closest(".accordionItem")).removeClass("hover");
                    $.post(`/asset/my-${this.getMyName()}/update/` + this.state.draggingItemId, {
                        folderId
                    }, ()=>{
                        this.getMyData(()=>{
                            setTimeout(()=>{
                                this.openAccordion(folderId);
                            }, 100);
                        });
                    });
                    this.setState({
                        draggingItemId: null
                    });
                },
                onNameUpdate: (value)=>{
                    // TODO: post if the name is changed
                    $.post("/folder/update/" + data2.id, {
                        name: value
                    }, ()=>{
                        this.getMyData();
                    });
                } // onImport={(e) => {
                ,
                disableContextMenu: data2.name === "Recent",
                enableImport: data1.my && data1.name !== "My materials"
            }), (0, _preact.h)((0, _reactAnimateHeightDefault.default), {
                duration: 400,
                height: this.isAccordionIdOpen(data2.id) ? "auto" : 0,
                delay: 200
            }, this.isAccordionIdInitialOpen(data2.id) && (0, _preact.h)(Items, {
                data: data2
            })));
        }));
    }
    render({}, { activeItem , portalMenu  }) {
        return (0, _preact.h)("div", {
            style: "background: black"
        }, this.renderData(), (0, _preact.h)(Menu, {
            portalMenu: portalMenu,
            activeItem: activeItem,
            onClick: this.onMenuClick
        }));
    }
}
const TopButtons = ({ onGoBackClick , showCreateFolderButton , onCreateFolderClick , creatingFolder , enableImport , onImport  })=>{
    return (0, _preact.h)("div", {
        class: (0, _classnamesDefault.default)("top-buttons", (0, _css.css)`
          position: absolute;
          display: flex;
          justify-content: space-between;
          flex-direction: row;
          width: 100%;
          padding: 3px 8px;
          align-items: center;
          border-bottom: 0.5px solid #1e2742;
          background: black;
          z-index: 2;
        `)
    }, (0, _preact.h)("button", {
        onClick: onGoBackClick,
        class: (0, _css.css)`
          &,
          &:hover,
          &:focus {
            background: none;
          }
        `
    }, (0, _preact.h)("div", {
        class: (0, _css.css)`
            display: -webkit-box;
            display: -webkit-flex;
            display: -ms-flexbox;
            display: flex;
            width: 14px;
            height: 14px;
            margin-left: 4px;
            -webkit-box-pack: center;
            -webkit-justify-content: center;
            -ms-flex-pack: center;
            justify-content: center;
            -webkit-box-align: center;
            -webkit-align-items: center;
            -ms-flex-align: center;
            align-items: center;
            border-style: none none solid solid;
            border-width: 1px;
            border-color: #7292db;
            border-radius: 0px 0px 0px 4px;
            -webkit-transform: rotate(45deg);
            -ms-transform: rotate(45deg);
            transform: rotate(45deg);
            cursor: pointer;
          `
    })), (0, _preact.h)("div", {
        class: (0, _css.css)`
        flex: 1;
        display: flex;
        margin-right: 12px;
        justify-content: flex-end;
        gap: 12px;
      `
    }, (0, _preact.h)("input", {
        id: "input_file",
        type: "file",
        multiple: true,
        onChange: onImport,
        style: {
            display: "none"
        }
    }), enableImport && (0, _preact.h)("div", {
        onClick: ()=>$("#input_file").click(),
        class: (0, _css.css)`
              display: flex;
              width: 18px;
              height: 18px;
              justify-content: center;
              align-items: center;
              border: 1px solid #48648f;
              border-radius: 2px;
              &,
              &:hover,
              &:focus {
                background: none;
              }
              cursor: pointer;
            `
    }, (0, _preact.h)("img", {
        src: "https://assets.website-files.com/616a041ea72c58e139ed3c8e/616a041ea72c583813ed3ca9_plus.png",
        alt: "",
        class: (0, _css.css)`
                max-width: 40%;
                vertical-align: middle;
                display: inline-block;
              `
    })), showCreateFolderButton && (0, _preact.h)("div", {
        onClick: onCreateFolderClick,
        class: (0, _css.css)`
            display: flex;
              width: 18px;
              height: 18px;
              justify-content: center;
              align-items: center;
              &,
              &:hover,
              &:focus {
                background: none;
              }
              cursor: pointer;
            `
    }, creatingFolder ? (0, _preact.h)(Spinner, {
        size: 1
    }) : (0, _preact.h)("img", {
        src: "https://arcadestudio-assets.s3.us-east-2.amazonaws.com/website/master/control-panel/new-folder.svg",
        alt: "",
        class: (0, _css.css)`
                  max-width: 100%;
                  vertical-align: middle;
                  display: inline-block;
                `
    }))));
};
const AccordionHead = ({ data , onItemDrop , onNameUpdate , onImport , disableContextMenu , enableImport  })=>{
    const { onDeleteClick , isMyItemOpened , toggleAccordion , isAccordionIdOpen  } = (0, _hooks.useContext)(Context);
    return (0, _preact.h)("div", {
        key: data.id,
        "data-id": data.id,
        onDrop: isMyItemOpened && onItemDrop,
        onDragOver: isMyItemOpened ? (e)=>{
            // console.log("dragover", e);
            $(e.target.closest(".accordionItem")).addClass("hover");
            e.stopPropagation();
            e.preventDefault();
        } : false,
        onDragLeave: (e)=>{
            // console.log("dragleave", e);
            $(e.target.closest(".accordionItem")).removeClass("hover");
        },
        onContextMenu: (e)=>{
            e.preventDefault();
            e.stopPropagation();
            $(".slide-menu").hide();
            var folderItemMenu = $($(e.target).parent().find(".slide-menu")[0]);
            if (folderItemMenu.parent().length > 0) {
                var { top , left  } = folderItemMenu.parent()[0].getBoundingClientRect();
                folderItemMenu.css("left", e.clientX - left + "px");
                folderItemMenu.css("top", e.clientY - top + "px");
                folderItemMenu.show();
            }
        },
        onClick: (e)=>{
            if (e.target.closest("input").hasAttribute("readOnly")) toggleAccordion(data.id);
        },
        class: (0, _classnamesDefault.default)("accordionItem", isAccordionIdOpen(data.id) ? "active" : "", (0, _css.css)`
          display: flex;
          height: auto;
          justify-content: space-between;
          flex: 0 0 auto;
          padding-right: 0px;
          padding-left: 15px;
          border-bottom: 0.5px solid #1e2742;
          width: 100%;
          height: 100%;
          height: 30px;
          align-items: center;
          button {
            display: none;
          }
          &:hover,
          &:focus {
            background-color: #0f141e;
            button {
              display: block;
            }
          }
          &.hover, &.active {
            background-color: #1e2742;
            button {
              display: block;
            }
          }
          cursor: pointer;
          & > span {
            display: flex;
            width: 100%;
            height: 30px;
          }
          ${slideMenuParentCSS}
        `)
    }, (0, _preact.h)(InlineEdit, {
        class: (0, _classnamesDefault.default)("title"),
        value: data.name,
        setValue: onNameUpdate,
        forceReadOnly: disableContextMenu
    }), !disableContextMenu && (0, _preact.h)("div", {
        class: (0, _classnamesDefault.default)("slide-menu FolderItemMenu")
    }, (0, _preact.h)("div", {
        onClick: (e)=>onDeleteClick(data.id)
    }, "Delete")));
};
const Items = ({ data , noneBorder  })=>{
    let { activeItem , isMyItemOpened , addingToMy , myName , onAddToMyClick , onDeleteClick , myDataContains , isAccordionIdOpen , isAccordionIdInitialOpen , onDragStart  } = (0, _hooks.useContext)(Context);
    if (activeItem === "images") return (0, _preact.h)("div", {
        class: (0, _classnamesDefault.default)("accordion-body"),
        style: {
            borderBottom: noneBorder ? "none" : "0.5px solid #1e2742",
            padding: "15px"
        }
    }, (0, _preact.h)((0, _reactResponsiveMasonry.ResponsiveMasonry), {
        columnsCountBreakPoints: {
            350: 1,
            750: 2,
            900: 2
        }
    }, (0, _preact.h)((0, _reactResponsiveMasonryDefault.default), {
        gutter: "10px"
    }, data.items.map((data3)=>{
        return (0, _preact.h)("div", {
            class: (0, _css.css)`
                    width: 100%;
                    cursor: pointer;
                    position: relative;
                  `,
            ondragstart: ()=>onDragStart(data3.id),
            onClick: (e)=>onAddToMyClick(e, data3.id),
            onContextMenu: (e)=>{
                e.preventDefault();
                e.stopPropagation();
                $(".slide-menu").hide();
                var { top , left  } = $(e.target).parent()[0].getBoundingClientRect();
                var folderItemMenu = $(e.target).parent().find(".slide-menu");
                folderItemMenu.css("left", e.clientX - left + "px");
                folderItemMenu.css("top", e.clientY - top + "px");
                folderItemMenu.show();
            }
        }, addingToMy(data3.id) && (0, _preact.h)(Spinner, {
            isMasonry: true
        }), (0, _preact.h)(SlideMenu, {
            id: data3.id
        }), (0, _preact.h)(Heart, {
            id: data3.id
        }), (0, _preact.h)("img", {
            src: data3.thumbUrl || data3.url // loading="lazy"
            ,
            class: (0, _classnamesDefault.default)("accordion-item-image", (0, _css.css)`
                        display: block;
                        width: 100%;
                        ${addingToMy(data3.id) && ""}
                      `)
        }));
    }))));
    let gridN = 4;
    if (activeItem === "animation") gridN = 5;
    let templateColumns = "1fr 1fr 1fr";
    let gridGap = 0;
    let padding = 15;
    if (activeItem === "video" || activeItem === "environment" || activeItem === "audio" || activeItem === "animation") {
        templateColumns = "repeat(auto-fill, minmax(max(200px, 100% / var(--n)), 1fr))";
        if (activeItem !== "audio") gridGap = 20;
    }
    const [activeAudio, setActiveAudio] = (0, _hooks.useState)("");
    if (activeItem == "audio") padding = 0;
    const grid = (0, _css.css)`
    display: grid;
    --n: ${gridN};
    grid-template-columns: ${templateColumns};
    grid-template-rows: masonry;
    grid-gap: ${gridGap}px;
    padding: ${padding}px;
    border-bottom: ${noneBorder ? "none" : "0.5px solid #1e2742"};
  `;
    return (0, _preact.h)("div", {
        class: (0, _classnamesDefault.default)("accordionItemContainer", data.accordion ? "" : grid)
    }, data.items.map((data2)=>{
        // if (addingToMy(data2.id)) {
        //   return <Spinner isMasonry={true} size={activeItem === "audio" ? 2 : 10} />
        // }
        if (data.accordion) return (0, _preact.h)("div", null, (0, _preact.h)(Spinner, {
            isMasonry: true,
            size: activeItem === "audio" ? 2 : 10
        }), (0, _preact.h)(AccordionHead, {
            data: data2
        }), (0, _preact.h)((0, _reactAnimateHeightDefault.default), {
            duration: 300,
            height: isAccordionIdOpen(data2.id) ? "auto" : 0,
            delay: 200
        }, isAccordionIdInitialOpen(data2.id) && (0, _preact.h)(Items, {
            style: {
                borderBottom: "0.5px solid #1e2742"
            },
            data: data2
        })));
        if (activeItem === "audio" && data2.url) return (0, _preact.h)(Audio, {
            id: data2.id,
            name: data2.name,
            src: data2.url,
            activeAudio: activeAudio,
            setActiveAudio: setActiveAudio
        });
        if (activeItem === "environment") return (0, _preact.h)(CategoriesItem, {
            id: data2.id,
            name: data2.name,
            thumbUrl: data2.thumbUrl,
            isMyData: true
        });
        if (activeItem === "animation" && data2.url) return (0, _preact.h)(LottieItem, {
            id: data2.id,
            name: data2.name,
            url: data2.url
        });
        if (activeItem === "video" && data2.url) return (0, _preact.h)(PixabayVideo, {
            name: data2.name,
            id: data2.id,
            url: data2.url
        });
        return (0, _preact.h)("div", {
            class: "accordion-item",
            style: {
                position: "relative"
            },
            onDragStart: ()=>onDragStart(data2.id),
            draggable: isMyItemOpened,
            onClick: (e)=>{
                onAddToMyClick(e, data2.id);
            },
            onContextMenu: (e)=>{
                e.preventDefault();
                e.stopPropagation();
                $(".slide-menu").hide();
                var { top , left  } = $(e.target).parent()[0].getBoundingClientRect();
                var folderItemMenu = $(e.target).parent().find(".slide-menu");
                folderItemMenu.css("left", e.clientX - left + "px");
                folderItemMenu.css("top", e.clientY - top + "px");
                folderItemMenu.show();
            }
        }, addingToMy(data2.id) && (0, _preact.h)(Spinner, {
            isMasonry: true
        }), (0, _preact.h)("div", {
            class: (0, _css.css)`
                display: flex;
                width: 100%;
                height: 100px;
                margin-bottom: 0px;
                -webkit-box-pack: center;
                justify-content: center;
                -webkit-box-align: center;
                align-items: flex-start;
                border-radius: 0px;
                background-image: none;
                background-position: 0px 0px;
                background-size: auto;
                background-repeat: repeat;
                background-attachment: scroll;
                cursor: pointer;
                ${slideMenuParentCSS}
              `
        }, (0, _preact.h)(SlideMenu, {
            id: data2.id,
            borderRadius: 0
        }), (0, _preact.h)(Heart, {
            id: data2.id
        }), (0, _preact.h)("img", {
            src: data2.thumbUrl || data2.url,
            loading: "lazy",
            class: (0, _classnamesDefault.default)("accordion-item-image", (0, _css.css)`
                    width: 60px;
                    max-height: 60px;
                  `)
        }), (0, _preact.h)("span", {
            class: (0, _classnamesDefault.default)("Text", (0, _css.css)`
                text-align: center;
                width: 100%;
                white-space: nowrap;
                overflow: hidden !important;
                text-overflow: ellipsis;
                text-transform: capitalize;
                display: inline-block;
                width: 60px;
                position: absolute;
                bottom: 10px;
                left: 50%;
                margin-left: -30px;
              `),
            style: "display: inline-block; vertical-align: middle;"
        }, data2.name)));
    }));
};
const slideMenuParentCSS = "position: relative; &:hover > .slide-menu {transform: translate3d(0px, 0px, 0px) scale3d(1, 1, 1) rotateX(0deg) rotateY(0deg) rotateZ(0deg) skew(0deg, 0deg); opacity: 1; transform-style: preserve-3d;}";
const SlideMenu = ({ borderRadius , id  })=>{
    const { isMyItemOpened , deleteFromMy  } = (0, _hooks.useContext)(Context);
    if (!isMyItemOpened) return;
    const borderRadiusCSS = borderRadius ? `border-radius: ${borderRadius}px 0px 0px ${borderRadius}px;` : "";
    return (0, _preact.h)("div", {
        class: (0, _classnamesDefault.default)("slide-menu FolderItemMenu")
    }, (0, _preact.h)("div", {
        onClick: (e)=>deleteFromMy(e, id)
    }, "Delete"));
};
const HeartParentCSS = "position: relative; ";
const Heart = ({ id , audio , animation , environment  })=>{
    const { isMyItemOpened , myDataContains  } = (0, _hooks.useContext)(Context);
    if (isMyItemOpened) return; // if (!myDataContains(id))
    //   return (
    //     <div
    //       class={css`
    //         padding-left: 19px;
    //       `}
    //     ></div>
    //   )
    const Image1 = ()=>(0, _preact.h)("div", {
            class: (0, _classnamesDefault.default)(`${audio ? `heart ${myDataContains(id) ? "Like" : "Unlike"}` : ""}`, (0, _css.css)`
        background-color: ${environment ? "rgba(60,68,88,0.81)" : "none"};
        margin-right: ${environment ? "8px" : "0px"};
        padding: ${environment ? "4px" : "0px"};
        border-radius: ${audio ? "0px" : "0px 0px 6px 6px"};
      `)
        }, (0, _preact.h)("img", {
            class: (0, _css.css)`
          width: ${animation ? "30px" : audio ? "14px" : "18px"};
        `,
            src: myDataContains(id) ? "https://arcadestudio-assets.s3.us-east-2.amazonaws.com/engine-ui/heart-filled.svg" : "https://arcadestudio-assets.s3.us-east-2.amazonaws.com/engine-ui/heart-unfilled.svg"
        }));
    if (audio) return (0, _preact.h)(Image1, null);
    return (0, _preact.h)("div", {
        class: (0, _classnamesDefault.default)(`heart ${myDataContains(id) ? "Like" : "Unlike"}`, (0, _css.css)`
          opacity: ${environment ? "1 !important" : "unset"};
          margin: ${animation ? "12px" : "0px"};
          position: absolute;
          z-index: 1;
          left: auto;
          top: 0%;
          right: 0%;
          bottom: 0%;
          display: flex;
          width: auto;
          height: 100%;
          padding-top: 0%;
          padding-bottom: 0%;
          flex-direction: column;
          justify-content: space-around;
          align-items: center;
        `)
    }, (0, _preact.h)("div", {
        class: (0, _css.css)`
          display: -webkit-box;
          display: -webkit-flex;
          display: -ms-flexbox;
          display: flex;
          width: auto;
          height: 100%;
          -webkit-box-orient: vertical;
          -webkit-box-direction: normal;
          -webkit-flex-direction: column;
          -ms-flex-direction: column;
          flex-direction: column;
          -webkit-box-pack: justify;
          -webkit-justify-content: space-between;
          -ms-flex-pack: justify;
          justify-content: space-between;
          -webkit-box-align: center;
          -webkit-align-items: center;
          -ms-flex-align: center;
          align-items: center;
        `
    }, (0, _preact.h)(Image1, null)));
};
const CategoriesItem = ({ id , thumbUrl , name , onOpenItemClick , isMyData  })=>{
    const { myDataContains , myName , isMyItemOpened , onDragStart  } = (0, _hooks.useContext)(Context);
    const [status, setStatus] = (0, _hooks.useState)(false);
    function loadImage(url) {
        var image = new Image();
        image.src = url;
        return true;
    }
    return (0, _preact.h)("div", {
        onClick: (e)=>{
            onOpenItemClick(e);
            setTimeout(()=>{
                setStatus(myDataContains(id));
            }, 200);
        },
        draggable: isMyItemOpened,
        ondragstart: ()=>onDragStart(id),
        onContextMenu: (e)=>{
            e.preventDefault();
            e.stopPropagation();
            $(".slide-menu").hide();
            var { top , left  } = $(e.target).parent()[0].getBoundingClientRect();
            var folderItemMenu = $(e.target).parent().find(".slide-menu");
            folderItemMenu.css("left", e.clientX - left + "px");
            folderItemMenu.css("top", e.clientY - top + "px");
            folderItemMenu.show();
        },
        class: (0, _css.css)`
        position: relative;
        height: 167px;
        max-height: 167px;
        overflow: hidden;
        cursor: ${isMyItemOpened ? "initial" : "pointer"};

        &:first-child {
          margin-left: 0;
        }
        ${slideMenuParentCSS}
      `
    }, loadImage(thumbUrl) && (0, _preact.h)(SlideMenu, {
        id: id,
        borderRadius: 0
    }), (!isMyData || myName != "environment") && (0, _preact.h)(Heart, {
        id: id,
        status: status,
        environment: myName == "environment"
    }), (0, _preact.h)("div", {
        class: (0, _classnamesDefault.default)((0, _css.css)`
            position: absolute;
            height: 130px;
            width: 100%;
            background-position: ${isMyData ? "right" : "center"};
            background-size: cover;
            background-repeat: no-repeat;
          `, {
            [(0, _css.css)`
              //TODO: add condition
              //transition: all 3s;
              &:hover,
              &:focus {
                //transform: scale(1.3);
              }
            `]: (0, _reactDeviceDetect.isBrowser) && !isMyData && myName !== "environment"
        }),
        style: {
            backgroundImage: `url(${thumbUrl})`
        }
    }), (0, _preact.h)("div", {
        class: (0, _classnamesDefault.default)("categoryTitle", (0, _css.css)`
          position: absolute;
          bottom: 0;
          display: flex;
          flex-direction: row;
          justify-content: center;
          flex: 0 auto;
          width: 100%;
          height: 40px;
          margin: 0;
          padding: 0;
          padding-left: 10%;
          align-items: center;
          border-top: 0.5px none #1e2742;
          // border-bottom: 0.5px solid #1e2742;
          background-color: black;
          cursor: pointer;
        `)
    }, (0, _preact.h)("div", {
        class: (0, _css.css)`
            color: #7292db;
            font-size: 12px;
            font-weight: 400;
            flex: 1;
            font-family: Montserrat, sans-serif;
            text-transform: capitalize;
          `
    }, name)));
};
const LottieItem = ({ id , url , name  })=>{
    const { isMyItemOpened , onAddToMyClick , onDragStart , addingToMy  } = (0, _hooks.useContext)(Context);
    return (0, _preact.h)("div", {
        draggable: isMyItemOpened,
        ondragstart: ()=>onDragStart(id),
        class: (0, _css.css)`
        position: relative;
        margin-bottom: 0px;

        height: 100%;
        width: 100%;
        cursor: "pointer";

        ${slideMenuParentCSS}
      `,
        onClick: (e)=>onAddToMyClick(e, id),
        onContextMenu: (e)=>{
            e.preventDefault();
            e.stopPropagation();
            $(".slide-menu").hide();
            var { top , left  } = $(e.target).parent()[0].getBoundingClientRect();
            var folderItemMenu = $(e.target).parent().find(".slide-menu");
            folderItemMenu.css("left", e.clientX - left + "px");
            folderItemMenu.css("top", e.clientY - top + "px");
            folderItemMenu.show();
        }
    }, addingToMy(id) && (0, _preact.h)(Spinner, {
        isMasonry: true
    }), (0, _preact.h)(SlideMenu, {
        id: id,
        borderRadius: 0
    }), (0, _preact.h)(Heart, {
        id: id,
        animation: true
    }), (0, _preact.h)((0, _reactLottiePlayerDefault.default), {
        style: {
            height: "400px"
        },
        path: url,
        class: (0, _css.css)`
          display: flex;
          align-items: center;
          justify-content: center;
          height: 90%;

          border-style: solid;
          border-width: 1px;
          border-color: #1e2742;
          background-color: transparent;

          & > svg {
            display: block;
          }
        `,
        loop: true,
        play: true
    }), (0, _preact.h)("div", {
        class: (0, _css.css)`
          display: flex;
          align-items: center;
          height: 25px;
          padding-left: 10px;
          align-items: center;
          border-style: none solid solid;
          border-width: 1px;
          border-color: #1e2742;
          background-color: black;
          font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
            Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;
          color: #7292db;
          font-size: 12px;
          line-height: 12px;
          font-weight: 200;
          white-space: nowrap;
        `
    }, name));
};
const Audio = ({ id , name , src , activeAudio , setActiveAudio  })=>{
    const player = (0, _hooks.useRef)();
    const [playing, setPlaying] = (0, _hooks.useState)(false);
    const [duration, setDuration] = (0, _hooks.useState)("00:00");
    const { myDataContains , onAddToMyClick , isMyItemOpened , onDragStart  } = (0, _hooks.useContext)(Context);
    (0, _hooks.useEffect)(()=>{
        if (id != activeAudio && player) player.current.stop();
    }, [
        activeAudio
    ]);
    return (0, _preact.h)("div", {
        draggable: isMyItemOpened,
        ondragstart: ()=>onDragStart(id),
        onClick: (e)=>onAddToMyClick(e, id),
        class: (0, _classnamesDefault.default)("player", (0, _css.css)`
          position: relative;
          display: flex;
          height: 32px;
          margin-top: 0px;
          padding-right: 15px;
          padding-left: 15px;
          -webkit-box-pack: justify;
          justify-content: space-between;
          -webkit-box-align: center;
          align-items: center;
          border-top: 1px none rgba(0, 0, 0, 0.2);
          border-bottom: 1px solid rgba(0, 0, 0, 0.2);
          border-radius: 0px;
          background-color: transparent;
          font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
            Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;
          font-size: 12px;
          cursor: pointer;

          &:hover {
            background-color: #0f141e;
          }
          
          & > .duration {
            display: ${myDataContains(id) ? "none" : "block"}
          }

          &:hover >.duration {
            display: ${myDataContains(id) ? "block" : "none"}
          }
        `)
    }, (0, _preact.h)("div", {
        onClick: (e)=>{
            e.stopPropagation();
            setActiveAudio(id);
            playing ? setPlaying(false) : setPlaying(true);
        },
        class: (0, _css.css)`
          cursor: pointer;
        `
    }, playing ? (0, _preact.h)("div", {
        class: (0, _css.css)`
              display: flex;
              width: 12px;
              height: 12px;
              justify-content: center;
              -webkit-box-align: center;
              align-items: center;
              flex: 0 0 auto;
              border-style: solid;
              border-width: 1px;
              border-color: #7292db;
              background-color: #7292db;
            `
    }) : (0, _preact.h)("img", {
        src: "https://assets.website-files.com/616a041ea72c58e139ed3c8e/616a041ea72c582627ed3cb0_iconfinder-icon%20(3).svg",
        width: "9"
    })), (0, _preact.h)("div", {
        class: (0, _css.css)`
          padding-left: 15px;
          flex-grow: 1;
        `
    }, name), (0, _preact.h)("div", {
        class: "duration",
        style: {
            paddingRight: "4px"
        }
    }, duration), (0, _preact.h)(Heart, {
        id: id,
        audio: true
    }), (0, _preact.h)((0, _reactHowlerDefault.default), {
        onLoad: ()=>{
            setDuration(_dayjs(player.current.duration() * 1000).format("mm:ss.SSS"));
        },
        onEnd: ()=>{
            setPlaying(false);
        },
        onStop: ()=>{
            setPlaying(false);
        },
        ref: player,
        src: src,
        preload: false,
        html5: true,
        playing: playing
    }));
};
const Unsplash = ({})=>{
    const [loading, setLoading] = (0, _hooks.useState)(false);
    const [items, setItems] = (0, _hooks.useState)([]);
    const [hasNextPage, setHasNextPage] = (0, _hooks.useState)(true);
    const [error, setError] = (0, _hooks.useState)();
    const [query, setQuery] = (0, _hooks.useState)("");
    const debouncedSetQuery = (0, _useDebounce.useDebouncedCallback)((value)=>setQuery(value), 1000);
    const { addingToMy , uploadToMy  } = (0, _hooks.useContext)(Context);
    var unsplashID = "7uvLOvcJobn4kUszQ-ftApVAtjbt1wvq1oJTgKBlbPc";
    const getUrl = ()=>{
        const page = !items.length ? 1 : items.length / 20;
        if (query) return `https://api.unsplash.com/search/photos?client_id=${unsplashID}&query=${query}&page=${page}&per_page=20`;
        return `https://api.unsplash.com/photos?client_id=${unsplashID}&page=${page}&per_page=20`;
    };
    const loadMore = (isNewQuery)=>{
        setLoading(true);
        $.get(getUrl(), (data)=>{
            data = query ? data.results : data;
            isNewQuery ? setItems(data) : setItems((prev)=>[
                    ...prev,
                    ...data
                ]);
            setHasNextPage(true);
            setLoading(false); //        setError(err)
        });
    };
    (0, _hooks.useEffect)(()=>{
        loadMore(true);
    }, [
        query
    ]);
    const [infiniteRef] = (0, _reactInfiniteScrollHookDefault.default)({
        loading,
        hasNextPage,
        onLoadMore: loadMore,
        disabled: !!error,
        // `rootMargin` is passed to `IntersectionObserver`.
        // We can use it to trigger 'onLoadMore' when the sentry comes near to become
        // visible, instead of becoming fully visible on the screen.
        rootMargin: "0px 0px 400px 0px"
    });
    return (0, _preact.h)("div", {
        class: (0, _css.css)`
      display: flex;
      flex-direction: column;
      height: 100%;
    `
    }, (0, _preact.h)("div", {
        class: (0, _css.css)`
          padding-top: 30px;
          margin: 15px;
        `
    }, (0, _preact.h)("input", {
        type: "text",
        placeholder: "",
        onChange: (e)=>debouncedSetQuery(e.target.value),
        class: classes.searchInput
    }), (0, _preact.h)("a", {
        target: "_blank",
        href: "https://unsplash.com/",
        class: (0, _css.css)`
          margin-left: -70px;
          line-height: 30px;
        `
    }, "Unsplash")), (0, _preact.h)((0, _reactMasonryCssDefault.default), {
        breakpointCols: breakpointColumnsObj,
        className: (0, _css.css)`
          display: flex;
          margin-left: 0px; /* gutter size offset */
          padding-left: 16px;
          padding-right: 16px;
          width: auto;
          gap: 10px;
          flex: 1;
          overflow-y: scroll;
        `,
        columnClassName: (0, _css.css)`
          padding-left: 0px; /* gutter size */
          background-clip: padding-box;
          & > div {
            // background: grey;
            margin-bottom: 1rem;
          }
        `
    }, items.map((item)=>{
        return (0, _preact.h)("div", {
            class: (0, _css.css)`
                cursor: pointer;
                position: relative;
              `
        }, addingToMy(item.id) && (0, _preact.h)(Spinner, {
            isMasonry: true
        }), (0, _preact.h)("img", {
            key: item.id,
            onClick: (e)=>uploadToMy(e, "Image", item.urls.regular, item.id),
            src: item.urls.regular // loading="lazy"
            ,
            class: (0, _css.css)`
                  ${addingToMy(item.id) && ""}
                `
        }, item.name));
    })));
};
const Pixabay = ({})=>{
    const [loading, setLoading] = (0, _hooks.useState)(false);
    const [items, setItems] = (0, _hooks.useState)([]);
    const [hasNextPage, setHasNextPage] = (0, _hooks.useState)(true);
    const [error, setError] = (0, _hooks.useState)();
    const [query, setQuery] = (0, _hooks.useState)("");
    const debouncedSetQuery = (0, _useDebounce.useDebouncedCallback)((value)=>setQuery(value), 1000);
    const { addingToMy , uploadToMy  } = (0, _hooks.useContext)(Context);
    var pixabayKey = "15962911-94d039aef78b595bfb0bf5385";
    const loadMore = (isNewQuery)=>{
        setLoading(true);
        const page = !items.length ? 1 : items.length / 20;
        const url = `https://pixabay.com/api/videos/?key=${pixabayKey}&q=${query}&page=${page}`;
        $.get(url, (data)=>{
            data = data.hits.map(({ id , picture_id , videos , user  })=>{
                return {
                    id,
                    thumb: `https://i.vimeocdn.com/video/${picture_id}_295x166.jpg`,
                    url: videos.tiny.url,
                    name: user + "_" + id
                };
            });
            isNewQuery ? setItems(data) : setItems((prev)=>[
                    ...prev,
                    ...data
                ]);
            setHasNextPage(true);
            setLoading(false); // setError(err)
        }); //test
    // for (var i = 0; i < 10; i ++) {
    //   items.push(
    //     {
    //       id: 29 + i, thumb: "https://d1i82wgyy7ipwz.cloudfront.net/publishes/aa/thumbnail.jpg?Expires=1684839021&Key-Pair-Id=K2U1INTATTGJXK&Signature=wNX03aTlBq7updIOAkkqB4xqfaLAlCvM7CAkCGhRY0itHsI8NwULa8JvUtJtZ4tK-6hTPzV7gsRs2NgvMtmi~UQ92IhZL0I0jCznimzSjKzaABVgRM9M2cs1o6Tl-MfTAC~SyokQjwMZfEL~i5qaMO7sArKtv~Fc9X5Bui9c36BukL4veK622fZx8xrLwcekCwWzS2Tv26UpcHQS7h8LF4mq4PKmobzzW94Ww2qPe9S~rXbk0N4LvSt767BGwZ7gAOVVzQssqW6bZvJp1r51lo-J-KbFgG73~sEjhPsDn6OUO3SAVC3nW53MZZjiHcZspAbacGxrpJ1o4dpPH4kS2g__", 
    //       url: "https://d1i82wgyy7ipwz.cloudfront.net/publishes/aa/thumbnail.jpg?Expires=1684839021&Key-Pair-Id=K2U1INTATTGJXK&Signature=wNX03aTlBq7updIOAkkqB4xqfaLAlCvM7CAkCGhRY0itHsI8NwULa8JvUtJtZ4tK-6hTPzV7gsRs2NgvMtmi~UQ92IhZL0I0jCznimzSjKzaABVgRM9M2cs1o6Tl-MfTAC~SyokQjwMZfEL~i5qaMO7sArKtv~Fc9X5Bui9c36BukL4veK622fZx8xrLwcekCwWzS2Tv26UpcHQS7h8LF4mq4PKmobzzW94Ww2qPe9S~rXbk0N4LvSt767BGwZ7gAOVVzQssqW6bZvJp1r51lo-J-KbFgG73~sEjhPsDn6OUO3SAVC3nW53MZZjiHcZspAbacGxrpJ1o4dpPH4kS2g__", 
    //       name: "Videos"
    //     }
    //   );
    // }
    };
    (0, _hooks.useEffect)(()=>{
        loadMore(true);
    }, [
        query
    ]);
    const [infiniteRef] = (0, _reactInfiniteScrollHookDefault.default)({
        loading,
        hasNextPage,
        onLoadMore: loadMore,
        disabled: !!error,
        // `rootMargin` is passed to `IntersectionObserver`.
        // We can use it to trigger 'onLoadMore' when the sentry comes near to become
        // visible, instead of becoming fully visible on the screen.
        rootMargin: "0px 0px 400px 0px"
    });
    return (0, _preact.h)("div", {
        class: (0, _css.css)`
      display: flex;
      flex-direction: column;
      flex: 1;
      overflow: scroll;
    `
    }, (0, _preact.h)("div", {
        class: (0, _css.css)`
          padding-top: 30px;
          margin: 15px;
          margin-bottom: 0px;
        `
    }, (0, _preact.h)("input", {
        type: "text",
        placeholder: "",
        onChange: (e)=>debouncedSetQuery(e.target.value),
        class: classes.searchInput
    })), (0, _preact.h)("div", {
        class: (0, _css.css)`
          display: grid;
          --n: 4;
          flex: 1;
          padding: 16px;
          padding-top: 0px;
          gap: 10px;
          overflow-y: scroll;
          grid-template-columns: repeat(auto-fill, minmax(max(200px, 100% / var(--n)), 1fr));
        `
    }, items.map(({ id , thumb , url , name  })=>{
        if (url.indexOf("/progressive_redirect/") > 0) return; // if (addingToMy(id)) {
        //   return <Spinner />
        // }
        return (0, _preact.h)(PixabayVideo, {
            name: name,
            onUploadToMyClick: (e)=>uploadToMy(e, "Video", url, id),
            id: id,
            thumb: thumb,
            url: url
        });
    })));
};
const PixabayVideo = ({ id , url , thumb , onUploadToMyClick , name  })=>{
    const [preview, setPreview] = (0, _hooks.useState)(false);
    const [initialPreview, setInitialPreview] = (0, _hooks.useState)(false);
    const [loaded, setLoaded] = (0, _hooks.useState)(false);
    const { isMyItemOpened , onDragStart , addingToMy  } = (0, _hooks.useContext)(Context);
    const class_ = (0, _css.css)`
    width: 100%;
    cursor: pointer;
  `;
    return (0, _preact.h)("div", {
        key: id,
        onClick: (e)=>onUploadToMyClick(e),
        draggable: isMyItemOpened,
        ondragstart: ()=>onDragStart(id),
        onMouseEnter: ()=>{
            setInitialPreview(true);
            setPreview(true);
        },
        onMouseLeave: ()=>setPreview(false),
        onContextMenu: (e)=>{
            e.preventDefault();
            e.stopPropagation();
            $(".slide-menu").hide();
            var { top , left  } = $(e.target).parent()[0].getBoundingClientRect();
            var folderItemMenu = $(e.target).parent().find(".slide-menu");
            folderItemMenu.css("left", e.clientX - left + "px");
            folderItemMenu.css("top", e.clientY - top + "px");
            folderItemMenu.show();
        }
    }, (0, _preact.h)("div", {
        class: (0, _css.css)`
          overflow: hidden;
          ${slideMenuParentCSS}
        `
    }, addingToMy(id) && (0, _preact.h)(Spinner, {
        isMasonry: true
    }), (0, _preact.h)(SlideMenu, {
        id: id
    }), (0, _preact.h)(Heart, {
        id: id
    }), initialPreview && (0, _preact.h)("video", {
        onloadeddata: ()=>setLoaded(true),
        style: {
            display: preview && loaded ? "block" : "none"
        },
        class: class_,
        src: url,
        autoplay: true,
        muted: true
    }), thumb ? (0, _preact.h)("img", {
        class: class_,
        loading: "lazy",
        style: {
            display: preview && loaded ? "none" : "block"
        },
        src: thumb
    }) : (0, _preact.h)("video", {
        style: {
            display: preview && loaded ? "none" : "block"
        },
        class: class_,
        src: url + "#t=0.1",
        preload: "metadata",
        muted: true
    })));
};
class Menu extends (0, _preact.Component) {
    render({ onClick , portalMenu , activeItem  }, {}) {
        return (0, _preact.h)("div", null, menuItems.map((i)=>{
            return (0, _preact.h)("div", {
                onClick: ()=>onClick(i),
                className: (0, _classnamesDefault.default)("tab-item", "js-accordion-item", "portal-item", i.name, {
                    active: activeItem === i.name
                }, "show"),
                key: i.name
            }, (0, _preact.h)("div", {
                class: "js-accordion-header"
            }, i.name), (0, _preact.h)("div", {
                class: "js-accordion-body"
            }));
        }));
    }
}
const classes = {
    accordionTitle: (0, _css.css)`
    display: flex;
    width: 100%;
    align-self: center;
    flex: 1;
    color: #7292db;
    font-size: 12px;
    font-weight: 200;
    white-space: nowrap;
  `,
    searchInput: (0, _css.css)`
    flex: 1;
    font-size: 18px;
    font-weight: 200;
    padding-left: 40px;
    color: #7292db;
    cursor: pointer;
    outline: 0;
    border: 1px solid rgba(76, 110, 147, 0.32);
    height: 30px;
    line-height: 30px;
    width: 100%;
    color: #7292db;
    font-size: 12px;
    font-weight: 200;
    border-radius: 6px;
    background: url("https://assets.website-files.com/616a041ea72c58e139ed3c8e/616a041ea72c58e49bed3cf1_Engine-icons-search_icon.svg")
      no-repeat left;
    background-size: 17px;
    background-position: 12px;

    &::placeholder {
      /* Chrome, Firefox, Opera, Safari 10.1+ */
      color: #7292db;
      opacity: 1; /* Firefox */
    }
  `
};
const Spinner = ({ size =10 , isMasonry  })=>{
    const borderSize = 1.1 / 10 * size;
    return (0, _preact.h)("div", {
        class: (0, _css.css)`
        &,
        &:after {
          border-radius: 50%;
          width: ${size}em;
          height: ${size}em;
        }
        & {
          margin: auto;
          font-size: 10px;
          ${isMasonry ? `
          position: absolute;
          top: 0;
          bottom: 0;
          left: 0;
          right: 0;
          ` : `position: relative;`}

          text-indent: -9999em;
          border-top: ${borderSize}em solid rgba(255, 255, 255, 0.2);
          border-right: ${borderSize}em solid rgba(255, 255, 255, 0.2);
          border-bottom: ${borderSize}em solid rgba(255, 255, 255, 0.2);
          border-left: ${borderSize}em solid #ffffff;
          -webkit-transform: translateZ(0);
          -ms-transform: translateZ(0);
          transform: translateZ(0);
          -webkit-animation: load8 1.1s infinite linear;
          animation: load8 1.1s infinite linear;
        }
        @-webkit-keyframes load8 {
          0% {
            -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
          }
          100% {
            -webkit-transform: rotate(360deg);
            transform: rotate(360deg);
          }
        }
        @keyframes load8 {
          0% {
            -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
          }
          100% {
            -webkit-transform: rotate(360deg);
            transform: rotate(360deg);
          }
        }
      `
    });
};
const InlineEdit = ({ value , setValue , forceReadOnly  })=>{
    const [readOnly, setReadOnly] = (0, _hooks.useState)(true);
    const [editingValue, setEditingValue] = (0, _hooks.useState)(value);
    const onChange = (event)=>setEditingValue(event.target.value);
    const onKeyDown = (event)=>{
        if (event.key === "Enter" || event.key === "Escape") event.target.blur();
    };
    const onBlur = (event)=>{
        if (event.target.value.trim() === "") setEditingValue(value);
        else setValue(event.target.value);
        setReadOnly(true);
    };
    const onDoubleClick = (e)=>{
        e.stopPropagation();
        setReadOnly(false);
    };
    return (0, _preact.h)("input", {
        type: "text",
        value: editingValue,
        onChange: onChange,
        onKeyDown: onKeyDown,
        onBlur: onBlur,
        readOnly: forceReadOnly || readOnly,
        class: classes.accordionTitle,
        onDoubleClick: onDoubleClick,
        style: {
            cursor: readOnly ? "pointer" : ""
        }
    });
};
const parseData = (data)=>{
    if (Array.isArray(data)) return data;
    let newData = [];
    for (const [k1, v1] of Object.entries(data)){
        const r1 = {
            name: k1,
            id: v1.id,
            thumbUrl: v1.thumbUrl,
            items: []
        };
        for (const [k2, v2] of Object.entries(v1.children)){
            const r2 = {
                name: k2,
                id: v2.id,
                url: v2.url,
                thumbUrl: v2.thumbUrl
            };
            if (v2.children) {
                r1.accordion = true;
                r2.items = [];
                for (const [k3, v3] of Object.entries(v2.children)){
                    const r3 = {
                        id: v3.id,
                        name: k3,
                        url: v3.url,
                        thumbUrl: v3.thumbUrl
                    };
                    if (v3.children) {
                        r2.accordion = true;
                        r3.items = [];
                        for (const [k4, v4] of Object.entries(v3.children)){
                            const r4 = {
                                name: k4,
                                id: v4.id,
                                url: v4.url,
                                thumbUrl: v4.thumbUrl
                            };
                            r3.items.push(r4);
                        }
                    }
                    r2.items.push(r3);
                }
            }
            r1.items.push(r2);
        }
        newData.push(r1);
    }
    return newData;
};
const menuItems = [
    {
        name: "geometry",
        myName: "geometry",
        url: "/asset/geometry/list",
        exts: [
            "obj",
            "fbx"
        ]
    },
    {
        name: "materials",
        myName: "material",
        url: "/asset/material/list",
        exts: [
            "obj",
            "fbx"
        ]
    },
    {
        name: "images",
        myName: "image",
        url: "/asset/image/list",
        exts: [
            "obj",
            "fbx"
        ]
    },
    {
        name: "audio",
        myName: "audio",
        url: "/asset/audio/list",
        exts: [
            "obj",
            "fbx"
        ]
    },
    {
        name: "video",
        myName: "video",
        exts: [
            "obj",
            "fbx"
        ]
    },
    {
        name: "animation",
        myName: "animation",
        url: "/asset/animation/list",
        exts: [
            "obj",
            "fbx"
        ]
    },
    {
        name: "environment",
        myName: "environment",
        url: "/asset/environment/list",
        exts: [
            "obj",
            "fbx"
        ]
    }
];
const breakpointColumnsObj = {
    default: 2,
    1100: 2,
    700: 2,
    500: 1
};
const insert = (arr, index, newItem)=>[
        ...arr.slice(0, index),
        newItem,
        ...arr.slice(index)
    ];
(0, _preact.render)((0, _preact.h)(Tabs, null), document.getElementById("js-accordion-assets"));
if (module.hot) module.hot.accept();

},{"@babel/runtime/helpers/defineProperty":"lORDb","preact":"6u3ew","preact/hooks":"lwCAI","preact/compat":"2kGyk","classnames":"1giFm","react-masonry-css":"k4J8U","preact-context-menu":"6VquX","@emotion/css":"hRDYn","dayjs":"kYP2X","dayjs/plugin/utc":"g4LUz","react-lottie-player":"3M5EC","react-animate-height":"AGLTb","react-responsive-masonry":"h3scm","react-infinite-scroll-hook":"knIBK","use-debounce":"3TmwF","react-howler":"2hWPw","react-device-detect":"dyTgj","@parcel/transformer-js/src/esmodule-helpers.js":"hqSvo"}],"lORDb":[function(require,module,exports) {
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;

},{}],"6u3ew":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Component", ()=>d);
parcelHelpers.export(exports, "Fragment", ()=>p);
parcelHelpers.export(exports, "cloneElement", ()=>q);
parcelHelpers.export(exports, "createContext", ()=>B);
parcelHelpers.export(exports, "createElement", ()=>h);
parcelHelpers.export(exports, "createRef", ()=>y);
parcelHelpers.export(exports, "h", ()=>h);
parcelHelpers.export(exports, "hydrate", ()=>S);
parcelHelpers.export(exports, "isValidElement", ()=>i);
parcelHelpers.export(exports, "options", ()=>l);
parcelHelpers.export(exports, "render", ()=>P);
parcelHelpers.export(exports, "toChildArray", ()=>x);
var n, l, u, i, t, o, r, f = {}, e = [], c = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
function s(n, l) {
    for(var u in l)n[u] = l[u];
    return n;
}
function a(n) {
    var l = n.parentNode;
    l && l.removeChild(n);
}
function h(l, u, i) {
    var t, o, r, f = {};
    for(r in u)"key" == r ? t = u[r] : "ref" == r ? o = u[r] : f[r] = u[r];
    if (arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), "function" == typeof l && null != l.defaultProps) for(r in l.defaultProps)void 0 === f[r] && (f[r] = l.defaultProps[r]);
    return v(l, f, t, o, null);
}
function v(n, i, t, o, r) {
    var f = {
        type: n,
        props: i,
        key: t,
        ref: o,
        __k: null,
        __: null,
        __b: 0,
        __e: null,
        __d: void 0,
        __c: null,
        __h: null,
        constructor: void 0,
        __v: null == r ? ++u : r
    };
    return null == r && null != l.vnode && l.vnode(f), f;
}
function y() {
    return {
        current: null
    };
}
function p(n) {
    return n.children;
}
function d(n, l) {
    this.props = n, this.context = l;
}
function _(n, l) {
    if (null == l) return n.__ ? _(n.__, n.__.__k.indexOf(n) + 1) : null;
    for(var u; l < n.__k.length; l++)if (null != (u = n.__k[l]) && null != u.__e) return u.__e;
    return "function" == typeof n.type ? _(n) : null;
}
function k(n) {
    var l, u;
    if (null != (n = n.__) && null != n.__c) {
        for(n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++)if (null != (u = n.__k[l]) && null != u.__e) {
            n.__e = n.__c.base = u.__e;
            break;
        }
        return k(n);
    }
}
function b(n) {
    (!n.__d && (n.__d = !0) && t.push(n) && !g.__r++ || o !== l.debounceRendering) && ((o = l.debounceRendering) || setTimeout)(g);
}
function g() {
    for(var n; g.__r = t.length;)n = t.sort(function(n, l) {
        return n.__v.__b - l.__v.__b;
    }), t = [], n.some(function(n) {
        var l, u, i, t, o, r;
        n.__d && (o = (t = (l = n).__v).__e, (r = l.__P) && (u = [], (i = s({}, t)).__v = t.__v + 1, j(r, t, i, l.__n, void 0 !== r.ownerSVGElement, null != t.__h ? [
            o
        ] : null, u, null == o ? _(t) : o, t.__h), z(u, t), t.__e != o && k(t)));
    });
}
function w(n, l, u, i, t, o, r, c, s, a) {
    var h, y, d, k, b, g, w, x = i && i.__k || e, C = x.length;
    for(u.__k = [], h = 0; h < l.length; h++)if (null != (k = u.__k[h] = null == (k = l[h]) || "boolean" == typeof k ? null : "string" == typeof k || "number" == typeof k || "bigint" == typeof k ? v(null, k, null, null, k) : Array.isArray(k) ? v(p, {
        children: k
    }, null, null, null) : k.__b > 0 ? v(k.type, k.props, k.key, k.ref ? k.ref : null, k.__v) : k)) {
        if (k.__ = u, k.__b = u.__b + 1, null === (d = x[h]) || d && k.key == d.key && k.type === d.type) x[h] = void 0;
        else for(y = 0; y < C; y++){
            if ((d = x[y]) && k.key == d.key && k.type === d.type) {
                x[y] = void 0;
                break;
            }
            d = null;
        }
        j(n, k, d = d || f, t, o, r, c, s, a), b = k.__e, (y = k.ref) && d.ref != y && (w || (w = []), d.ref && w.push(d.ref, null, k), w.push(y, k.__c || b, k)), null != b ? (null == g && (g = b), "function" == typeof k.type && k.__k === d.__k ? k.__d = s = m(k, s, n) : s = A(n, k, d, x, b, s), "function" == typeof u.type && (u.__d = s)) : s && d.__e == s && s.parentNode != n && (s = _(d));
    }
    for(u.__e = g, h = C; h--;)null != x[h] && ("function" == typeof u.type && null != x[h].__e && x[h].__e == u.__d && (u.__d = _(i, h + 1)), N(x[h], x[h]));
    if (w) for(h = 0; h < w.length; h++)M(w[h], w[++h], w[++h]);
}
function m(n, l, u) {
    for(var i, t = n.__k, o = 0; t && o < t.length; o++)(i = t[o]) && (i.__ = n, l = "function" == typeof i.type ? m(i, l, u) : A(u, i, i, t, i.__e, l));
    return l;
}
function x(n, l) {
    return l = l || [], null == n || "boolean" == typeof n || (Array.isArray(n) ? n.some(function(n) {
        x(n, l);
    }) : l.push(n)), l;
}
function A(n, l, u, i, t, o) {
    var r, f, e;
    if (void 0 !== l.__d) r = l.__d, l.__d = void 0;
    else if (null == u || t != o || null == t.parentNode) n: if (null == o || o.parentNode !== n) n.appendChild(t), r = null;
    else {
        for(f = o, e = 0; (f = f.nextSibling) && e < i.length; e += 2)if (f == t) break n;
        n.insertBefore(t, o), r = o;
    }
    return void 0 !== r ? r : t.nextSibling;
}
function C(n, l, u, i, t) {
    var o;
    for(o in u)"children" === o || "key" === o || o in l || H(n, o, null, u[o], i);
    for(o in l)t && "function" != typeof l[o] || "children" === o || "key" === o || "value" === o || "checked" === o || u[o] === l[o] || H(n, o, l[o], u[o], i);
}
function $(n, l, u) {
    "-" === l[0] ? n.setProperty(l, u) : n[l] = null == u ? "" : "number" != typeof u || c.test(l) ? u : u + "px";
}
function H(n, l, u, i, t) {
    var o;
    n: if ("style" === l) {
        if ("string" == typeof u) n.style.cssText = u;
        else {
            if ("string" == typeof i && (n.style.cssText = i = ""), i) for(l in i)u && l in u || $(n.style, l, "");
            if (u) for(l in u)i && u[l] === i[l] || $(n.style, l, u[l]);
        }
    } else if ("o" === l[0] && "n" === l[1]) o = l !== (l = l.replace(/Capture$/, "")), l = l.toLowerCase() in n ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + o] = u, u ? i || n.addEventListener(l, o ? T : I, o) : n.removeEventListener(l, o ? T : I, o);
    else if ("dangerouslySetInnerHTML" !== l) {
        if (t) l = l.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
        else if ("href" !== l && "list" !== l && "form" !== l && "tabIndex" !== l && "download" !== l && l in n) try {
            n[l] = null == u ? "" : u;
            break n;
        } catch (n) {}
        "function" == typeof u || (null != u && (!1 !== u || "a" === l[0] && "r" === l[1]) ? n.setAttribute(l, u) : n.removeAttribute(l));
    }
}
function I(n) {
    this.l[n.type + !1](l.event ? l.event(n) : n);
}
function T(n) {
    this.l[n.type + !0](l.event ? l.event(n) : n);
}
function j(n, u, i, t, o, r, f, e, c) {
    var a, h, v, y, _, k, b, g, m, x, A, C, $, H = u.type;
    if (void 0 !== u.constructor) return null;
    null != i.__h && (c = i.__h, e = u.__e = i.__e, u.__h = null, r = [
        e
    ]), (a = l.__b) && a(u);
    try {
        n: if ("function" == typeof H) {
            if (g = u.props, m = (a = H.contextType) && t[a.__c], x = a ? m ? m.props.value : a.__ : t, i.__c ? b = (h = u.__c = i.__c).__ = h.__E : ("prototype" in H && H.prototype.render ? u.__c = h = new H(g, x) : (u.__c = h = new d(g, x), h.constructor = H, h.render = O), m && m.sub(h), h.props = g, h.state || (h.state = {}), h.context = x, h.__n = t, v = h.__d = !0, h.__h = []), null == h.__s && (h.__s = h.state), null != H.getDerivedStateFromProps && (h.__s == h.state && (h.__s = s({}, h.__s)), s(h.__s, H.getDerivedStateFromProps(g, h.__s))), y = h.props, _ = h.state, v) null == H.getDerivedStateFromProps && null != h.componentWillMount && h.componentWillMount(), null != h.componentDidMount && h.__h.push(h.componentDidMount);
            else {
                if (null == H.getDerivedStateFromProps && g !== y && null != h.componentWillReceiveProps && h.componentWillReceiveProps(g, x), !h.__e && null != h.shouldComponentUpdate && !1 === h.shouldComponentUpdate(g, h.__s, x) || u.__v === i.__v) {
                    h.props = g, h.state = h.__s, u.__v !== i.__v && (h.__d = !1), h.__v = u, u.__e = i.__e, u.__k = i.__k, u.__k.forEach(function(n) {
                        n && (n.__ = u);
                    }), h.__h.length && f.push(h);
                    break n;
                }
                null != h.componentWillUpdate && h.componentWillUpdate(g, h.__s, x), null != h.componentDidUpdate && h.__h.push(function() {
                    h.componentDidUpdate(y, _, k);
                });
            }
            if (h.context = x, h.props = g, h.__v = u, h.__P = n, A = l.__r, C = 0, "prototype" in H && H.prototype.render) h.state = h.__s, h.__d = !1, A && A(u), a = h.render(h.props, h.state, h.context);
            else do h.__d = !1, A && A(u), a = h.render(h.props, h.state, h.context), h.state = h.__s;
            while (h.__d && ++C < 25);
            h.state = h.__s, null != h.getChildContext && (t = s(s({}, t), h.getChildContext())), v || null == h.getSnapshotBeforeUpdate || (k = h.getSnapshotBeforeUpdate(y, _)), $ = null != a && a.type === p && null == a.key ? a.props.children : a, w(n, Array.isArray($) ? $ : [
                $
            ], u, i, t, o, r, f, e, c), h.base = u.__e, u.__h = null, h.__h.length && f.push(h), b && (h.__E = h.__ = null), h.__e = !1;
        } else null == r && u.__v === i.__v ? (u.__k = i.__k, u.__e = i.__e) : u.__e = L(i.__e, u, i, t, o, r, f, c);
        (a = l.diffed) && a(u);
    } catch (n) {
        u.__v = null, (c || null != r) && (u.__e = e, u.__h = !!c, r[r.indexOf(e)] = null), l.__e(n, u, i);
    }
}
function z(n, u) {
    l.__c && l.__c(u, n), n.some(function(u) {
        try {
            n = u.__h, u.__h = [], n.some(function(n) {
                n.call(u);
            });
        } catch (n) {
            l.__e(n, u.__v);
        }
    });
}
function L(l, u, i, t, o, r, e, c) {
    var s, h, v, y = i.props, p = u.props, d = u.type, k = 0;
    if ("svg" === d && (o = !0), null != r) {
        for(; k < r.length; k++)if ((s = r[k]) && "setAttribute" in s == !!d && (d ? s.localName === d : 3 === s.nodeType)) {
            l = s, r[k] = null;
            break;
        }
    }
    if (null == l) {
        if (null === d) return document.createTextNode(p);
        l = o ? document.createElementNS("http://www.w3.org/2000/svg", d) : document.createElement(d, p.is && p), r = null, c = !1;
    }
    if (null === d) y === p || c && l.data === p || (l.data = p);
    else {
        if (r = r && n.call(l.childNodes), h = (y = i.props || f).dangerouslySetInnerHTML, v = p.dangerouslySetInnerHTML, !c) {
            if (null != r) for(y = {}, k = 0; k < l.attributes.length; k++)y[l.attributes[k].name] = l.attributes[k].value;
            (v || h) && (v && (h && v.__html == h.__html || v.__html === l.innerHTML) || (l.innerHTML = v && v.__html || ""));
        }
        if (C(l, p, y, o, c), v) u.__k = [];
        else if (k = u.props.children, w(l, Array.isArray(k) ? k : [
            k
        ], u, i, t, o && "foreignObject" !== d, r, e, r ? r[0] : i.__k && _(i, 0), c), null != r) for(k = r.length; k--;)null != r[k] && a(r[k]);
        c || ("value" in p && void 0 !== (k = p.value) && (k !== l.value || "progress" === d && !k || "option" === d && k !== y.value) && H(l, "value", k, y.value, !1), "checked" in p && void 0 !== (k = p.checked) && k !== l.checked && H(l, "checked", k, y.checked, !1));
    }
    return l;
}
function M(n, u, i) {
    try {
        "function" == typeof n ? n(u) : n.current = u;
    } catch (n) {
        l.__e(n, i);
    }
}
function N(n, u, i) {
    var t, o;
    if (l.unmount && l.unmount(n), (t = n.ref) && (t.current && t.current !== n.__e || M(t, null, u)), null != (t = n.__c)) {
        if (t.componentWillUnmount) try {
            t.componentWillUnmount();
        } catch (n) {
            l.__e(n, u);
        }
        t.base = t.__P = null, n.__c = void 0;
    }
    if (t = n.__k) for(o = 0; o < t.length; o++)t[o] && N(t[o], u, "function" != typeof n.type);
    i || null == n.__e || a(n.__e), n.__ = n.__e = n.__d = void 0;
}
function O(n, l, u) {
    return this.constructor(n, u);
}
function P(u, i, t) {
    var o, r, e;
    l.__ && l.__(u, i), r = (o = "function" == typeof t) ? null : t && t.__k || i.__k, e = [], j(i, u = (!o && t || i).__k = h(p, null, [
        u
    ]), r || f, f, void 0 !== i.ownerSVGElement, !o && t ? [
        t
    ] : r ? null : i.firstChild ? n.call(i.childNodes) : null, e, !o && t ? t : r ? r.__e : i.firstChild, o), z(e, u);
}
function S(n, l) {
    P(n, l, S);
}
function q(l, u, i) {
    var t, o, r, f = s({}, l.props);
    for(r in u)"key" == r ? t = u[r] : "ref" == r ? o = u[r] : f[r] = u[r];
    return arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), v(l.type, f, t || l.key, o || l.ref, null);
}
function B(n, l) {
    var u = {
        __c: l = "__cC" + r++,
        __: n,
        Consumer: function(n, l) {
            return n.children(l);
        },
        Provider: function(n) {
            var u, i;
            return this.getChildContext || (u = [], (i = {})[l] = this, this.getChildContext = function() {
                return i;
            }, this.shouldComponentUpdate = function(n) {
                this.props.value !== n.value && u.some(b);
            }, this.sub = function(n) {
                u.push(n);
                var l = n.componentWillUnmount;
                n.componentWillUnmount = function() {
                    u.splice(u.indexOf(n), 1), l && l.call(n);
                };
            }), n.children;
        }
    };
    return u.Provider.__ = u.Consumer.contextType = u;
}
n = e.slice, l = {
    __e: function(n, l, u, i) {
        for(var t, o, r; l = l.__;)if ((t = l.__c) && !t.__) try {
            if ((o = t.constructor) && null != o.getDerivedStateFromError && (t.setState(o.getDerivedStateFromError(n)), r = t.__d), null != t.componentDidCatch && (t.componentDidCatch(n, i || {}), r = t.__d), r) return t.__E = t;
        } catch (l) {
            n = l;
        }
        throw n;
    }
}, u = 0, i = function(n) {
    return null != n && void 0 === n.constructor;
}, d.prototype.setState = function(n, l) {
    var u;
    u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = s({}, this.state), "function" == typeof n && (n = n(s({}, u), this.props)), n && s(u, n), null != n && this.__v && (l && this.__h.push(l), b(this));
}, d.prototype.forceUpdate = function(n) {
    this.__v && (this.__e = !0, n && this.__h.push(n), b(this));
}, d.prototype.render = p, t = [], g.__r = 0, r = 0;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"hqSvo"}],"hqSvo":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"lwCAI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useCallback", ()=>q);
parcelHelpers.export(exports, "useContext", ()=>x);
parcelHelpers.export(exports, "useDebugValue", ()=>P);
parcelHelpers.export(exports, "useEffect", ()=>s);
parcelHelpers.export(exports, "useErrorBoundary", ()=>V);
parcelHelpers.export(exports, "useId", ()=>b);
parcelHelpers.export(exports, "useImperativeHandle", ()=>F);
parcelHelpers.export(exports, "useLayoutEffect", ()=>_);
parcelHelpers.export(exports, "useMemo", ()=>T);
parcelHelpers.export(exports, "useReducer", ()=>h);
parcelHelpers.export(exports, "useRef", ()=>A);
parcelHelpers.export(exports, "useState", ()=>y);
var _preact = require("preact");
var r, u, i, o, f = 0, c = [], e = [], a = (0, _preact.options).__b, v = (0, _preact.options).__r, l = (0, _preact.options).diffed, m = (0, _preact.options).__c, d = (0, _preact.options).unmount;
function p(t, r) {
    (0, _preact.options).__h && (0, _preact.options).__h(u, t, f || r), f = 0;
    var i = u.__H || (u.__H = {
        __: [],
        __h: []
    });
    return t >= i.__.length && i.__.push({
        __V: e
    }), i.__[t];
}
function y(n) {
    return f = 1, h(C, n);
}
function h(n, t, i) {
    var o = p(r++, 2);
    if (o.t = n, !o.__c && (o.__ = [
        i ? i(t) : C(void 0, t),
        function(n) {
            var t = o.__N ? o.__N[0] : o.__[0], r = o.t(t, n);
            t !== r && (o.__N = [
                r,
                o.__[1]
            ], o.__c.setState({}));
        }
    ], o.__c = u, !u.u)) {
        u.u = !0;
        var f = u.shouldComponentUpdate;
        u.shouldComponentUpdate = function(n, t, r) {
            if (!o.__c.__H) return !0;
            var u = o.__c.__H.__.filter(function(n) {
                return n.__c;
            });
            if (u.every(function(n) {
                return !n.__N;
            })) return !f || f.call(this, n, t, r);
            var i = !1;
            return u.forEach(function(n) {
                if (n.__N) {
                    var t = n.__[0];
                    n.__ = n.__N, n.__N = void 0, t !== n.__[0] && (i = !0);
                }
            }), !!i && (!f || f.call(this, n, t, r));
        };
    }
    return o.__N || o.__;
}
function s(t, i) {
    var o = p(r++, 3);
    !(0, _preact.options).__s && B(o.__H, i) && (o.__ = t, o.i = i, u.__H.__h.push(o));
}
function _(t, i) {
    var o = p(r++, 4);
    !(0, _preact.options).__s && B(o.__H, i) && (o.__ = t, o.i = i, u.__h.push(o));
}
function A(n) {
    return f = 5, T(function() {
        return {
            current: n
        };
    }, []);
}
function F(n, t, r) {
    f = 6, _(function() {
        return "function" == typeof n ? (n(t()), function() {
            return n(null);
        }) : n ? (n.current = t(), function() {
            return n.current = null;
        }) : void 0;
    }, null == r ? r : r.concat(n));
}
function T(n, t) {
    var u = p(r++, 7);
    return B(u.__H, t) ? (u.__V = n(), u.i = t, u.__h = n, u.__V) : u.__;
}
function q(n, t) {
    return f = 8, T(function() {
        return n;
    }, t);
}
function x(n) {
    var t = u.context[n.__c], i = p(r++, 9);
    return i.c = n, t ? (null == i.__ && (i.__ = !0, t.sub(u)), t.props.value) : n.__;
}
function P(t, r) {
    (0, _preact.options).useDebugValue && (0, _preact.options).useDebugValue(r ? r(t) : t);
}
function V(n) {
    var t = p(r++, 10), i = y();
    return t.__ = n, u.componentDidCatch || (u.componentDidCatch = function(n, r) {
        t.__ && t.__(n, r), i[1](n);
    }), [
        i[0],
        function() {
            i[1](void 0);
        }
    ];
}
function b() {
    var n = p(r++, 11);
    return n.__ || (n.__ = "P" + function(n) {
        for(var t = 0, r = n.length; r > 0;)t = (t << 5) - t + n.charCodeAt(--r) | 0;
        return t;
    }(u.__v.o) + r), n.__;
}
function g() {
    for(var t; t = c.shift();)if (t.__P && t.__H) try {
        t.__H.__h.forEach(w), t.__H.__h.forEach(z), t.__H.__h = [];
    } catch (r) {
        t.__H.__h = [], (0, _preact.options).__e(r, t.__v);
    }
}
(0, _preact.options).__b = function(n) {
    "function" != typeof n.type || n.o || n.type === (0, _preact.Fragment) ? n.o || (n.o = n.__ && n.__.o ? n.__.o : "") : n.o = (n.__ && n.__.o ? n.__.o : "") + (n.__ && n.__.__k ? n.__.__k.indexOf(n) : 0), u = null, a && a(n);
}, (0, _preact.options).__r = function(n) {
    v && v(n), r = 0;
    var t = (u = n.__c).__H;
    t && (i === u ? (t.__h = [], u.__h = [], t.__.forEach(function(n) {
        n.__N && (n.__ = n.__N), n.__V = e, n.__N = n.i = void 0;
    })) : (t.__h.forEach(w), t.__h.forEach(z), t.__h = [])), i = u;
}, (0, _preact.options).diffed = function(t) {
    l && l(t);
    var r = t.__c;
    r && r.__H && (r.__H.__h.length && (1 !== c.push(r) && o === (0, _preact.options).requestAnimationFrame || ((o = (0, _preact.options).requestAnimationFrame) || k)(g)), r.__H.__.forEach(function(n) {
        n.i && (n.__H = n.i), n.__V !== e && (n.__ = n.__V), n.i = void 0, n.__V = e;
    })), i = u = null;
}, (0, _preact.options).__c = function(t, r) {
    r.some(function(t) {
        try {
            t.__h.forEach(w), t.__h = t.__h.filter(function(n) {
                return !n.__ || z(n);
            });
        } catch (u) {
            r.some(function(n) {
                n.__h && (n.__h = []);
            }), r = [], (0, _preact.options).__e(u, t.__v);
        }
    }), m && m(t, r);
}, (0, _preact.options).unmount = function(t) {
    d && d(t);
    var r, u = t.__c;
    u && u.__H && (u.__H.__.forEach(function(n) {
        try {
            w(n);
        } catch (n) {
            r = n;
        }
    }), u.__H = void 0, r && (0, _preact.options).__e(r, u.__v));
};
var j = "function" == typeof requestAnimationFrame;
function k(n) {
    var t, r = function() {
        clearTimeout(u), j && cancelAnimationFrame(t), setTimeout(n);
    }, u = setTimeout(r, 100);
    j && (t = requestAnimationFrame(r));
}
function w(n) {
    var t = u, r = n.__c;
    "function" == typeof r && (n.__c = void 0, r()), u = t;
}
function z(n) {
    var t = u;
    n.__c = n.__(), u = t;
}
function B(n, t) {
    return !n || n.length !== t.length || t.some(function(t, r) {
        return t !== n[r];
    });
}
function C(n, t) {
    return "function" == typeof t ? t(n) : t;
}

},{"preact":"6u3ew","@parcel/transformer-js/src/esmodule-helpers.js":"hqSvo"}],"2kGyk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Component", ()=>(0, _preact.Component));
parcelHelpers.export(exports, "Fragment", ()=>(0, _preact.Fragment));
parcelHelpers.export(exports, "createContext", ()=>(0, _preact.createContext));
parcelHelpers.export(exports, "createElement", ()=>(0, _preact.createElement));
parcelHelpers.export(exports, "createRef", ()=>(0, _preact.createRef));
parcelHelpers.export(exports, "Children", ()=>A);
parcelHelpers.export(exports, "PureComponent", ()=>E);
parcelHelpers.export(exports, "StrictMode", ()=>hn);
parcelHelpers.export(exports, "Suspense", ()=>U);
parcelHelpers.export(exports, "SuspenseList", ()=>M);
parcelHelpers.export(exports, "__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED", ()=>en);
parcelHelpers.export(exports, "cloneElement", ()=>ln);
parcelHelpers.export(exports, "createFactory", ()=>un);
parcelHelpers.export(exports, "createPortal", ()=>$);
parcelHelpers.export(exports, "default", ()=>_n);
parcelHelpers.export(exports, "findDOMNode", ()=>fn);
parcelHelpers.export(exports, "flushSync", ()=>sn);
parcelHelpers.export(exports, "forwardRef", ()=>N);
parcelHelpers.export(exports, "hydrate", ()=>Y);
parcelHelpers.export(exports, "isValidElement", ()=>on);
parcelHelpers.export(exports, "lazy", ()=>F);
parcelHelpers.export(exports, "memo", ()=>w);
parcelHelpers.export(exports, "render", ()=>Z);
parcelHelpers.export(exports, "startTransition", ()=>vn);
parcelHelpers.export(exports, "unmountComponentAtNode", ()=>cn);
parcelHelpers.export(exports, "unstable_batchedUpdates", ()=>an);
parcelHelpers.export(exports, "useDeferredValue", ()=>dn);
parcelHelpers.export(exports, "useInsertionEffect", ()=>mn);
parcelHelpers.export(exports, "useSyncExternalStore", ()=>yn);
parcelHelpers.export(exports, "useTransition", ()=>pn);
parcelHelpers.export(exports, "version", ()=>rn);
var _preact = require("preact");
var _hooks = require("preact/hooks");
parcelHelpers.exportAll(_hooks, exports);
function g(n, t) {
    for(var e in t)n[e] = t[e];
    return n;
}
function C(n, t) {
    for(var e in n)if ("__source" !== e && !(e in t)) return !0;
    for(var r in t)if ("__source" !== r && n[r] !== t[r]) return !0;
    return !1;
}
function E(n) {
    this.props = n;
}
function w(n, e) {
    function r(n) {
        var t = this.props.ref, r = t == n.ref;
        return !r && t && (t.call ? t(null) : t.current = null), e ? !e(this.props, n) || !r : C(this.props, n);
    }
    function u(e) {
        return this.shouldComponentUpdate = r, (0, _preact.createElement)(n, e);
    }
    return u.displayName = "Memo(" + (n.displayName || n.name) + ")", u.prototype.isReactComponent = !0, u.__f = !0, u;
}
(E.prototype = new (0, _preact.Component)).isPureReactComponent = !0, E.prototype.shouldComponentUpdate = function(n, t) {
    return C(this.props, n) || C(this.state, t);
};
var R = (0, _preact.options).__b;
(0, _preact.options).__b = function(n) {
    n.type && n.type.__f && n.ref && (n.props.ref = n.ref, n.ref = null), R && R(n);
};
var x = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
function N(n) {
    function t(t) {
        var e = g({}, t);
        return delete e.ref, n(e, t.ref || null);
    }
    return t.$$typeof = x, t.render = t, t.prototype.isReactComponent = t.__f = !0, t.displayName = "ForwardRef(" + (n.displayName || n.name) + ")", t;
}
var k = function(n, t) {
    return null == n ? null : (0, _preact.toChildArray)((0, _preact.toChildArray)(n).map(t));
}, A = {
    map: k,
    forEach: k,
    count: function(n) {
        return n ? (0, _preact.toChildArray)(n).length : 0;
    },
    only: function(n) {
        var t = (0, _preact.toChildArray)(n);
        if (1 !== t.length) throw "Children.only";
        return t[0];
    },
    toArray: (0, _preact.toChildArray)
}, O = (0, _preact.options).__e;
(0, _preact.options).__e = function(n, t, e, r) {
    if (n.then) {
        for(var u, o = t; o = o.__;)if ((u = o.__c) && u.__c) return null == t.__e && (t.__e = e.__e, t.__k = e.__k), u.__c(n, t);
    }
    O(n, t, e, r);
};
var T = (0, _preact.options).unmount;
function I(n, t, e) {
    return n && (n.__c && n.__c.__H && (n.__c.__H.__.forEach(function(n) {
        "function" == typeof n.__c && n.__c();
    }), n.__c.__H = null), null != (n = g({}, n)).__c && (n.__c.__P === e && (n.__c.__P = t), n.__c = null), n.__k = n.__k && n.__k.map(function(n) {
        return I(n, t, e);
    })), n;
}
function L(n, t, e) {
    return n && (n.__v = null, n.__k = n.__k && n.__k.map(function(n) {
        return L(n, t, e);
    }), n.__c && n.__c.__P === t && (n.__e && e.insertBefore(n.__e, n.__d), n.__c.__e = !0, n.__c.__P = e)), n;
}
function U() {
    this.__u = 0, this.t = null, this.__b = null;
}
function D(n) {
    var t = n.__.__c;
    return t && t.__a && t.__a(n);
}
function F(n) {
    var e, r, u;
    function o(o) {
        if (e || (e = n()).then(function(n) {
            r = n.default || n;
        }, function(n) {
            u = n;
        }), u) throw u;
        if (!r) throw e;
        return (0, _preact.createElement)(r, o);
    }
    return o.displayName = "Lazy", o.__f = !0, o;
}
function M() {
    this.u = null, this.o = null;
}
(0, _preact.options).unmount = function(n) {
    var t = n.__c;
    t && t.__R && t.__R(), t && !0 === n.__h && (n.type = null), T && T(n);
}, (U.prototype = new (0, _preact.Component)).__c = function(n, t) {
    var e = t.__c, r = this;
    null == r.t && (r.t = []), r.t.push(e);
    var u = D(r.__v), o = !1, i = function() {
        o || (o = !0, e.__R = null, u ? u(l) : l());
    };
    e.__R = i;
    var l = function() {
        if (!--r.__u) {
            if (r.state.__a) {
                var n = r.state.__a;
                r.__v.__k[0] = L(n, n.__c.__P, n.__c.__O);
            }
            var t;
            for(r.setState({
                __a: r.__b = null
            }); t = r.t.pop();)t.forceUpdate();
        }
    }, c = !0 === t.__h;
    r.__u++ || c || r.setState({
        __a: r.__b = r.__v.__k[0]
    }), n.then(i, i);
}, U.prototype.componentWillUnmount = function() {
    this.t = [];
}, U.prototype.render = function(n, e) {
    if (this.__b) {
        if (this.__v.__k) {
            var r = document.createElement("div"), o = this.__v.__k[0].__c;
            this.__v.__k[0] = I(this.__b, r, o.__O = o.__P);
        }
        this.__b = null;
    }
    var i = e.__a && (0, _preact.createElement)((0, _preact.Fragment), null, n.fallback);
    return i && (i.__h = null), [
        (0, _preact.createElement)((0, _preact.Fragment), null, e.__a ? null : n.children),
        i
    ];
};
var V = function(n, t, e) {
    if (++e[1] === e[0] && n.o.delete(t), n.props.revealOrder && ("t" !== n.props.revealOrder[0] || !n.o.size)) for(e = n.u; e;){
        for(; e.length > 3;)e.pop()();
        if (e[1] < e[0]) break;
        n.u = e = e[2];
    }
};
function W(n) {
    return this.getChildContext = function() {
        return n.context;
    }, n.children;
}
function P(n) {
    var e = this, r = n.i;
    e.componentWillUnmount = function() {
        (0, _preact.render)(null, e.l), e.l = null, e.i = null;
    }, e.i && e.i !== r && e.componentWillUnmount(), n.__v ? (e.l || (e.i = r, e.l = {
        nodeType: 1,
        parentNode: r,
        childNodes: [],
        appendChild: function(n) {
            this.childNodes.push(n), e.i.appendChild(n);
        },
        insertBefore: function(n, t) {
            this.childNodes.push(n), e.i.appendChild(n);
        },
        removeChild: function(n) {
            this.childNodes.splice(this.childNodes.indexOf(n) >>> 1, 1), e.i.removeChild(n);
        }
    }), (0, _preact.render)((0, _preact.createElement)(W, {
        context: e.context
    }, n.__v), e.l)) : e.l && e.componentWillUnmount();
}
function $(n, e) {
    var r = (0, _preact.createElement)(P, {
        __v: n,
        i: e
    });
    return r.containerInfo = e, r;
}
(M.prototype = new (0, _preact.Component)).__a = function(n) {
    var t = this, e = D(t.__v), r = t.o.get(n);
    return r[0]++, function(u) {
        var o = function() {
            t.props.revealOrder ? (r.push(u), V(t, n, r)) : u();
        };
        e ? e(o) : o();
    };
}, M.prototype.render = function(n) {
    this.u = null, this.o = new Map;
    var t = (0, _preact.toChildArray)(n.children);
    n.revealOrder && "b" === n.revealOrder[0] && t.reverse();
    for(var e = t.length; e--;)this.o.set(t[e], this.u = [
        1,
        0,
        this.u
    ]);
    return n.children;
}, M.prototype.componentDidUpdate = M.prototype.componentDidMount = function() {
    var n = this;
    this.o.forEach(function(t, e) {
        V(n, e, t);
    });
};
var j = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103, z = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/, B = "undefined" != typeof document, H = function(n) {
    return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(n);
};
function Z(n, t, e) {
    return null == t.__k && (t.textContent = ""), (0, _preact.render)(n, t), "function" == typeof e && e(), n ? n.__c : null;
}
function Y(n, t, e) {
    return (0, _preact.hydrate)(n, t), "function" == typeof e && e(), n ? n.__c : null;
}
(0, _preact.Component).prototype.isReactComponent = {}, [
    "componentWillMount",
    "componentWillReceiveProps",
    "componentWillUpdate"
].forEach(function(t) {
    Object.defineProperty((0, _preact.Component).prototype, t, {
        configurable: !0,
        get: function() {
            return this["UNSAFE_" + t];
        },
        set: function(n) {
            Object.defineProperty(this, t, {
                configurable: !0,
                writable: !0,
                value: n
            });
        }
    });
});
var q = (0, _preact.options).event;
function G() {}
function J() {
    return this.cancelBubble;
}
function K() {
    return this.defaultPrevented;
}
(0, _preact.options).event = function(n) {
    return q && (n = q(n)), n.persist = G, n.isPropagationStopped = J, n.isDefaultPrevented = K, n.nativeEvent = n;
};
var Q, X = {
    configurable: !0,
    get: function() {
        return this.class;
    }
}, nn = (0, _preact.options).vnode;
(0, _preact.options).vnode = function(n) {
    var t = n.type, e = n.props, u = e;
    if ("string" == typeof t) {
        var o = -1 === t.indexOf("-");
        for(var i in u = {}, e){
            var l = e[i];
            B && "children" === i && "noscript" === t || "value" === i && "defaultValue" in e && null == l || ("defaultValue" === i && "value" in e && null == e.value ? i = "value" : "download" === i && !0 === l ? l = "" : /ondoubleclick/i.test(i) ? i = "ondblclick" : /^onchange(textarea|input)/i.test(i + t) && !H(e.type) ? i = "oninput" : /^onfocus$/i.test(i) ? i = "onfocusin" : /^onblur$/i.test(i) ? i = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(i) ? i = i.toLowerCase() : o && z.test(i) ? i = i.replace(/[A-Z0-9]/g, "-$&").toLowerCase() : null === l && (l = void 0), /^oninput$/i.test(i) && (i = i.toLowerCase(), u[i] && (i = "oninputCapture")), u[i] = l);
        }
        "select" == t && u.multiple && Array.isArray(u.value) && (u.value = (0, _preact.toChildArray)(e.children).forEach(function(n) {
            n.props.selected = -1 != u.value.indexOf(n.props.value);
        })), "select" == t && null != u.defaultValue && (u.value = (0, _preact.toChildArray)(e.children).forEach(function(n) {
            n.props.selected = u.multiple ? -1 != u.defaultValue.indexOf(n.props.value) : u.defaultValue == n.props.value;
        })), n.props = u, e.class != e.className && (X.enumerable = "className" in e, null != e.className && (u.class = e.className), Object.defineProperty(u, "className", X));
    }
    n.$$typeof = j, nn && nn(n);
};
var tn = (0, _preact.options).__r;
(0, _preact.options).__r = function(n) {
    tn && tn(n), Q = n.__c;
};
var en = {
    ReactCurrentDispatcher: {
        current: {
            readContext: function(n) {
                return Q.__n[n.__c].props.value;
            }
        }
    }
}, rn = "17.0.2";
function un(n) {
    return (0, _preact.createElement).bind(null, n);
}
function on(n) {
    return !!n && n.$$typeof === j;
}
function ln(n) {
    return on(n) ? (0, _preact.cloneElement).apply(null, arguments) : n;
}
function cn(n) {
    return !!n.__k && ((0, _preact.render)(null, n), !0);
}
function fn(n) {
    return n && (n.base || 1 === n.nodeType && n) || null;
}
var an = function(n, t) {
    return n(t);
}, sn = function(n, t) {
    return n(t);
}, hn = (0, _preact.Fragment);
function vn(n) {
    n();
}
function dn(n) {
    return n;
}
function pn() {
    return [
        !1,
        vn
    ];
}
var mn = (0, _hooks.useLayoutEffect);
function yn(n, t) {
    var e = t(), r = (0, _hooks.useState)({
        h: {
            __: e,
            v: t
        }
    }), u = r[0].h, o = r[1];
    return (0, _hooks.useLayoutEffect)(function() {
        u.__ = e, u.v = t, u.__ !== t() && o({
            h: u
        });
    }, [
        n,
        e,
        t
    ]), (0, _hooks.useEffect)(function() {
        return u.__ !== u.v() && o({
            h: u
        }), n(function() {
            u.__ !== u.v() && o({
                h: u
            });
        });
    }, [
        n
    ]), e;
}
var _n = {
    useState: (0, _hooks.useState),
    useId: (0, _hooks.useId),
    useReducer: (0, _hooks.useReducer),
    useEffect: (0, _hooks.useEffect),
    useLayoutEffect: (0, _hooks.useLayoutEffect),
    useInsertionEffect: mn,
    useTransition: pn,
    useDeferredValue: dn,
    useSyncExternalStore: yn,
    startTransition: vn,
    useRef: (0, _hooks.useRef),
    useImperativeHandle: (0, _hooks.useImperativeHandle),
    useMemo: (0, _hooks.useMemo),
    useCallback: (0, _hooks.useCallback),
    useContext: (0, _hooks.useContext),
    useDebugValue: (0, _hooks.useDebugValue),
    version: "17.0.2",
    Children: A,
    render: Z,
    hydrate: Y,
    unmountComponentAtNode: cn,
    createPortal: $,
    createElement: (0, _preact.createElement),
    createContext: (0, _preact.createContext),
    createFactory: un,
    cloneElement: ln,
    createRef: (0, _preact.createRef),
    Fragment: (0, _preact.Fragment),
    isValidElement: on,
    findDOMNode: fn,
    Component: (0, _preact.Component),
    PureComponent: E,
    memo: w,
    forwardRef: N,
    flushSync: sn,
    unstable_batchedUpdates: an,
    StrictMode: hn,
    Suspense: U,
    SuspenseList: M,
    lazy: F,
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: en
};

},{"preact":"6u3ew","preact/hooks":"lwCAI","@parcel/transformer-js/src/esmodule-helpers.js":"hqSvo"}],"1giFm":[function(require,module,exports) {
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/ /* global define */ (function() {
    "use strict";
    var hasOwn = {}.hasOwnProperty;
    var nativeCodeString = "[native code]";
    function classNames() {
        var classes = [];
        for(var i = 0; i < arguments.length; i++){
            var arg = arguments[i];
            if (!arg) continue;
            var argType = typeof arg;
            if (argType === "string" || argType === "number") classes.push(arg);
            else if (Array.isArray(arg)) {
                if (arg.length) {
                    var inner = classNames.apply(null, arg);
                    if (inner) classes.push(inner);
                }
            } else if (argType === "object") {
                if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
                    classes.push(arg.toString());
                    continue;
                }
                for(var key in arg)if (hasOwn.call(arg, key) && arg[key]) classes.push(key);
            }
        }
        return classes.join(" ");
    }
    if (0, module.exports) {
        classNames.default = classNames;
        module.exports = classNames;
    } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) // register as 'classnames', consistent with npm package name
    define("classnames", [], function() {
        return classNames;
    });
    else window.classNames = classNames;
})();

},{}],"k4J8U":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
function _extends() {
    _extends = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
        });
        else if (Object.getOwnPropertyDescriptors) Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        else ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
const defaultProps = {
    breakpointCols: undefined,
    // optional, number or object { default: number, [key: number]: number }
    className: undefined,
    // required, string
    columnClassName: undefined,
    // optional, string
    // Any React children. Typically an array of JSX items
    children: undefined,
    // Custom attributes, however it is advised against
    // using these to prevent unintended issues and future conflicts
    // ...any other attribute, will be added to the container
    columnAttrs: undefined,
    // object, added to the columns
    // Deprecated props
    // The column property is deprecated.
    // It is an alias of the `columnAttrs` property
    column: undefined
};
const DEFAULT_COLUMNS = 2;
class Masonry extends (0, _reactDefault.default).Component {
    constructor(props){
        super(props); // Correct scope for when methods are accessed externally
        this.reCalculateColumnCount = this.reCalculateColumnCount.bind(this);
        this.reCalculateColumnCountDebounce = this.reCalculateColumnCountDebounce.bind(this); // default state
        let columnCount;
        if (this.props.breakpointCols && this.props.breakpointCols.default) columnCount = this.props.breakpointCols.default;
        else columnCount = parseInt(this.props.breakpointCols) || DEFAULT_COLUMNS;
        this.state = {
            columnCount
        };
    }
    componentDidMount() {
        this.reCalculateColumnCount(); // window may not be available in some environments
        if (window) window.addEventListener("resize", this.reCalculateColumnCountDebounce);
    }
    componentDidUpdate() {
        this.reCalculateColumnCount();
    }
    componentWillUnmount() {
        if (window) window.removeEventListener("resize", this.reCalculateColumnCountDebounce);
    }
    reCalculateColumnCountDebounce() {
        if (!window || !window.requestAnimationFrame) {
            // IE10+
            this.reCalculateColumnCount();
            return;
        }
        if (window.cancelAnimationFrame) // IE10+
        window.cancelAnimationFrame(this._lastRecalculateAnimationFrame);
        this._lastRecalculateAnimationFrame = window.requestAnimationFrame(()=>{
            this.reCalculateColumnCount();
        });
    }
    reCalculateColumnCount() {
        const windowWidth = window && window.innerWidth || Infinity;
        let breakpointColsObject = this.props.breakpointCols; // Allow passing a single number to `breakpointCols` instead of an object
        if (typeof breakpointColsObject !== "object") breakpointColsObject = {
            default: parseInt(breakpointColsObject) || DEFAULT_COLUMNS
        };
        let matchedBreakpoint = Infinity;
        let columns = breakpointColsObject.default || DEFAULT_COLUMNS;
        for(let breakpoint in breakpointColsObject){
            const optBreakpoint = parseInt(breakpoint);
            const isCurrentBreakpoint = optBreakpoint > 0 && windowWidth <= optBreakpoint;
            if (isCurrentBreakpoint && optBreakpoint < matchedBreakpoint) {
                matchedBreakpoint = optBreakpoint;
                columns = breakpointColsObject[breakpoint];
            }
        }
        columns = Math.max(1, parseInt(columns) || 1);
        if (this.state.columnCount !== columns) this.setState({
            columnCount: columns
        });
    }
    itemsInColumns() {
        const currentColumnCount = this.state.columnCount;
        const itemsInColumns = new Array(currentColumnCount); // Force children to be handled as an array
        const items = (0, _reactDefault.default).Children.toArray(this.props.children);
        for(let i = 0; i < items.length; i++){
            const columnIndex = i % currentColumnCount;
            if (!itemsInColumns[columnIndex]) itemsInColumns[columnIndex] = [];
            itemsInColumns[columnIndex].push(items[i]);
        }
        return itemsInColumns;
    }
    renderColumns() {
        const { column , columnAttrs ={} , columnClassName  } = this.props;
        const childrenInColumns = this.itemsInColumns();
        const columnWidth = `${100 / childrenInColumns.length}%`;
        let className = columnClassName;
        if (className && typeof className !== "string") {
            this.logDeprecated('The property "columnClassName" requires a string'); // This is a deprecated default and will be removed soon.
            if (typeof className === "undefined") className = "my-masonry-grid_column";
        }
        const columnAttributes = _objectSpread(_objectSpread(_objectSpread({}, column), columnAttrs), {}, {
            style: _objectSpread(_objectSpread({}, columnAttrs.style), {}, {
                width: columnWidth
            }),
            className
        });
        return childrenInColumns.map((items, i)=>{
            return /*#__PURE__*/ (0, _reactDefault.default).createElement("div", _extends({}, columnAttributes, {
                key: i
            }), items);
        });
    }
    logDeprecated(message) {
        console.error("[Masonry]", message);
    }
    render() {
        const _this$props = this.props, { // ignored
        children , breakpointCols , columnClassName , columnAttrs , column , // used
        className  } = _this$props, rest = _objectWithoutProperties(_this$props, [
            "children",
            "breakpointCols",
            "columnClassName",
            "columnAttrs",
            "column",
            "className"
        ]);
        let classNameOutput = className;
        if (typeof className !== "string") {
            this.logDeprecated('The property "className" requires a string'); // This is a deprecated default and will be removed soon.
            if (typeof className === "undefined") classNameOutput = "my-masonry-grid";
        }
        return /*#__PURE__*/ (0, _reactDefault.default).createElement("div", _extends({}, rest, {
            className: classNameOutput
        }), this.renderColumns());
    }
}
Masonry.defaultProps = defaultProps;
exports.default = Masonry;

},{"react":"2kGyk","@parcel/transformer-js/src/esmodule-helpers.js":"hqSvo"}],"6VquX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ContextMenu", ()=>(0, _menuDefault.default));
parcelHelpers.export(exports, "ContextMenuWithData", ()=>(0, _menu.ContextMenuWithData));
parcelHelpers.export(exports, "ContextMenuTrigger", ()=>(0, _triggerDefault.default));
parcelHelpers.export(exports, "MenuItem", ()=>(0, _itemDefault.default));
parcelHelpers.export(exports, "openContextMenu", ()=>(0, _util.openContextMenu));
parcelHelpers.export(exports, "attachContextMenu", ()=>(0, _util.attachContextMenu));
var _menu = require("./menu");
var _menuDefault = parcelHelpers.interopDefault(_menu);
var _trigger = require("./trigger");
var _triggerDefault = parcelHelpers.interopDefault(_trigger);
var _item = require("./item");
var _itemDefault = parcelHelpers.interopDefault(_item);
var _util = require("./util");

},{"./menu":"lkMD9","./trigger":"e0bZt","./item":"5SSTC","./util":"2mndJ","@parcel/transformer-js/src/esmodule-helpers.js":"hqSvo"}],"lkMD9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "menuOffset", ()=>menuOffset);
parcelHelpers.export(exports, "contextMenus", ()=>contextMenus);
parcelHelpers.export(exports, "MenuContext", ()=>MenuContext);
parcelHelpers.export(exports, "ContextMenuWithData", ()=>ContextMenuWithData);
var _preact = require("preact");
var _hooks = require("preact/hooks");
var _compat = require("preact/compat");
var __assign = undefined && undefined.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = undefined && undefined.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") {
        for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
var menuOffset = 8;
var contextMenus = new Map();
var MenuContext = (0, _preact.createContext)(undefined);
var menuContainer;
if (typeof window !== "undefined") {
    menuContainer = document.createElement("div");
    menuContainer.classList.add("preact-context-menu");
    menuContainer.setAttribute("style", "overflow: hidden; pointer-events: none;");
    document.body.appendChild(menuContainer);
}
var ContextMenuWithData = function(props) {
    var id = props.id, children = props.children, className = props.className, shouldOpen = props.shouldOpen, onClose = props.onClose, style = props.style, divProps = __rest(props, [
        "id",
        "children",
        "className",
        "shouldOpen",
        "onClose",
        "style"
    ]);
    var _a = (0, _hooks.useState)(false), render = _a[0], setRender = _a[1];
    var _b = (0, _hooks.useState)(false), wasOpen = _b[0], setWasOpen = _b[1];
    var _c = (0, _hooks.useState)(undefined), placement = _c[0], setPlacement = _c[1];
    var _d = (0, _hooks.useState)(undefined), eventCoords = _d[0], setEventCoords = _d[1];
    var _e = (0, _hooks.useState)(undefined), data = _e[0], setData = _e[1];
    var ref = (0, _hooks.useRef)(null);
    var trigger = (0, _hooks.useCallback)(function(coords, data) {
        if (shouldOpen !== undefined && !shouldOpen(data)) return;
        setEventCoords(coords);
        setRender(true);
        setData(data);
    }, [
        shouldOpen
    ]);
    var closeMenu = (0, _hooks.useCallback)(function(data) {
        setRender(false);
        setPlacement(undefined);
        setData(undefined);
        if (props.onClose !== undefined) props.onClose(data);
    }, [
        props.onClose
    ]);
    var onClickAway = (0, _hooks.useCallback)(function(event) {
        if (ref.current && !ref.current.contains(event.target)) closeMenu(undefined);
    }, []);
    (0, _hooks.useEffect)(function() {
        if (contextMenus.has(id)) throw new Error("There is another ContextMenu element with the ID " + id);
        contextMenus.set(id, trigger);
        return function() {
            contextMenus.delete(id);
        };
    }, [
        id
    ]);
    (0, _hooks.useEffect)(function() {
        if (render && typeof window !== "undefined") {
            var div = ref.current;
            if (div === null) return;
            var coords = eventCoords || {
                x: 0,
                y: 0
            };
            var x = coords.x + menuOffset;
            var y = coords.y + menuOffset;
            var width = window.innerWidth;
            var height = window.innerHeight;
            if (x + div.offsetWidth > width - 8) x = coords.x - div.offsetWidth;
            if (y + div.offsetHeight > height - 8) y = height - div.offsetHeight - 8;
            setPlacement({
                x: x,
                y: y
            });
            document.addEventListener("mousedown", onClickAway);
            return function() {
                return document.removeEventListener("mousedown", onClickAway);
            };
        }
        return undefined;
    }, [
        render,
        eventCoords
    ]);
    if (render) {
        var finalStyle = style || {};
        finalStyle.position = "fixed";
        if (placement !== undefined) {
            finalStyle.top = placement.y;
            finalStyle.left = placement.x;
            finalStyle.pointerEvents = "initial";
        } else {
            finalStyle.opacity = 0;
            finalStyle.pointerEvents = "none";
        }
        var out = children(data);
        if (!wasOpen && (!out || out.length === 0)) {
            setRender(false);
            setPlacement(undefined);
            setData(undefined);
            return null;
        }
        setWasOpen(true);
        return (0, _compat.createPortal)((0, _preact.h)(MenuContext.Provider, {
            value: function(data) {
                return closeMenu(data);
            }
        }, (0, _preact.h)("div", __assign({
            ref: ref,
            id: id
        }, divProps, {
            // This is to stop the browser context menu from opening
            onContextMenu: function(event) {
                return event.preventDefault();
            },
            className: className !== undefined ? "context-menu " + className : "context-menu",
            style: finalStyle
        }), out)), menuContainer);
    } else {
        setWasOpen(false);
        return null;
    }
};
var ContextMenu = function(props) {
    var children = props.children, rest = __rest(props, [
        "children"
    ]);
    return (0, _preact.h)(ContextMenuWithData, __assign({}, rest), function(_) {
        return children;
    });
};
exports.default = ContextMenu;

},{"preact":"6u3ew","preact/hooks":"lwCAI","preact/compat":"2kGyk","@parcel/transformer-js/src/esmodule-helpers.js":"hqSvo"}],"e0bZt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _preact = require("preact");
var _hooks = require("preact/hooks");
var _util = require("./util");
/**
 * Component which wraps around other components to provide a context menu trigger area.
 * @param props Trigger props
 * @returns Component
 */ var ContextMenuTrigger = function(props) {
    // For most browsers, we can use onContextMenu.
    var onContextMenu = (0, _hooks.useCallback)(function(event) {
        if (props.disabled === true) return;
        (0, _util.openContextMenu)(props.id, props.data, {
            x: event.clientX,
            y: event.clientY
        });
        event.stopPropagation();
        event.preventDefault();
    }, [
        props.id,
        props.data
    ]);
    var ref = (0, _hooks.useRef)(null);
    var timeoutRef = (0, _hooks.useRef)();
    // On iOS devices, we need to manually handle the touch events.
    var onTouchStart = (0, _hooks.useCallback)(function(event) {
        var _a;
        if (props.disabled === true) return;
        event.stopPropagation();
        event.preventDefault();
        var touch = event.touches[0];
        clearTimeout(timeoutRef.current);
        timeoutRef.current = setTimeout(function() {
            (0, _util.openContextMenu)(props.id, props.data, {
                x: touch.clientX,
                y: touch.clientY
            });
        }, (_a = props.touchTimeout) !== null && _a !== void 0 ? _a : 610);
    }, [
        props.id,
        props.data
    ]);
    // Cancel context menu if we move, end or cancel the touch.
    var onTouchCancel = (0, _hooks.useCallback)(function() {
        clearTimeout(timeoutRef.current);
    }, []);
    // Bind events directly, since Preact has some trouble here.
    (0, _hooks.useEffect)(function() {
        if (ref.current) {
            ref.current.addEventListener("touchstart", onTouchStart, {
                passive: true
            });
            ref.current.addEventListener("touchcancel", onTouchCancel, {
                passive: true
            });
            ref.current.addEventListener("touchmove", onTouchCancel, {
                passive: true
            });
            ref.current.addEventListener("touchend", onTouchCancel, {
                passive: true
            });
            return function() {
                ref.current.removeEventListener("touchstart", onTouchStart);
                ref.current.removeEventListener("touchcancel", onTouchCancel);
                ref.current.removeEventListener("touchmove", onTouchCancel);
                ref.current.removeEventListener("touchend", onTouchCancel);
            };
        }
        return function() {};
    }, [
        ref
    ]);
    return (0, _preact.h)("span", {
        ref: ref,
        onContextMenu: onContextMenu
    }, props.children);
};
exports.default = ContextMenuTrigger;

},{"preact":"6u3ew","preact/hooks":"lwCAI","./util":"2mndJ","@parcel/transformer-js/src/esmodule-helpers.js":"hqSvo"}],"2mndJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "openContextMenu", ()=>openContextMenu);
parcelHelpers.export(exports, "attachContextMenu", ()=>attachContextMenu);
var _menu = require("./menu");
var currentMouseCoords = {
    x: 0,
    y: 0
};
if (typeof window !== "undefined") document.addEventListener("mousemove", function(event) {
    return currentMouseCoords = {
        x: event.clientX,
        y: event.clientY
    };
});
var openContextMenu = function(id, data, coords) {
    var fn = (0, _menu.contextMenus).get(id);
    if (fn === undefined) throw new Error("There is no ContextMenu with the ID " + id);
    fn(coords ? {
        x: coords.x - (0, _menu.menuOffset),
        y: coords.y - (0, _menu.menuOffset)
    } : currentMouseCoords, data);
};
var attachContextMenu = function(id, data) {
    return function(event) {
        openContextMenu(id, data, {
            x: event.clientX,
            y: event.clientY
        });
        event.stopPropagation();
        event.preventDefault();
    };
};

},{"./menu":"lkMD9","@parcel/transformer-js/src/esmodule-helpers.js":"hqSvo"}],"5SSTC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _preact = require("preact");
var _hooks = require("preact/hooks");
var _menu = require("./menu");
var MenuItem = function(props) {
    var onClick = (0, _hooks.useCallback)(function(event, fn, data) {
        if (props.disabled === true) return;
        event.stopPropagation();
        if (fn === undefined) throw new Error("MenuItem is not inside a ContextMenu");
        fn(data);
    }, []);
    return (0, _preact.h)((0, _menu.MenuContext).Consumer, null, function(fn) {
        return (0, _preact.h)("span", {
            onClick: function(event) {
                return onClick(event, fn, props.data);
            }
        }, props.children);
    });
};
exports.default = MenuItem;

},{"preact":"6u3ew","preact/hooks":"lwCAI","./menu":"lkMD9","@parcel/transformer-js/src/esmodule-helpers.js":"hqSvo"}],"hRDYn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "cache", ()=>cache);
parcelHelpers.export(exports, "css", ()=>css);
parcelHelpers.export(exports, "cx", ()=>cx);
parcelHelpers.export(exports, "flush", ()=>flush);
parcelHelpers.export(exports, "getRegisteredStyles", ()=>getRegisteredStyles);
parcelHelpers.export(exports, "hydrate", ()=>hydrate);
parcelHelpers.export(exports, "injectGlobal", ()=>injectGlobal);
parcelHelpers.export(exports, "keyframes", ()=>keyframes);
parcelHelpers.export(exports, "merge", ()=>merge);
parcelHelpers.export(exports, "sheet", ()=>sheet);
var _cache = require("@emotion/cache");
var _serialize = require("@emotion/serialize");
var _utils = require("@emotion/utils");
var _emotionCssCreateInstanceEsmJs = require("../create-instance/dist/emotion-css-create-instance.esm.js");
var _emotionCssCreateInstanceEsmJsDefault = parcelHelpers.interopDefault(_emotionCssCreateInstanceEsmJs);
var _createEmotion = (0, _emotionCssCreateInstanceEsmJsDefault.default)({
    key: "css"
}), flush = _createEmotion.flush, hydrate = _createEmotion.hydrate, cx = _createEmotion.cx, merge = _createEmotion.merge, getRegisteredStyles = _createEmotion.getRegisteredStyles, injectGlobal = _createEmotion.injectGlobal, keyframes = _createEmotion.keyframes, css = _createEmotion.css, sheet = _createEmotion.sheet, cache = _createEmotion.cache;

},{"@emotion/cache":"dychw","@emotion/serialize":"8XJ5i","@emotion/utils":"kU4Ka","../create-instance/dist/emotion-css-create-instance.esm.js":"dmLTS","@parcel/transformer-js/src/esmodule-helpers.js":"hqSvo"}],"dychw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _sheet = require("@emotion/sheet");
var _stylis = require("stylis");
var _weakMemoize = require("@emotion/weak-memoize");
var _memoize = require("@emotion/memoize");
var identifierWithPointTracking = function identifierWithPointTracking(begin, points, index) {
    var previous = 0;
    var character = 0;
    while(true){
        previous = character;
        character = (0, _stylis.peek)(); // &\f
        if (previous === 38 && character === 12) points[index] = 1;
        if ((0, _stylis.token)(character)) break;
        (0, _stylis.next)();
    }
    return (0, _stylis.slice)(begin, (0, _stylis.position));
};
var toRules = function toRules(parsed, points) {
    // pretend we've started with a comma
    var index = -1;
    var character = 44;
    do switch((0, _stylis.token)(character)){
        case 0:
            // &\f
            if (character === 38 && (0, _stylis.peek)() === 12) // this is not 100% correct, we don't account for literal sequences here - like for example quoted strings
            // stylis inserts \f after & to know when & where it should replace this sequence with the context selector
            // and when it should just concatenate the outer and inner selectors
            // it's very unlikely for this sequence to actually appear in a different context, so we just leverage this fact here
            points[index] = 1;
            parsed[index] += identifierWithPointTracking((0, _stylis.position) - 1, points, index);
            break;
        case 2:
            parsed[index] += (0, _stylis.delimit)(character);
            break;
        case 4:
            // comma
            if (character === 44) {
                // colon
                parsed[++index] = (0, _stylis.peek)() === 58 ? "&\f" : "";
                points[index] = parsed[index].length;
                break;
            }
        // fallthrough
        default:
            parsed[index] += (0, _stylis.from)(character);
    }
    while (character = (0, _stylis.next)());
    return parsed;
};
var getRules = function getRules(value, points) {
    return (0, _stylis.dealloc)(toRules((0, _stylis.alloc)(value), points));
}; // WeakSet would be more appropriate, but only WeakMap is supported in IE11
var fixedElements = /* #__PURE__ */ new WeakMap();
var compat = function compat(element) {
    if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
    // negative .length indicates that this rule has been already prefixed
    element.length < 1) return;
    var value = element.value, parent = element.parent;
    var isImplicitRule = element.column === parent.column && element.line === parent.line;
    while(parent.type !== "rule"){
        parent = parent.parent;
        if (!parent) return;
    } // short-circuit for the simplest case
    if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) return;
     // if this is an implicitly inserted rule (the one eagerly inserted at the each new nested level)
    // then the props has already been manipulated beforehand as they that array is shared between it and its "rule parent"
    if (isImplicitRule) return;
    fixedElements.set(element, true);
    var points = [];
    var rules = getRules(value, points);
    var parentRules = parent.props;
    for(var i = 0, k = 0; i < rules.length; i++)for(var j = 0; j < parentRules.length; j++, k++)element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
};
var removeLabel = function removeLabel(element) {
    if (element.type === "decl") {
        var value = element.value;
        if (value.charCodeAt(0) === 108 && // charcode for b
        value.charCodeAt(2) === 98) {
            // this ignores label
            element["return"] = "";
            element.value = "";
        }
    }
};
var ignoreFlag = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason";
var isIgnoringComment = function isIgnoringComment(element) {
    return element.type === "comm" && element.children.indexOf(ignoreFlag) > -1;
};
var createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm(cache) {
    return function(element, index, children) {
        if (element.type !== "rule" || cache.compat) return;
        var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);
        if (unsafePseudoClasses) {
            var isNested = element.parent === children[0]; // in nested rules comments become children of the "auto-inserted" rule
            //
            // considering this input:
            // .a {
            //   .b /* comm */ {}
            //   color: hotpink;
            // }
            // we get output corresponding to this:
            // .a {
            //   & {
            //     /* comm */
            //     color: hotpink;
            //   }
            //   .b {}
            // }
            var commentContainer = isNested ? children[0].children : children;
            for(var i = commentContainer.length - 1; i >= 0; i--){
                var node = commentContainer[i];
                if (node.line < element.line) break;
                 // it is quite weird but comments are *usually* put at `column: element.column - 1`
                // so we seek *from the end* for the node that is earlier than the rule's `element` and check that
                // this will also match inputs like this:
                // .a {
                //   /* comm */
                //   .b {}
                // }
                //
                // but that is fine
                //
                // it would be the easiest to change the placement of the comment to be the first child of the rule:
                // .a {
                //   .b { /* comm */ }
                // }
                // with such inputs we wouldn't have to search for the comment at all
                // TODO: consider changing this comment placement in the next major version
                if (node.column < element.column) {
                    if (isIgnoringComment(node)) return;
                    break;
                }
            }
            unsafePseudoClasses.forEach(function(unsafePseudoClass) {
                console.error('The pseudo class "' + unsafePseudoClass + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + unsafePseudoClass.split("-child")[0] + '-of-type".');
            });
        }
    };
};
var isImportRule = function isImportRule(element) {
    return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;
};
var isPrependedWithRegularRules = function isPrependedWithRegularRules(index, children) {
    for(var i = index - 1; i >= 0; i--){
        if (!isImportRule(children[i])) return true;
    }
    return false;
}; // use this to remove incorrect elements from further processing
// so they don't get handed to the `sheet` (or anything else)
// as that could potentially lead to additional logs which in turn could be overhelming to the user
var nullifyElement = function nullifyElement(element) {
    element.type = "";
    element.value = "";
    element["return"] = "";
    element.children = "";
    element.props = "";
};
var incorrectImportAlarm = function incorrectImportAlarm(element, index, children) {
    if (!isImportRule(element)) return;
    if (element.parent) {
        console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
        nullifyElement(element);
    } else if (isPrependedWithRegularRules(index, children)) {
        console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
        nullifyElement(element);
    }
};
var defaultStylisPlugins = [
    (0, _stylis.prefixer)
];
var createCache = function createCache(options) {
    var key = options.key;
    if (!key) throw new Error("You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\nIf multiple caches share the same key they might \"fight\" for each other's style elements.");
    if (key === "css") {
        var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])"); // get SSRed styles out of the way of React's hydration
        // document.head is a safe place to move them to(though note document.head is not necessarily the last place they will be)
        // note this very very intentionally targets all style elements regardless of the key to ensure
        // that creating a cache works inside of render of a React component
        Array.prototype.forEach.call(ssrStyles, function(node) {
            // we want to only move elements which have a space in the data-emotion attribute value
            // because that indicates that it is an Emotion 11 server-side rendered style elements
            // while we will already ignore Emotion 11 client-side inserted styles because of the :not([data-s]) part in the selector
            // Emotion 10 client-side inserted styles did not have data-s (but importantly did not have a space in their data-emotion attributes)
            // so checking for the space ensures that loading Emotion 11 after Emotion 10 has inserted some styles
            // will not result in the Emotion 10 styles being destroyed
            var dataEmotionAttribute = node.getAttribute("data-emotion");
            if (dataEmotionAttribute.indexOf(" ") === -1) return;
            document.head.appendChild(node);
            node.setAttribute("data-s", "");
        });
    }
    var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
    // $FlowFixMe
    if (/[^a-z-]/.test(key)) throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + key + '" was passed');
    var inserted = {};
    var container;
    var nodesToHydrate = [];
    container = options.container || document.head;
    Array.prototype.forEach.call(// means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + key + ' "]'), function(node) {
        var attrib = node.getAttribute("data-emotion").split(" "); // $FlowFixMe
        for(var i = 1; i < attrib.length; i++)inserted[attrib[i]] = true;
        nodesToHydrate.push(node);
    });
    var _insert;
    var omnipresentPlugins = [
        compat,
        removeLabel
    ];
    omnipresentPlugins.push(createUnsafeSelectorsAlarm({
        get compat () {
            return cache.compat;
        }
    }), incorrectImportAlarm);
    var currentSheet;
    var finalizingPlugins = [
        (0, _stylis.stringify),
        function(element) {
            if (!element.root) {
                if (element["return"]) currentSheet.insert(element["return"]);
                else if (element.value && element.type !== (0, _stylis.COMMENT)) // insert empty rule in non-production environments
                // so @emotion/jest can grab `key` from the (JS)DOM for caches without any rules inserted yet
                currentSheet.insert(element.value + "{}");
            }
        }
    ];
    var serializer = (0, _stylis.middleware)(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis(styles) {
        return (0, _stylis.serialize)((0, _stylis.compile)(styles), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
        currentSheet = sheet;
        if (serialized.map !== undefined) currentSheet = {
            insert: function insert(rule) {
                sheet.insert(rule + serialized.map);
            }
        };
        stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
        if (shouldCache) cache.inserted[serialized.name] = true;
    };
    var cache = {
        key: key,
        sheet: new (0, _sheet.StyleSheet)({
            key: key,
            container: container,
            nonce: options.nonce,
            speedy: options.speedy,
            prepend: options.prepend,
            insertionPoint: options.insertionPoint
        }),
        nonce: options.nonce,
        inserted: inserted,
        registered: {},
        insert: _insert
    };
    cache.sheet.hydrate(nodesToHydrate);
    return cache;
};
exports.default = createCache;

},{"@emotion/sheet":"5hmvw","stylis":"jIZWa","@emotion/weak-memoize":"4H9s4","@emotion/memoize":"akntE","@parcel/transformer-js/src/esmodule-helpers.js":"hqSvo"}],"5hmvw":[function(require,module,exports) {
/*

Based off glamor's StyleSheet, thanks Sunil ❤️

high performance StyleSheet for css-in-js systems

- uses multiple style tags behind the scenes for millions of rules
- uses `insertRule` for appending in production for *much* faster performance

// usage

import { StyleSheet } from '@emotion/sheet'

let styleSheet = new StyleSheet({ key: '', container: document.head })

styleSheet.insert('#box { border: 1px solid red; }')
- appends a css rule into the stylesheet

styleSheet.flush()
- empties the stylesheet of all its contents

*/ // $FlowFixMe
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "StyleSheet", ()=>StyleSheet);
function sheetForTag(tag) {
    if (tag.sheet) // $FlowFixMe
    return tag.sheet;
     // this weirdness brought to you by firefox
    /* istanbul ignore next */ for(var i = 0; i < document.styleSheets.length; i++){
        if (document.styleSheets[i].ownerNode === tag) // $FlowFixMe
        return document.styleSheets[i];
    }
}
function createStyleElement(options) {
    var tag = document.createElement("style");
    tag.setAttribute("data-emotion", options.key);
    if (options.nonce !== undefined) tag.setAttribute("nonce", options.nonce);
    tag.appendChild(document.createTextNode(""));
    tag.setAttribute("data-s", "");
    return tag;
}
var StyleSheet = /*#__PURE__*/ function() {
    // Using Node instead of HTMLElement since container may be a ShadowRoot
    function StyleSheet(options) {
        var _this = this;
        this._insertTag = function(tag) {
            var before;
            if (_this.tags.length === 0) {
                if (_this.insertionPoint) before = _this.insertionPoint.nextSibling;
                else if (_this.prepend) before = _this.container.firstChild;
                else before = _this.before;
            } else before = _this.tags[_this.tags.length - 1].nextSibling;
            _this.container.insertBefore(tag, before);
            _this.tags.push(tag);
        };
        this.isSpeedy = options.speedy === undefined ? false : options.speedy;
        this.tags = [];
        this.ctr = 0;
        this.nonce = options.nonce; // key is the value of the data-emotion attribute, it's used to identify different sheets
        this.key = options.key;
        this.container = options.container;
        this.prepend = options.prepend;
        this.insertionPoint = options.insertionPoint;
        this.before = null;
    }
    var _proto = StyleSheet.prototype;
    _proto.hydrate = function hydrate(nodes) {
        nodes.forEach(this._insertTag);
    };
    _proto.insert = function insert(rule) {
        // the max length is how many rules we have per style tag, it's 65000 in speedy mode
        // it's 1 in dev because we insert source maps that map a single rule to a location
        // and you can only have one source map per style tag
        if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) this._insertTag(createStyleElement(this));
        var tag = this.tags[this.tags.length - 1];
        var isImportRule = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;
        if (isImportRule && this._alreadyInsertedOrderInsensitiveRule) // this would only cause problem in speedy mode
        // but we don't want enabling speedy to affect the observable behavior
        // so we report this error at all times
        console.error("You're attempting to insert the following rule:\n" + rule + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.");
        this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule;
        if (this.isSpeedy) {
            var sheet = sheetForTag(tag);
            try {
                // this is the ultrafast version, works across browsers
                // the big drawback is that the css won't be editable in devtools
                sheet.insertRule(rule, sheet.cssRules.length);
            } catch (e) {
                if (!/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear){/.test(rule)) console.error('There was a problem inserting the following rule: "' + rule + '"', e);
            }
        } else tag.appendChild(document.createTextNode(rule));
        this.ctr++;
    };
    _proto.flush = function flush() {
        // $FlowFixMe
        this.tags.forEach(function(tag) {
            return tag.parentNode && tag.parentNode.removeChild(tag);
        });
        this.tags = [];
        this.ctr = 0;
        this._alreadyInsertedOrderInsensitiveRule = false;
    };
    return StyleSheet;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"hqSvo"}],"jIZWa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CHARSET", ()=>f);
parcelHelpers.export(exports, "COMMENT", ()=>c);
parcelHelpers.export(exports, "COUNTER_STYLE", ()=>w);
parcelHelpers.export(exports, "DECLARATION", ()=>t);
parcelHelpers.export(exports, "DOCUMENT", ()=>v);
parcelHelpers.export(exports, "FONT_FACE", ()=>b);
parcelHelpers.export(exports, "FONT_FEATURE_VALUES", ()=>$);
parcelHelpers.export(exports, "IMPORT", ()=>i);
parcelHelpers.export(exports, "KEYFRAMES", ()=>p);
parcelHelpers.export(exports, "MEDIA", ()=>u);
parcelHelpers.export(exports, "MOZ", ()=>r);
parcelHelpers.export(exports, "MS", ()=>e);
parcelHelpers.export(exports, "NAMESPACE", ()=>h);
parcelHelpers.export(exports, "PAGE", ()=>s);
parcelHelpers.export(exports, "RULESET", ()=>n);
parcelHelpers.export(exports, "SUPPORTS", ()=>l);
parcelHelpers.export(exports, "VIEWPORT", ()=>o);
parcelHelpers.export(exports, "WEBKIT", ()=>a);
parcelHelpers.export(exports, "abs", ()=>k);
parcelHelpers.export(exports, "alloc", ()=>U);
parcelHelpers.export(exports, "append", ()=>S);
parcelHelpers.export(exports, "assign", ()=>g);
parcelHelpers.export(exports, "caret", ()=>Q);
parcelHelpers.export(exports, "char", ()=>K);
parcelHelpers.export(exports, "character", ()=>G);
parcelHelpers.export(exports, "characters", ()=>H);
parcelHelpers.export(exports, "charat", ()=>z);
parcelHelpers.export(exports, "column", ()=>D);
parcelHelpers.export(exports, "combine", ()=>q);
parcelHelpers.export(exports, "comment", ()=>se);
parcelHelpers.export(exports, "commenter", ()=>re);
parcelHelpers.export(exports, "compile", ()=>ce);
parcelHelpers.export(exports, "copy", ()=>J);
parcelHelpers.export(exports, "dealloc", ()=>V);
parcelHelpers.export(exports, "declaration", ()=>ue);
parcelHelpers.export(exports, "delimit", ()=>W);
parcelHelpers.export(exports, "delimiter", ()=>ee);
parcelHelpers.export(exports, "escaping", ()=>_);
parcelHelpers.export(exports, "from", ()=>d);
parcelHelpers.export(exports, "hash", ()=>m);
parcelHelpers.export(exports, "identifier", ()=>ae);
parcelHelpers.export(exports, "indexof", ()=>C);
parcelHelpers.export(exports, "length", ()=>E);
parcelHelpers.export(exports, "line", ()=>B);
parcelHelpers.export(exports, "match", ()=>y);
parcelHelpers.export(exports, "middleware", ()=>le);
parcelHelpers.export(exports, "namespace", ()=>pe);
parcelHelpers.export(exports, "next", ()=>N);
parcelHelpers.export(exports, "node", ()=>I);
parcelHelpers.export(exports, "parse", ()=>ne);
parcelHelpers.export(exports, "peek", ()=>P);
parcelHelpers.export(exports, "position", ()=>F);
parcelHelpers.export(exports, "prefix", ()=>ie);
parcelHelpers.export(exports, "prefixer", ()=>he);
parcelHelpers.export(exports, "prev", ()=>L);
parcelHelpers.export(exports, "replace", ()=>j);
parcelHelpers.export(exports, "ruleset", ()=>te);
parcelHelpers.export(exports, "rulesheet", ()=>ve);
parcelHelpers.export(exports, "serialize", ()=>fe);
parcelHelpers.export(exports, "sizeof", ()=>M);
parcelHelpers.export(exports, "slice", ()=>R);
parcelHelpers.export(exports, "stringify", ()=>oe);
parcelHelpers.export(exports, "strlen", ()=>O);
parcelHelpers.export(exports, "substr", ()=>A);
parcelHelpers.export(exports, "token", ()=>T);
parcelHelpers.export(exports, "tokenize", ()=>X);
parcelHelpers.export(exports, "tokenizer", ()=>Z);
parcelHelpers.export(exports, "trim", ()=>x);
parcelHelpers.export(exports, "whitespace", ()=>Y);
var e = "-ms-";
var r = "-moz-";
var a = "-webkit-";
var c = "comm";
var n = "rule";
var t = "decl";
var s = "@page";
var u = "@media";
var i = "@import";
var f = "@charset";
var o = "@viewport";
var l = "@supports";
var v = "@document";
var h = "@namespace";
var p = "@keyframes";
var b = "@font-face";
var w = "@counter-style";
var $ = "@font-feature-values";
var k = Math.abs;
var d = String.fromCharCode;
var g = Object.assign;
function m(e, r) {
    return (((r << 2 ^ z(e, 0)) << 2 ^ z(e, 1)) << 2 ^ z(e, 2)) << 2 ^ z(e, 3);
}
function x(e) {
    return e.trim();
}
function y(e, r) {
    return (e = r.exec(e)) ? e[0] : e;
}
function j(e, r, a) {
    return e.replace(r, a);
}
function C(e, r) {
    return e.indexOf(r);
}
function z(e, r) {
    return e.charCodeAt(r) | 0;
}
function A(e, r, a) {
    return e.slice(r, a);
}
function O(e) {
    return e.length;
}
function M(e) {
    return e.length;
}
function S(e, r) {
    return r.push(e), e;
}
function q(e, r) {
    return e.map(r).join("");
}
var B = 1;
var D = 1;
var E = 0;
var F = 0;
var G = 0;
var H = "";
function I(e, r, a, c, n, t, s) {
    return {
        value: e,
        root: r,
        parent: a,
        type: c,
        props: n,
        children: t,
        line: B,
        column: D,
        length: s,
        return: ""
    };
}
function J(e, r) {
    return g(I("", null, null, "", null, null, 0), e, {
        length: -e.length
    }, r);
}
function K() {
    return G;
}
function L() {
    G = F > 0 ? z(H, --F) : 0;
    if (D--, G === 10) D = 1, B--;
    return G;
}
function N() {
    G = F < E ? z(H, F++) : 0;
    if (D++, G === 10) D = 1, B++;
    return G;
}
function P() {
    return z(H, F);
}
function Q() {
    return F;
}
function R(e, r) {
    return A(H, e, r);
}
function T(e) {
    switch(e){
        case 0:
        case 9:
        case 10:
        case 13:
        case 32:
            return 5;
        case 33:
        case 43:
        case 44:
        case 47:
        case 62:
        case 64:
        case 126:
        case 59:
        case 123:
        case 125:
            return 4;
        case 58:
            return 3;
        case 34:
        case 39:
        case 40:
        case 91:
            return 2;
        case 41:
        case 93:
            return 1;
    }
    return 0;
}
function U(e) {
    return B = D = 1, E = O(H = e), F = 0, [];
}
function V(e) {
    return H = "", e;
}
function W(e) {
    return x(R(F - 1, ee(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function X(e) {
    return V(Z(U(e)));
}
function Y(e) {
    while(G = P())if (G < 33) N();
    else break;
    return T(e) > 2 || T(G) > 3 ? "" : " ";
}
function Z(e) {
    while(N())switch(T(G)){
        case 0:
            S(ae(F - 1), e);
            break;
        case 2:
            S(W(G), e);
            break;
        default:
            S(d(G), e);
    }
    return e;
}
function _(e, r) {
    while(--r && N())if (G < 48 || G > 102 || G > 57 && G < 65 || G > 70 && G < 97) break;
    return R(e, Q() + (r < 6 && P() == 32 && N() == 32));
}
function ee(e) {
    while(N())switch(G){
        case e:
            return F;
        case 34:
        case 39:
            if (e !== 34 && e !== 39) ee(G);
            break;
        case 40:
            if (e === 41) ee(e);
            break;
        case 92:
            N();
            break;
    }
    return F;
}
function re(e, r) {
    while(N())if (e + G === 57) break;
    else if (e + G === 84 && P() === 47) break;
    return "/*" + R(r, F - 1) + "*" + d(e === 47 ? e : N());
}
function ae(e) {
    while(!T(P()))N();
    return R(e, F);
}
function ce(e) {
    return V(ne("", null, null, null, [
        ""
    ], e = U(e), 0, [
        0
    ], e));
}
function ne(e, r, a, c, n, t, s, u, i) {
    var f = 0;
    var o = 0;
    var l = s;
    var v = 0;
    var h = 0;
    var p = 0;
    var b = 1;
    var w = 1;
    var $ = 1;
    var k = 0;
    var g = "";
    var m = n;
    var x = t;
    var y = c;
    var z = g;
    while(w)switch(p = k, k = N()){
        case 40:
            if (p != 108 && z.charCodeAt(l - 1) == 58) {
                if (C(z += j(W(k), "&", "&\f"), "&\f") != -1) $ = -1;
                break;
            }
        case 34:
        case 39:
        case 91:
            z += W(k);
            break;
        case 9:
        case 10:
        case 13:
        case 32:
            z += Y(p);
            break;
        case 92:
            z += _(Q() - 1, 7);
            continue;
        case 47:
            switch(P()){
                case 42:
                case 47:
                    S(se(re(N(), Q()), r, a), i);
                    break;
                default:
                    z += "/";
            }
            break;
        case 123 * b:
            u[f++] = O(z) * $;
        case 125 * b:
        case 59:
        case 0:
            switch(k){
                case 0:
                case 125:
                    w = 0;
                case 59 + o:
                    if (h > 0 && O(z) - l) S(h > 32 ? ue(z + ";", c, a, l - 1) : ue(j(z, " ", "") + ";", c, a, l - 2), i);
                    break;
                case 59:
                    z += ";";
                default:
                    S(y = te(z, r, a, f, o, n, u, g, m = [], x = [], l), t);
                    if (k === 123) {
                        if (o === 0) ne(z, r, y, y, m, t, l, u, x);
                        else switch(v){
                            case 100:
                            case 109:
                            case 115:
                                ne(e, y, y, c && S(te(e, y, y, 0, 0, n, u, g, n, m = [], l), x), n, x, l, u, c ? m : x);
                                break;
                            default:
                                ne(z, y, y, y, [
                                    ""
                                ], x, 0, u, x);
                        }
                    }
            }
            f = o = h = 0, b = $ = 1, g = z = "", l = s;
            break;
        case 58:
            l = 1 + O(z), h = p;
        default:
            if (b < 1) {
                if (k == 123) --b;
                else if (k == 125 && b++ == 0 && L() == 125) continue;
            }
            switch(z += d(k), k * b){
                case 38:
                    $ = o > 0 ? 1 : (z += "\f", -1);
                    break;
                case 44:
                    u[f++] = (O(z) - 1) * $, $ = 1;
                    break;
                case 64:
                    if (P() === 45) z += W(N());
                    v = P(), o = l = O(g = z += ae(Q())), k++;
                    break;
                case 45:
                    if (p === 45 && O(z) == 2) b = 0;
            }
    }
    return t;
}
function te(e, r, a, c, t, s, u, i, f, o, l) {
    var v = t - 1;
    var h = t === 0 ? s : [
        ""
    ];
    var p = M(h);
    for(var b = 0, w = 0, $ = 0; b < c; ++b)for(var d = 0, g = A(e, v + 1, v = k(w = u[b])), m = e; d < p; ++d)if (m = x(w > 0 ? h[d] + " " + g : j(g, /&\f/g, h[d]))) f[$++] = m;
    return I(e, r, a, t === 0 ? n : i, f, o, l);
}
function se(e, r, a) {
    return I(e, r, a, c, d(K()), A(e, 2, -2), 0);
}
function ue(e, r, a, c) {
    return I(e, r, a, t, A(e, 0, c), A(e, c + 1, -1), c);
}
function ie(c, n) {
    switch(m(c, n)){
        case 5103:
            return a + "print-" + c + c;
        case 5737:
        case 4201:
        case 3177:
        case 3433:
        case 1641:
        case 4457:
        case 2921:
        case 5572:
        case 6356:
        case 5844:
        case 3191:
        case 6645:
        case 3005:
        case 6391:
        case 5879:
        case 5623:
        case 6135:
        case 4599:
        case 4855:
        case 4215:
        case 6389:
        case 5109:
        case 5365:
        case 5621:
        case 3829:
            return a + c + c;
        case 5349:
        case 4246:
        case 4810:
        case 6968:
        case 2756:
            return a + c + r + c + e + c + c;
        case 6828:
        case 4268:
            return a + c + e + c + c;
        case 6165:
            return a + c + e + "flex-" + c + c;
        case 5187:
            return a + c + j(c, /(\w+).+(:[^]+)/, a + "box-$1$2" + e + "flex-$1$2") + c;
        case 5443:
            return a + c + e + "flex-item-" + j(c, /flex-|-self/, "") + c;
        case 4675:
            return a + c + e + "flex-line-pack" + j(c, /align-content|flex-|-self/, "") + c;
        case 5548:
            return a + c + e + j(c, "shrink", "negative") + c;
        case 5292:
            return a + c + e + j(c, "basis", "preferred-size") + c;
        case 6060:
            return a + "box-" + j(c, "-grow", "") + a + c + e + j(c, "grow", "positive") + c;
        case 4554:
            return a + j(c, /([^-])(transform)/g, "$1" + a + "$2") + c;
        case 6187:
            return j(j(j(c, /(zoom-|grab)/, a + "$1"), /(image-set)/, a + "$1"), c, "") + c;
        case 5495:
        case 3959:
            return j(c, /(image-set\([^]*)/, a + "$1" + "$`$1");
        case 4968:
            return j(j(c, /(.+:)(flex-)?(.*)/, a + "box-pack:$3" + e + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + a + c + c;
        case 4095:
        case 3583:
        case 4068:
        case 2532:
            return j(c, /(.+)-inline(.+)/, a + "$1$2") + c;
        case 8116:
        case 7059:
        case 5753:
        case 5535:
        case 5445:
        case 5701:
        case 4933:
        case 4677:
        case 5533:
        case 5789:
        case 5021:
        case 4765:
            if (O(c) - 1 - n > 6) switch(z(c, n + 1)){
                case 109:
                    if (z(c, n + 4) !== 45) break;
                case 102:
                    return j(c, /(.+:)(.+)-([^]+)/, "$1" + a + "$2-$3" + "$1" + r + (z(c, n + 3) == 108 ? "$3" : "$2-$3")) + c;
                case 115:
                    return ~C(c, "stretch") ? ie(j(c, "stretch", "fill-available"), n) + c : c;
            }
            break;
        case 4949:
            if (z(c, n + 1) !== 115) break;
        case 6444:
            switch(z(c, O(c) - 3 - (~C(c, "!important") && 10))){
                case 107:
                    return j(c, ":", ":" + a) + c;
                case 101:
                    return j(c, /(.+:)([^;!]+)(;|!.+)?/, "$1" + a + (z(c, 14) === 45 ? "inline-" : "") + "box$3" + "$1" + a + "$2$3" + "$1" + e + "$2box$3") + c;
            }
            break;
        case 5936:
            switch(z(c, n + 11)){
                case 114:
                    return a + c + e + j(c, /[svh]\w+-[tblr]{2}/, "tb") + c;
                case 108:
                    return a + c + e + j(c, /[svh]\w+-[tblr]{2}/, "tb-rl") + c;
                case 45:
                    return a + c + e + j(c, /[svh]\w+-[tblr]{2}/, "lr") + c;
            }
            return a + c + e + c + c;
    }
    return c;
}
function fe(e, r) {
    var a = "";
    var c = M(e);
    for(var n = 0; n < c; n++)a += r(e[n], n, e, r) || "";
    return a;
}
function oe(e, r, a, s) {
    switch(e.type){
        case i:
        case t:
            return e.return = e.return || e.value;
        case c:
            return "";
        case p:
            return e.return = e.value + "{" + fe(e.children, s) + "}";
        case n:
            e.value = e.props.join(",");
    }
    return O(a = fe(e.children, s)) ? e.return = e.value + "{" + a + "}" : "";
}
function le(e) {
    var r = M(e);
    return function(a, c, n, t) {
        var s = "";
        for(var u = 0; u < r; u++)s += e[u](a, c, n, t) || "";
        return s;
    };
}
function ve(e) {
    return function(r) {
        if (!r.root) {
            if (r = r.return) e(r);
        }
    };
}
function he(c, s, u, i) {
    if (c.length > -1) {
        if (!c.return) switch(c.type){
            case t:
                c.return = ie(c.value, c.length);
                break;
            case p:
                return fe([
                    J(c, {
                        value: j(c.value, "@", "@" + a)
                    })
                ], i);
            case n:
                if (c.length) return q(c.props, function(n) {
                    switch(y(n, /(::plac\w+|:read-\w+)/)){
                        case ":read-only":
                        case ":read-write":
                            return fe([
                                J(c, {
                                    props: [
                                        j(n, /:(read-\w+)/, ":" + r + "$1")
                                    ]
                                })
                            ], i);
                        case "::placeholder":
                            return fe([
                                J(c, {
                                    props: [
                                        j(n, /:(plac\w+)/, ":" + a + "input-$1")
                                    ]
                                }),
                                J(c, {
                                    props: [
                                        j(n, /:(plac\w+)/, ":" + r + "$1")
                                    ]
                                }),
                                J(c, {
                                    props: [
                                        j(n, /:(plac\w+)/, e + "input-$1")
                                    ]
                                })
                            ], i);
                    }
                    return "";
                });
        }
    }
}
function pe(e) {
    switch(e.type){
        case n:
            e.props = e.props.map(function(r) {
                return q(X(r), function(r, a, c) {
                    switch(z(r, 0)){
                        case 12:
                            return A(r, 1, O(r));
                        case 0:
                        case 40:
                        case 43:
                        case 62:
                        case 126:
                            return r;
                        case 58:
                            if (c[++a] === "global") c[a] = "", c[++a] = "\f" + A(c[a], a = 1, -1);
                        case 32:
                            return a === 1 ? "" : r;
                        default:
                            switch(a){
                                case 0:
                                    e = r;
                                    return M(c) > 1 ? "" : r;
                                case a = M(c) - 1:
                                case 2:
                                    return a === 2 ? r + e + e : r + e;
                                default:
                                    return r;
                            }
                    }
                });
            });
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"hqSvo"}],"4H9s4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var weakMemoize = function weakMemoize(func) {
    // $FlowFixMe flow doesn't include all non-primitive types as allowed for weakmaps
    var cache = new WeakMap();
    return function(arg) {
        if (cache.has(arg)) // $FlowFixMe
        return cache.get(arg);
        var ret = func(arg);
        cache.set(arg, ret);
        return ret;
    };
};
exports.default = weakMemoize;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"hqSvo"}],"akntE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function memoize(fn) {
    var cache = Object.create(null);
    return function(arg) {
        if (cache[arg] === undefined) cache[arg] = fn(arg);
        return cache[arg];
    };
}
exports.default = memoize;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"hqSvo"}],"8XJ5i":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "serializeStyles", ()=>serializeStyles);
var _hash = require("@emotion/hash");
var _hashDefault = parcelHelpers.interopDefault(_hash);
var _unitless = require("@emotion/unitless");
var _unitlessDefault = parcelHelpers.interopDefault(_unitless);
var _memoize = require("@emotion/memoize");
var _memoizeDefault = parcelHelpers.interopDefault(_memoize);
var ILLEGAL_ESCAPE_SEQUENCE_ERROR = "You have illegal escape sequence in your template literal, most likely inside content's property value.\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \"content: '\\00d7';\" should become \"content: '\\\\00d7';\".\nYou can read more about this here:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences";
var UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty(property) {
    return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue(value) {
    return value != null && typeof value !== "boolean";
};
var processStyleName = /* #__PURE__ */ (0, _memoizeDefault.default)(function(styleName) {
    return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue(key, value) {
    switch(key){
        case "animation":
        case "animationName":
            if (typeof value === "string") return value.replace(animationRegex, function(match, p1, p2) {
                cursor = {
                    name: p1,
                    styles: p2,
                    next: cursor
                };
                return p1;
            });
    }
    if ((0, _unitlessDefault.default)[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) return value + "px";
    return value;
};
var contentValuePattern = /(var|attr|counters?|url|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
var contentValues = [
    "normal",
    "none",
    "initial",
    "inherit",
    "unset"
];
var oldProcessStyleValue = processStyleValue;
var msPattern = /^-ms-/;
var hyphenPattern = /-(.)/g;
var hyphenatedCache = {};
processStyleValue = function processStyleValue(key, value) {
    if (key === "content") {
        if (typeof value !== "string" || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value + "\"'`");
    }
    var processed = oldProcessStyleValue(key, value);
    if (processed !== "" && !isCustomProperty(key) && key.indexOf("-") !== -1 && hyphenatedCache[key] === undefined) {
        hyphenatedCache[key] = true;
        console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key.replace(msPattern, "ms-").replace(hyphenPattern, function(str, _char) {
            return _char.toUpperCase();
        }) + "?");
    }
    return processed;
};
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
    if (interpolation == null) return "";
    if (interpolation.__emotion_styles !== undefined) {
        if (interpolation.toString() === "NO_COMPONENT_SELECTOR") throw new Error(noComponentSelectorMessage);
        return interpolation;
    }
    switch(typeof interpolation){
        case "boolean":
            return "";
        case "object":
            if (interpolation.anim === 1) {
                cursor = {
                    name: interpolation.name,
                    styles: interpolation.styles,
                    next: cursor
                };
                return interpolation.name;
            }
            if (interpolation.styles !== undefined) {
                var next = interpolation.next;
                if (next !== undefined) // not the most efficient thing ever but this is a pretty rare case
                // and there will be very few iterations of this generally
                while(next !== undefined){
                    cursor = {
                        name: next.name,
                        styles: next.styles,
                        next: cursor
                    };
                    next = next.next;
                }
                var styles = interpolation.styles + ";";
                if (interpolation.map !== undefined) styles += interpolation.map;
                return styles;
            }
            return createStringFromObject(mergedProps, registered, interpolation);
        case "function":
            if (mergedProps !== undefined) {
                var previousCursor = cursor;
                var result = interpolation(mergedProps);
                cursor = previousCursor;
                return handleInterpolation(mergedProps, registered, result);
            } else console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
            break;
        case "string":
            var matched = [];
            var replaced = interpolation.replace(animationRegex, function(match, p1, p2) {
                var fakeVarName = "animation" + matched.length;
                matched.push("const " + fakeVarName + " = keyframes`" + p2.replace(/^@keyframes animation-\w+/, "") + "`");
                return "${" + fakeVarName + "}";
            });
            if (matched.length) console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(matched, [
                "`" + replaced + "`"
            ]).join("\n") + "\n\nYou should wrap it with `css` like this:\n\n" + ("css`" + replaced + "`"));
            break;
    } // finalize string values (regular strings and functions interpolated into css calls)
    if (registered == null) return interpolation;
    var cached = registered[interpolation];
    return cached !== undefined ? cached : interpolation;
}
function createStringFromObject(mergedProps, registered, obj) {
    var string = "";
    if (Array.isArray(obj)) for(var i = 0; i < obj.length; i++)string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    else for(var _key in obj){
        var value = obj[_key];
        if (typeof value !== "object") {
            if (registered != null && registered[value] !== undefined) string += _key + "{" + registered[value] + "}";
            else if (isProcessableValue(value)) string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
        } else {
            if (_key === "NO_COMPONENT_SELECTOR" && true) throw new Error(noComponentSelectorMessage);
            if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === undefined)) {
                for(var _i = 0; _i < value.length; _i++)if (isProcessableValue(value[_i])) string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
            } else {
                var interpolated = handleInterpolation(mergedProps, registered, value);
                switch(_key){
                    case "animation":
                    case "animationName":
                        string += processStyleName(_key) + ":" + interpolated + ";";
                        break;
                    default:
                        if (_key === "undefined") console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);
                        string += _key + "{" + interpolated + "}";
                }
            }
        }
    }
    return string;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var sourceMapPattern;
sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
// keyframes are stored on the SerializedStyles object as a linked list
var cursor;
var serializeStyles = function serializeStyles(args, registered, mergedProps) {
    if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== undefined) return args[0];
    var stringMode = true;
    var styles = "";
    cursor = undefined;
    var strings = args[0];
    if (strings == null || strings.raw === undefined) {
        stringMode = false;
        styles += handleInterpolation(mergedProps, registered, strings);
    } else {
        if (strings[0] === undefined) console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
        styles += strings[0];
    } // we start at 1 since we've already handled the first arg
    for(var i = 1; i < args.length; i++){
        styles += handleInterpolation(mergedProps, registered, args[i]);
        if (stringMode) {
            if (strings[i] === undefined) console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
            styles += strings[i];
        }
    }
    var sourceMap;
    styles = styles.replace(sourceMapPattern, function(match) {
        sourceMap = match;
        return "";
    });
    labelPattern.lastIndex = 0;
    var identifierName = "";
    var match; // https://esbench.com/bench/5b809c2cf2949800a0f61fb5
    while((match = labelPattern.exec(styles)) !== null)identifierName += "-" + // $FlowFixMe we know it's not null
    match[1];
    var name = (0, _hashDefault.default)(styles) + identifierName;
    // $FlowFixMe SerializedStyles type doesn't have toString property (and we don't want to add it)
    return {
        name: name,
        styles: styles,
        map: sourceMap,
        next: cursor,
        toString: function toString() {
            return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
        }
    };
};

},{"@emotion/hash":"hlXI2","@emotion/unitless":"9XzH1","@emotion/memoize":"akntE","@parcel/transformer-js/src/esmodule-helpers.js":"hqSvo"}],"hlXI2":[function(require,module,exports) {
/* eslint-disable */ // Inspired by https://github.com/garycourt/murmurhash-js
// Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function murmur2(str) {
    // 'm' and 'r' are mixing constants generated offline.
    // They're not really 'magic', they just happen to work well.
    // const m = 0x5bd1e995;
    // const r = 24;
    // Initialize the hash
    var h = 0; // Mix 4 bytes at a time into the hash
    var k, i = 0, len = str.length;
    for(; len >= 4; ++i, len -= 4){
        k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
        k = /* Math.imul(k, m): */ (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);
        k ^= /* k >>> r: */ k >>> 24;
        h = /* Math.imul(k, m): */ (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^ /* Math.imul(h, m): */ (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
    } // Handle the last few bytes of the input array
    switch(len){
        case 3:
            h ^= (str.charCodeAt(i + 2) & 0xff) << 16;
        case 2:
            h ^= (str.charCodeAt(i + 1) & 0xff) << 8;
        case 1:
            h ^= str.charCodeAt(i) & 0xff;
            h = /* Math.imul(h, m): */ (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
    } // Do a few final mixes of the hash to ensure the last few
    // bytes are well-incorporated.
    h ^= h >>> 13;
    h = /* Math.imul(h, m): */ (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
    return ((h ^ h >>> 15) >>> 0).toString(36);
}
exports.default = murmur2;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"hqSvo"}],"9XzH1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var unitlessKeys = {
    animationIterationCount: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    // SVG-related properties
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
};
exports.default = unitlessKeys;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"hqSvo"}],"kU4Ka":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getRegisteredStyles", ()=>getRegisteredStyles);
parcelHelpers.export(exports, "insertStyles", ()=>insertStyles);
parcelHelpers.export(exports, "registerStyles", ()=>registerStyles);
var isBrowser = true;
function getRegisteredStyles(registered, registeredStyles, classNames) {
    var rawClassName = "";
    classNames.split(" ").forEach(function(className) {
        if (registered[className] !== undefined) registeredStyles.push(registered[className] + ";");
        else rawClassName += className + " ";
    });
    return rawClassName;
}
var registerStyles = function registerStyles(cache, serialized, isStringTag) {
    var className = cache.key + "-" + serialized.name;
    if (// class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser === false) && cache.registered[className] === undefined) cache.registered[className] = serialized.styles;
};
var insertStyles = function insertStyles(cache, serialized, isStringTag) {
    registerStyles(cache, serialized, isStringTag);
    var className = cache.key + "-" + serialized.name;
    if (cache.inserted[serialized.name] === undefined) {
        var current = serialized;
        do {
            var maybeStyles = cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
            current = current.next;
        }while (current !== undefined);
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"hqSvo"}],"dmLTS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _cache = require("@emotion/cache");
var _cacheDefault = parcelHelpers.interopDefault(_cache);
var _serialize = require("@emotion/serialize");
var _utils = require("@emotion/utils");
function insertWithoutScoping(cache, serialized) {
    if (cache.inserted[serialized.name] === undefined) return cache.insert("", serialized, cache.sheet, true);
}
function merge(registered, css, className) {
    var registeredStyles = [];
    var rawClassName = (0, _utils.getRegisteredStyles)(registered, registeredStyles, className);
    if (registeredStyles.length < 2) return className;
    return rawClassName + css(registeredStyles);
}
var createEmotion = function createEmotion(options) {
    var cache = (0, _cacheDefault.default)(options); // $FlowFixMe
    cache.sheet.speedy = function(value) {
        if (this.ctr !== 0) throw new Error("speedy must be changed before any rules are inserted");
        this.isSpeedy = value;
    };
    cache.compat = true;
    var css = function css() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        var serialized = (0, _serialize.serializeStyles)(args, cache.registered, undefined);
        (0, _utils.insertStyles)(cache, serialized, false);
        return cache.key + "-" + serialized.name;
    };
    var keyframes = function keyframes() {
        for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++)args[_key2] = arguments[_key2];
        var serialized = (0, _serialize.serializeStyles)(args, cache.registered);
        var animation = "animation-" + serialized.name;
        insertWithoutScoping(cache, {
            name: serialized.name,
            styles: "@keyframes " + animation + "{" + serialized.styles + "}"
        });
        return animation;
    };
    var injectGlobal = function injectGlobal() {
        for(var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++)args[_key3] = arguments[_key3];
        var serialized = (0, _serialize.serializeStyles)(args, cache.registered);
        insertWithoutScoping(cache, serialized);
    };
    var cx = function cx() {
        for(var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++)args[_key4] = arguments[_key4];
        return merge(cache.registered, css, classnames(args));
    };
    return {
        css: css,
        cx: cx,
        injectGlobal: injectGlobal,
        keyframes: keyframes,
        hydrate: function hydrate(ids) {
            ids.forEach(function(key) {
                cache.inserted[key] = true;
            });
        },
        flush: function flush() {
            cache.registered = {};
            cache.inserted = {};
            cache.sheet.flush();
        },
        // $FlowFixMe
        sheet: cache.sheet,
        cache: cache,
        getRegisteredStyles: (0, _utils.getRegisteredStyles).bind(null, cache.registered),
        merge: merge.bind(null, cache.registered, css)
    };
};
var classnames = function classnames(args) {
    var cls = "";
    for(var i = 0; i < args.length; i++){
        var arg = args[i];
        if (arg == null) continue;
        var toAdd = void 0;
        switch(typeof arg){
            case "boolean":
                break;
            case "object":
                if (Array.isArray(arg)) toAdd = classnames(arg);
                else {
                    toAdd = "";
                    for(var k in arg)if (arg[k] && k) {
                        toAdd && (toAdd += " ");
                        toAdd += k;
                    }
                }
                break;
            default:
                toAdd = arg;
        }
        if (toAdd) {
            cls && (cls += " ");
            cls += toAdd;
        }
    }
    return cls;
};
exports.default = createEmotion;

},{"@emotion/cache":"dychw","@emotion/serialize":"8XJ5i","@emotion/utils":"kU4Ka","@parcel/transformer-js/src/esmodule-helpers.js":"hqSvo"}],"kYP2X":[function(require,module,exports) {
!function(t, e) {
    module.exports = e();
}(this, function() {
    "use strict";
    var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", f = "month", h = "quarter", c = "year", d = "date", $ = "Invalid Date", l = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = {
        name: "en",
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_")
    }, m = function(t, e, n) {
        var r = String(t);
        return !r || r.length >= e ? t : "" + Array(e + 1 - r.length).join(n) + t;
    }, g = {
        s: m,
        z: function(t) {
            var e = -t.utcOffset(), n = Math.abs(e), r = Math.floor(n / 60), i = n % 60;
            return (e <= 0 ? "+" : "-") + m(r, 2, "0") + ":" + m(i, 2, "0");
        },
        m: function t(e, n) {
            if (e.date() < n.date()) return -t(n, e);
            var r = 12 * (n.year() - e.year()) + (n.month() - e.month()), i = e.clone().add(r, f), s = n - i < 0, u = e.clone().add(r + (s ? -1 : 1), f);
            return +(-(r + (n - i) / (s ? i - u : u - i)) || 0);
        },
        a: function(t) {
            return t < 0 ? Math.ceil(t) || 0 : Math.floor(t);
        },
        p: function(t) {
            return ({
                M: f,
                y: c,
                w: o,
                d: a,
                D: d,
                h: u,
                m: s,
                s: i,
                ms: r,
                Q: h
            })[t] || String(t || "").toLowerCase().replace(/s$/, "");
        },
        u: function(t) {
            return void 0 === t;
        }
    }, v = "en", D = {};
    D[v] = M;
    var p = function(t) {
        return t instanceof _;
    }, S = function t(e, n, r) {
        var i;
        if (!e) return v;
        if ("string" == typeof e) {
            var s = e.toLowerCase();
            D[s] && (i = s), n && (D[s] = n, i = s);
            var u = e.split("-");
            if (!i && u.length > 1) return t(u[0]);
        } else {
            var a = e.name;
            D[a] = e, i = a;
        }
        return !r && i && (v = i), i || !r && v;
    }, w = function(t, e) {
        if (p(t)) return t.clone();
        var n = "object" == typeof e ? e : {};
        return n.date = t, n.args = arguments, new _(n);
    }, O = g;
    O.l = S, O.i = p, O.w = function(t, e) {
        return w(t, {
            locale: e.$L,
            utc: e.$u,
            x: e.$x,
            $offset: e.$offset
        });
    };
    var _ = function() {
        function M(t) {
            this.$L = S(t.locale, null, !0), this.parse(t);
        }
        var m = M.prototype;
        return m.parse = function(t) {
            this.$d = function(t) {
                var e = t.date, n = t.utc;
                if (null === e) return new Date(NaN);
                if (O.u(e)) return new Date;
                if (e instanceof Date) return new Date(e);
                if ("string" == typeof e && !/Z$/i.test(e)) {
                    var r = e.match(l);
                    if (r) {
                        var i = r[2] - 1 || 0, s = (r[7] || "0").substring(0, 3);
                        return n ? new Date(Date.UTC(r[1], i, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, s)) : new Date(r[1], i, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, s);
                    }
                }
                return new Date(e);
            }(t), this.$x = t.x || {}, this.init();
        }, m.init = function() {
            var t = this.$d;
            this.$y = t.getFullYear(), this.$M = t.getMonth(), this.$D = t.getDate(), this.$W = t.getDay(), this.$H = t.getHours(), this.$m = t.getMinutes(), this.$s = t.getSeconds(), this.$ms = t.getMilliseconds();
        }, m.$utils = function() {
            return O;
        }, m.isValid = function() {
            return !(this.$d.toString() === $);
        }, m.isSame = function(t, e) {
            var n = w(t);
            return this.startOf(e) <= n && n <= this.endOf(e);
        }, m.isAfter = function(t, e) {
            return w(t) < this.startOf(e);
        }, m.isBefore = function(t, e) {
            return this.endOf(e) < w(t);
        }, m.$g = function(t, e, n) {
            return O.u(t) ? this[e] : this.set(n, t);
        }, m.unix = function() {
            return Math.floor(this.valueOf() / 1e3);
        }, m.valueOf = function() {
            return this.$d.getTime();
        }, m.startOf = function(t, e) {
            var n = this, r = !!O.u(e) || e, h = O.p(t), $ = function(t, e) {
                var i = O.w(n.$u ? Date.UTC(n.$y, e, t) : new Date(n.$y, e, t), n);
                return r ? i : i.endOf(a);
            }, l = function(t, e) {
                return O.w(n.toDate()[t].apply(n.toDate("s"), (r ? [
                    0,
                    0,
                    0,
                    0
                ] : [
                    23,
                    59,
                    59,
                    999
                ]).slice(e)), n);
            }, y = this.$W, M = this.$M, m = this.$D, g = "set" + (this.$u ? "UTC" : "");
            switch(h){
                case c:
                    return r ? $(1, 0) : $(31, 11);
                case f:
                    return r ? $(1, M) : $(0, M + 1);
                case o:
                    var v = this.$locale().weekStart || 0, D = (y < v ? y + 7 : y) - v;
                    return $(r ? m - D : m + (6 - D), M);
                case a:
                case d:
                    return l(g + "Hours", 0);
                case u:
                    return l(g + "Minutes", 1);
                case s:
                    return l(g + "Seconds", 2);
                case i:
                    return l(g + "Milliseconds", 3);
                default:
                    return this.clone();
            }
        }, m.endOf = function(t) {
            return this.startOf(t, !1);
        }, m.$set = function(t, e) {
            var n, o = O.p(t), h = "set" + (this.$u ? "UTC" : ""), $ = (n = {}, n[a] = h + "Date", n[d] = h + "Date", n[f] = h + "Month", n[c] = h + "FullYear", n[u] = h + "Hours", n[s] = h + "Minutes", n[i] = h + "Seconds", n[r] = h + "Milliseconds", n)[o], l = o === a ? this.$D + (e - this.$W) : e;
            if (o === f || o === c) {
                var y = this.clone().set(d, 1);
                y.$d[$](l), y.init(), this.$d = y.set(d, Math.min(this.$D, y.daysInMonth())).$d;
            } else $ && this.$d[$](l);
            return this.init(), this;
        }, m.set = function(t, e) {
            return this.clone().$set(t, e);
        }, m.get = function(t) {
            return this[O.p(t)]();
        }, m.add = function(r, h) {
            var d, $ = this;
            r = Number(r);
            var l = O.p(h), y = function(t) {
                var e = w($);
                return O.w(e.date(e.date() + Math.round(t * r)), $);
            };
            if (l === f) return this.set(f, this.$M + r);
            if (l === c) return this.set(c, this.$y + r);
            if (l === a) return y(1);
            if (l === o) return y(7);
            var M = (d = {}, d[s] = e, d[u] = n, d[i] = t, d)[l] || 1, m = this.$d.getTime() + r * M;
            return O.w(m, this);
        }, m.subtract = function(t, e) {
            return this.add(-1 * t, e);
        }, m.format = function(t) {
            var e = this, n = this.$locale();
            if (!this.isValid()) return n.invalidDate || $;
            var r = t || "YYYY-MM-DDTHH:mm:ssZ", i = O.z(this), s = this.$H, u = this.$m, a = this.$M, o = n.weekdays, f = n.months, h = function(t, n, i, s) {
                return t && (t[n] || t(e, r)) || i[n].slice(0, s);
            }, c = function(t) {
                return O.s(s % 12 || 12, t, "0");
            }, d = n.meridiem || function(t, e, n) {
                var r = t < 12 ? "AM" : "PM";
                return n ? r.toLowerCase() : r;
            }, l = {
                YY: String(this.$y).slice(-2),
                YYYY: this.$y,
                M: a + 1,
                MM: O.s(a + 1, 2, "0"),
                MMM: h(n.monthsShort, a, f, 3),
                MMMM: h(f, a),
                D: this.$D,
                DD: O.s(this.$D, 2, "0"),
                d: String(this.$W),
                dd: h(n.weekdaysMin, this.$W, o, 2),
                ddd: h(n.weekdaysShort, this.$W, o, 3),
                dddd: o[this.$W],
                H: String(s),
                HH: O.s(s, 2, "0"),
                h: c(1),
                hh: c(2),
                a: d(s, u, !0),
                A: d(s, u, !1),
                m: String(u),
                mm: O.s(u, 2, "0"),
                s: String(this.$s),
                ss: O.s(this.$s, 2, "0"),
                SSS: O.s(this.$ms, 3, "0"),
                Z: i
            };
            return r.replace(y, function(t, e) {
                return e || l[t] || i.replace(":", "");
            });
        }, m.utcOffset = function() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m.diff = function(r, d, $) {
            var l, y = O.p(d), M = w(r), m = (M.utcOffset() - this.utcOffset()) * e, g = this - M, v = O.m(this, M);
            return v = (l = {}, l[c] = v / 12, l[f] = v, l[h] = v / 3, l[o] = (g - m) / 6048e5, l[a] = (g - m) / 864e5, l[u] = g / n, l[s] = g / e, l[i] = g / t, l)[y] || g, $ ? v : O.a(v);
        }, m.daysInMonth = function() {
            return this.endOf(f).$D;
        }, m.$locale = function() {
            return D[this.$L];
        }, m.locale = function(t, e) {
            if (!t) return this.$L;
            var n = this.clone(), r = S(t, e, !0);
            return r && (n.$L = r), n;
        }, m.clone = function() {
            return O.w(this.$d, this);
        }, m.toDate = function() {
            return new Date(this.valueOf());
        }, m.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
        }, m.toISOString = function() {
            return this.$d.toISOString();
        }, m.toString = function() {
            return this.$d.toUTCString();
        }, M;
    }(), T = _.prototype;
    return w.prototype = T, [
        [
            "$ms",
            r
        ],
        [
            "$s",
            i
        ],
        [
            "$m",
            s
        ],
        [
            "$H",
            u
        ],
        [
            "$W",
            a
        ],
        [
            "$M",
            f
        ],
        [
            "$y",
            c
        ],
        [
            "$D",
            d
        ]
    ].forEach(function(t) {
        T[t[1]] = function(e) {
            return this.$g(e, t[0], t[1]);
        };
    }), w.extend = function(t, e) {
        return t.$i || (t(e, _, w), t.$i = !0), w;
    }, w.locale = S, w.isDayjs = p, w.unix = function(t) {
        return w(1e3 * t);
    }, w.en = D[v], w.Ls = D, w.p = {}, w;
});

},{}],"g4LUz":[function(require,module,exports) {
!function(t, i) {
    module.exports = i();
}(this, function() {
    "use strict";
    var t = "minute", i = /[+-]\d\d(?::?\d\d)?/g, e = /([+-]|\d\d)/g;
    return function(s, f, n) {
        var u = f.prototype;
        n.utc = function(t) {
            var i = {
                date: t,
                utc: !0,
                args: arguments
            };
            return new f(i);
        }, u.utc = function(i) {
            var e = n(this.toDate(), {
                locale: this.$L,
                utc: !0
            });
            return i ? e.add(this.utcOffset(), t) : e;
        }, u.local = function() {
            return n(this.toDate(), {
                locale: this.$L,
                utc: !1
            });
        };
        var o = u.parse;
        u.parse = function(t) {
            t.utc && (this.$u = !0), this.$utils().u(t.$offset) || (this.$offset = t.$offset), o.call(this, t);
        };
        var r = u.init;
        u.init = function() {
            if (this.$u) {
                var t = this.$d;
                this.$y = t.getUTCFullYear(), this.$M = t.getUTCMonth(), this.$D = t.getUTCDate(), this.$W = t.getUTCDay(), this.$H = t.getUTCHours(), this.$m = t.getUTCMinutes(), this.$s = t.getUTCSeconds(), this.$ms = t.getUTCMilliseconds();
            } else r.call(this);
        };
        var a = u.utcOffset;
        u.utcOffset = function(s, f) {
            var n = this.$utils().u;
            if (n(s)) return this.$u ? 0 : n(this.$offset) ? a.call(this) : this.$offset;
            if ("string" == typeof s && (s = function(t) {
                void 0 === t && (t = "");
                var s = t.match(i);
                if (!s) return null;
                var f = ("" + s[0]).match(e) || [
                    "-",
                    0,
                    0
                ], n = f[0], u = 60 * +f[1] + +f[2];
                return 0 === u ? 0 : "+" === n ? u : -u;
            }(s), null === s)) return this;
            var u = Math.abs(s) <= 16 ? 60 * s : s, o = this;
            if (f) return o.$offset = u, o.$u = 0 === s, o;
            if (0 !== s) {
                var r = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
                (o = this.local().add(u + r, t)).$offset = u, o.$x.$localOffset = r;
            } else o = this.utc();
            return o;
        };
        var h = u.format;
        u.format = function(t) {
            var i = t || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
            return h.call(this, i);
        }, u.valueOf = function() {
            var t = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
            return this.$d.valueOf() - 6e4 * t;
        }, u.isUTC = function() {
            return !!this.$u;
        }, u.toISOString = function() {
            return this.toDate().toISOString();
        }, u.toString = function() {
            return this.toDate().toUTCString();
        };
        var l = u.toDate;
        u.toDate = function(t) {
            return "s" === t && this.$offset ? n(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : l.call(this);
        };
        var c = u.diff;
        u.diff = function(t, i, e) {
            if (t && this.$u === t.$u) return c.call(this, t, i, e);
            var s = this.local(), f = n(t).local();
            return c.call(s, f, i, e);
        };
    };
});

},{}],"3M5EC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lottieWeb = require("lottie-web");
var _lottieWebDefault = parcelHelpers.interopDefault(_lottieWeb);
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
var _react1 = require("fast-deep-equal/es6/react");
var _reactDefault1 = parcelHelpers.interopDefault(_react1);
var _default = require("rfdc/default");
var _defaultDefault = parcelHelpers.interopDefault(_default);
function _extends() {
    _extends = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
function createCommonjsModule(fn, module) {
    return module = {
        exports: {}
    }, fn(module, module.exports), module.exports;
}
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var b = "function" === typeof Symbol && Symbol.for, c = b ? Symbol.for("react.element") : 60103, d = b ? Symbol.for("react.portal") : 60106, e = b ? Symbol.for("react.fragment") : 60107, f = b ? Symbol.for("react.strict_mode") : 60108, g = b ? Symbol.for("react.profiler") : 60114, h = b ? Symbol.for("react.provider") : 60109, k = b ? Symbol.for("react.context") : 60110, l = b ? Symbol.for("react.async_mode") : 60111, m = b ? Symbol.for("react.concurrent_mode") : 60111, n = b ? Symbol.for("react.forward_ref") : 60112, p = b ? Symbol.for("react.suspense") : 60113, q = b ? Symbol.for("react.suspense_list") : 60120, r = b ? Symbol.for("react.memo") : 60115, t = b ? Symbol.for("react.lazy") : 60116, v = b ? Symbol.for("react.block") : 60121, w = b ? Symbol.for("react.fundamental") : 60117, x = b ? Symbol.for("react.responder") : 60118, y = b ? Symbol.for("react.scope") : 60119;
function z(a) {
    if ("object" === typeof a && null !== a) {
        var u = a.$$typeof;
        switch(u){
            case c:
                switch(a = a.type, a){
                    case l:
                    case m:
                    case e:
                    case g:
                    case f:
                    case p:
                        return a;
                    default:
                        switch(a = a && a.$$typeof, a){
                            case k:
                            case n:
                            case t:
                            case r:
                            case h:
                                return a;
                            default:
                                return u;
                        }
                }
            case d:
                return u;
        }
    }
}
function A(a) {
    return z(a) === m;
}
var AsyncMode = l;
var ConcurrentMode = m;
var ContextConsumer = k;
var ContextProvider = h;
var Element = c;
var ForwardRef = n;
var Fragment = e;
var Lazy = t;
var Memo = r;
var Portal = d;
var Profiler = g;
var StrictMode = f;
var Suspense = p;
var isAsyncMode = function(a) {
    return A(a) || z(a) === l;
};
var isConcurrentMode = A;
var isContextConsumer = function(a) {
    return z(a) === k;
};
var isContextProvider = function(a) {
    return z(a) === h;
};
var isElement = function(a) {
    return "object" === typeof a && null !== a && a.$$typeof === c;
};
var isForwardRef = function(a) {
    return z(a) === n;
};
var isFragment = function(a) {
    return z(a) === e;
};
var isLazy = function(a) {
    return z(a) === t;
};
var isMemo = function(a) {
    return z(a) === r;
};
var isPortal = function(a) {
    return z(a) === d;
};
var isProfiler = function(a) {
    return z(a) === g;
};
var isStrictMode = function(a) {
    return z(a) === f;
};
var isSuspense = function(a) {
    return z(a) === p;
};
var isValidElementType = function(a) {
    return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
};
var typeOf = z;
var reactIs_production_min = {
    AsyncMode: AsyncMode,
    ConcurrentMode: ConcurrentMode,
    ContextConsumer: ContextConsumer,
    ContextProvider: ContextProvider,
    Element: Element,
    ForwardRef: ForwardRef,
    Fragment: Fragment,
    Lazy: Lazy,
    Memo: Memo,
    Portal: Portal,
    Profiler: Profiler,
    StrictMode: StrictMode,
    Suspense: Suspense,
    isAsyncMode: isAsyncMode,
    isConcurrentMode: isConcurrentMode,
    isContextConsumer: isContextConsumer,
    isContextProvider: isContextProvider,
    isElement: isElement,
    isForwardRef: isForwardRef,
    isFragment: isFragment,
    isLazy: isLazy,
    isMemo: isMemo,
    isPortal: isPortal,
    isProfiler: isProfiler,
    isStrictMode: isStrictMode,
    isSuspense: isSuspense,
    isValidElementType: isValidElementType,
    typeOf: typeOf
};
var reactIs_development = createCommonjsModule(function(module, exports) {
    (function() {
        // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
        // nor polyfill, then a plain number is used for performance.
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 0xeac7;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 0xeaca;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 0xeacb;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 0xeacc;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 0xead2;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 0xeacd;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
        // (unstable) APIs that have been removed. Can we remove the symbols?
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 0xeacf;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 0xeacf;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 0xead0;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 0xead1;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 0xead8;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 0xead3;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 0xead4;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 0xead9;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 0xead5;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 0xead6;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 0xead7;
        function isValidElementType(type) {
            return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
            type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
            if (typeof object === "object" && object !== null) {
                var $$typeof = object.$$typeof;
                switch($$typeof){
                    case REACT_ELEMENT_TYPE:
                        var type = object.type;
                        switch(type){
                            case REACT_ASYNC_MODE_TYPE:
                            case REACT_CONCURRENT_MODE_TYPE:
                            case REACT_FRAGMENT_TYPE:
                            case REACT_PROFILER_TYPE:
                            case REACT_STRICT_MODE_TYPE:
                            case REACT_SUSPENSE_TYPE:
                                return type;
                            default:
                                var $$typeofType = type && type.$$typeof;
                                switch($$typeofType){
                                    case REACT_CONTEXT_TYPE:
                                    case REACT_FORWARD_REF_TYPE:
                                    case REACT_LAZY_TYPE:
                                    case REACT_MEMO_TYPE:
                                    case REACT_PROVIDER_TYPE:
                                        return $$typeofType;
                                    default:
                                        return $$typeof;
                                }
                        }
                    case REACT_PORTAL_TYPE:
                        return $$typeof;
                }
            }
            return undefined;
        } // AsyncMode is deprecated along with isAsyncMode
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated
        function isAsyncMode(object) {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint
                console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
            return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
            return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
            return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
            return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
            return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
            return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
            return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
            return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
            return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
            return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
            return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
            return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
    })();
});
var reactIs = createCommonjsModule(function(module) {
    module.exports = reactIs_development;
});
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/ /* eslint-disable no-unused-vars */ var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
    if (val === null || val === undefined) throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(val);
}
function shouldUseNative() {
    try {
        if (!Object.assign) return false;
        // Detect buggy property enumeration order in older V8 versions.
        // https://bugs.chromium.org/p/v8/issues/detail?id=4118
        var test1 = new String("abc"); // eslint-disable-line no-new-wrappers
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") return false;
        // https://bugs.chromium.org/p/v8/issues/detail?id=3056
        var test2 = {};
        for(var i = 0; i < 10; i++)test2["_" + String.fromCharCode(i)] = i;
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
            return test2[n];
        });
        if (order2.join("") !== "0123456789") return false;
        // https://bugs.chromium.org/p/v8/issues/detail?id=3056
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
            test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") return false;
        return true;
    } catch (err) {
        // We don't expect any of the above to throw, but better to be safe.
        return false;
    }
}
var objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
    var from;
    var to = toObject(target);
    var symbols;
    for(var s = 1; s < arguments.length; s++){
        from = Object(arguments[s]);
        for(var key in from)if (hasOwnProperty.call(from, key)) to[key] = from[key];
        if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for(var i = 0; i < symbols.length; i++)if (propIsEnumerable.call(from, symbols[i])) to[symbols[i]] = from[symbols[i]];
        }
    }
    return to;
};
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1 = ReactPropTypesSecret;
var printWarning = function() {};
var ReactPropTypesSecret$1 = ReactPropTypesSecret_1;
var loggedTypeFailures = {};
var has = Function.call.bind(Object.prototype.hasOwnProperty);
printWarning = function(text) {
    var message = "Warning: " + text;
    if (typeof console !== "undefined") console.error(message);
    try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
    } catch (x) {}
};
/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */ function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
    for(var typeSpecName in typeSpecs)if (has(typeSpecs, typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
            // This is intentionally an invariant that gets caught. It's the same
            // behavior as without this statement except with a better message.
            if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; " + "it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.");
                err.name = "Invariant Violation";
                throw err;
            }
            error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret$1);
        } catch (ex) {
            error = ex;
        }
        if (error && !(error instanceof Error)) printWarning((componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker " + "function must return `null` or an `Error` but returned a " + typeof error + ". " + "You may have forgotten to pass an argument to the type checker " + "creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and " + "shape all require an argument).");
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
            // Only monitor this failure once because there tends to be a lot of the
            // same error.
            loggedTypeFailures[error.message] = true;
            var stack = getStack ? getStack() : "";
            printWarning("Failed " + location + " type: " + error.message + (stack != null ? stack : ""));
        }
    }
}
/**
 * Resets warning cache when testing.
 *
 * @private
 */ checkPropTypes.resetWarningCache = function() {
    loggedTypeFailures = {};
};
var checkPropTypes_1 = checkPropTypes;
var has$1 = Function.call.bind(Object.prototype.hasOwnProperty);
var printWarning$1 = function() {};
printWarning$1 = function(text) {
    var message = "Warning: " + text;
    if (typeof console !== "undefined") console.error(message);
    try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
    } catch (x) {}
};
function emptyFunctionThatReturnsNull() {
    return null;
}
var factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {
    /* global Symbol */ var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = "@@iterator"; // Before Symbol spec.
    /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */ function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") return iteratorFn;
    }
    /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */ var ANONYMOUS = "<<anonymous>>";
    // Important!
    // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
    var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
    };
    /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */ /*eslint-disable no-self-compare*/ function is(x, y) {
        // SameValue algorithm
        if (x === y) // Steps 1-5, 7-10
        // Steps 6.b-6.e: +0 != -0
        return x !== 0 || 1 / x === 1 / y;
        else // Step 6.a: NaN == NaN
        return x !== x && y !== y;
    }
    /*eslint-enable no-self-compare*/ /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */ function PropTypeError(message) {
        this.message = message;
        this.stack = "";
    }
    // Make `instanceof Error` still work for returned errors.
    PropTypeError.prototype = Error.prototype;
    function createChainableTypeChecker(validate) {
        var manualPropTypeCallCache = {};
        var manualPropTypeWarningCount = 0;
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
            componentName = componentName || ANONYMOUS;
            propFullName = propFullName || propName;
            if (secret !== ReactPropTypesSecret_1) {
                if (throwOnDirectAccess) {
                    // New behavior only for users of `prop-types` package
                    var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types");
                    err.name = "Invariant Violation";
                    throw err;
                } else if (typeof console !== "undefined") {
                    // Old behavior for people using React.PropTypes
                    var cacheKey = componentName + ":" + propName;
                    if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
                    manualPropTypeWarningCount < 3) {
                        printWarning$1("You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated " + "and will throw in the standalone `prop-types` package. " + "You may be seeing this warning due to a third-party PropTypes " + "library. See https://fb.me/react-warning-dont-call-proptypes " + "for details.");
                        manualPropTypeCallCache[cacheKey] = true;
                        manualPropTypeWarningCount++;
                    }
                }
            }
            if (props[propName] == null) {
                if (isRequired) {
                    if (props[propName] === null) return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
                    return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
                }
                return null;
            } else return validate(props, propName, componentName, location, propFullName);
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
    }
    function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== expectedType) {
                // `propValue` being instance of, say, date/regexp, pass the 'object'
                // check, but we can offer a more precise error message here rather than
                // 'of type `object`'.
                var preciseType = getPreciseType(propValue);
                return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
    }
    function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== "function") return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
            var propValue = props[propName];
            if (!Array.isArray(propValue)) {
                var propType = getPropType(propValue);
                return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
            }
            for(var i = 0; i < propValue.length; i++){
                var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret_1);
                if (error instanceof Error) return error;
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            if (!isValidElement(propValue)) {
                var propType = getPropType(propValue);
                return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            if (!reactIs.isValidElementType(propValue)) {
                var propType = getPropType(propValue);
                return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
            if (!(props[propName] instanceof expectedClass)) {
                var expectedClassName = expectedClass.name || ANONYMOUS;
                var actualClassName = getClassName(props[propName]);
                return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
            {
                if (arguments.length > 1) printWarning$1("Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. " + "A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).");
                else printWarning$1("Invalid argument supplied to oneOf, expected an array.");
            }
            return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            for(var i = 0; i < expectedValues.length; i++){
                if (is(propValue, expectedValues[i])) return null;
            }
            var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
                var type = getPreciseType(value);
                if (type === "symbol") return String(value);
                return value;
            });
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
    }
    function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== "function") return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
            for(var key in propValue)if (has$1(propValue, key)) {
                var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret_1);
                if (error instanceof Error) return error;
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
            printWarning$1("Invalid argument supplied to oneOfType, expected an instance of array.");
            return emptyFunctionThatReturnsNull;
        }
        for(var i = 0; i < arrayOfTypeCheckers.length; i++){
            var checker = arrayOfTypeCheckers[i];
            if (typeof checker !== "function") {
                printWarning$1("Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + ".");
                return emptyFunctionThatReturnsNull;
            }
        }
        function validate(props, propName, componentName, location, propFullName) {
            for(var i = 0; i < arrayOfTypeCheckers.length; i++){
                var checker = arrayOfTypeCheckers[i];
                if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret_1) == null) return null;
            }
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`."));
        }
        return createChainableTypeChecker(validate);
    }
    function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
            if (!isNode(props[propName])) return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
            for(var key in shapeTypes){
                var checker = shapeTypes[key];
                if (!checker) continue;
                var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret_1);
                if (error) return error;
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
            // We need to check all keys in case some are required but missing from
            // props.
            var allKeys = objectAssign({}, props[propName], shapeTypes);
            for(var key in allKeys){
                var checker = shapeTypes[key];
                if (!checker) return new PropTypeError("Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`." + "\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  "));
                var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret_1);
                if (error) return error;
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function isNode(propValue) {
        switch(typeof propValue){
            case "number":
            case "string":
            case "undefined":
                return true;
            case "boolean":
                return !propValue;
            case "object":
                if (Array.isArray(propValue)) return propValue.every(isNode);
                if (propValue === null || isValidElement(propValue)) return true;
                var iteratorFn = getIteratorFn(propValue);
                if (iteratorFn) {
                    var iterator = iteratorFn.call(propValue);
                    var step;
                    if (iteratorFn !== propValue.entries) while(!(step = iterator.next()).done){
                        if (!isNode(step.value)) return false;
                    }
                    else // Iterator will provide entry [k,v] tuples rather than values.
                    while(!(step = iterator.next()).done){
                        var entry = step.value;
                        if (entry) {
                            if (!isNode(entry[1])) return false;
                        }
                    }
                } else return false;
                return true;
            default:
                return false;
        }
    }
    function isSymbol(propType, propValue) {
        // Native Symbol.
        if (propType === "symbol") return true;
        // falsy value can't be a Symbol
        if (!propValue) return false;
        // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
        if (propValue["@@toStringTag"] === "Symbol") return true;
        // Fallback for non-spec compliant Symbols which are polyfilled.
        if (typeof Symbol === "function" && propValue instanceof Symbol) return true;
        return false;
    }
    // Equivalent of `typeof` but with special handling for array and regexp.
    function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) return "array";
        if (propValue instanceof RegExp) // Old webkits (at least until Android 4.0) return 'function' rather than
        // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
        // passes PropTypes.object.
        return "object";
        if (isSymbol(propType, propValue)) return "symbol";
        return propType;
    }
    // This handles more types than `getPropType`. Only used for error messages.
    // See `createPrimitiveTypeChecker`.
    function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) return "" + propValue;
        var propType = getPropType(propValue);
        if (propType === "object") {
            if (propValue instanceof Date) return "date";
            else if (propValue instanceof RegExp) return "regexp";
        }
        return propType;
    }
    // Returns a string that is postfixed to a warning about an invalid type.
    // For example, "undefined" or "of type array"
    function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch(type){
            case "array":
            case "object":
                return "an " + type;
            case "boolean":
            case "date":
            case "regexp":
                return "a " + type;
            default:
                return type;
        }
    }
    // Returns class name of the object, if any.
    function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) return ANONYMOUS;
        return propValue.constructor.name;
    }
    ReactPropTypes.checkPropTypes = checkPropTypes_1;
    ReactPropTypes.resetWarningCache = checkPropTypes_1.resetWarningCache;
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
};
function emptyFunction() {}
function emptyFunctionWithReset() {}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
    function shim(props, propName, componentName, location, propFullName, secret) {
        if (secret === ReactPropTypesSecret_1) // It is still safe when called from React.
        return;
        var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
        err.name = "Invariant Violation";
        throw err;
    }
    shim.isRequired = shim;
    function getShim() {
        return shim;
    } // Important!
    // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
    var ReactPropTypes = {
        array: shim,
        bool: shim,
        func: shim,
        number: shim,
        object: shim,
        string: shim,
        symbol: shim,
        any: shim,
        arrayOf: getShim,
        element: shim,
        elementType: shim,
        instanceOf: getShim,
        node: shim,
        objectOf: getShim,
        oneOf: getShim,
        oneOfType: getShim,
        shape: getShim,
        exact: getShim,
        checkPropTypes: emptyFunctionWithReset,
        resetWarningCache: emptyFunction
    };
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
};
var propTypes = createCommonjsModule(function(module) {
    var ReactIs = reactIs;
    // By explicitly using `prop-types` you are opting into new development behavior.
    // http://fb.me/prop-types-in-prod
    var throwOnDirectAccess = true;
    module.exports = factoryWithTypeCheckers(ReactIs.isElement, throwOnDirectAccess);
});
var makeLottiePlayer = function makeLottiePlayer(lottie) {
    var Lottie = (0, _react.memo)(function(_ref) {
        var animationData = _ref.animationData, path = _ref.path, play = _ref.play, speed = _ref.speed, direction = _ref.direction, segmentsIn = _ref.segments, goTo = _ref.goTo, renderer = _ref.renderer, loop = _ref.loop, rendererSettingsIn = _ref.rendererSettings, audioFactory = _ref.audioFactory, onLoad = _ref.onLoad, onComplete = _ref.onComplete, onLoopComplete = _ref.onLoopComplete, onEnterFrame = _ref.onEnterFrame, onSegmentStart = _ref.onSegmentStart, props = _objectWithoutPropertiesLoose(_ref, [
            "animationData",
            "path",
            "play",
            "speed",
            "direction",
            "segments",
            "goTo",
            "renderer",
            "loop",
            "rendererSettings",
            "audioFactory",
            "onLoad",
            "onComplete",
            "onLoopComplete",
            "onEnterFrame",
            "onSegmentStart"
        ]);
        var animElementRef = (0, _react.useRef)();
        var animRef = (0, _react.useRef)();
        var _useState = (0, _react.useState)(false), ready = _useState[0], setReady = _useState[1];
        var _useState2 = (0, _react.useState)(segmentsIn), segments = _useState2[0], setSegments = _useState2[1];
        (0, _react.useEffect)(function() {
            if (!(0, _reactDefault1.default)(segments, segmentsIn)) setSegments(segmentsIn);
        }, [
            segmentsIn,
            segments
        ]);
        var _useState3 = (0, _react.useState)(rendererSettingsIn), rendererSettings = _useState3[0], setRendererSettings = _useState3[1];
        (0, _react.useEffect)(function() {
            if (!(0, _reactDefault1.default)(rendererSettings, rendererSettingsIn)) setRendererSettings(rendererSettingsIn);
        }, [
            rendererSettingsIn,
            rendererSettings
        ]);
        (0, _react.useEffect)(function() {
            return function() {
                return animRef.current.removeEventListener("complete", onComplete);
            };
        }, [
            onComplete
        ]);
        (0, _react.useEffect)(function() {
            return function() {
                return animRef.current.removeEventListener("loopComplete", onLoopComplete);
            };
        }, [
            onLoopComplete
        ]);
        (0, _react.useEffect)(function() {
            return function() {
                return animRef.current.removeEventListener("enterFrame", onEnterFrame);
            };
        }, [
            onEnterFrame
        ]);
        (0, _react.useEffect)(function() {
            return function() {
                return animRef.current.removeEventListener("segmentStart", onSegmentStart);
            };
        }, [
            onSegmentStart
        ]);
        (0, _react.useEffect)(function() {
            function parseAnimationData() {
                if (animationData == null || typeof animationData !== "object") return animationData;
                if (typeof animationData["default"] === "object") return (0, _defaultDefault.default)(animationData["default"]);
                return (0, _defaultDefault.default)(animationData);
            }
            animRef.current = lottie.loadAnimation({
                animationData: parseAnimationData(),
                path: path,
                container: animElementRef.current,
                renderer: renderer,
                loop: false,
                autoplay: false,
                rendererSettings: rendererSettings,
                audioFactory: audioFactory
            });
            function onDomLoaded() {
                setReady(true);
                onLoad();
            }
            animRef.current.addEventListener("DOMLoaded", onDomLoaded);
            return function() {
                animRef.current.removeEventListener("DOMLoaded", onDomLoaded);
                setReady(false);
                animRef.current.destroy();
                animRef.current = undefined;
            };
        }, [
            loop,
            renderer,
            rendererSettings,
            animationData,
            path,
            audioFactory
        ]);
        (0, _react.useEffect)(function() {
            animRef.current.addEventListener("complete", onComplete);
        }, [
            onComplete
        ]);
        (0, _react.useEffect)(function() {
            animRef.current.addEventListener("loopComplete", onLoopComplete);
        }, [
            onLoopComplete
        ]);
        (0, _react.useEffect)(function() {
            animRef.current.addEventListener("enterFrame", onEnterFrame);
        }, [
            onEnterFrame
        ]);
        (0, _react.useEffect)(function() {
            animRef.current.addEventListener("segmentStart", onSegmentStart);
        }, [
            onSegmentStart
        ]);
        (0, _react.useEffect)(function() {
            if (!ready) return;
            animRef.current.loop = loop;
        }, [
            ready,
            loop
        ]);
        var wasPlayingSegmentsRef = (0, _react.useRef)(false);
        (0, _react.useEffect)(function() {
            if (!ready) return;
            function playReverse(lastFrame) {
                animRef.current.goToAndPlay(lastFrame, true);
                animRef.current.setDirection(direction);
            }
            if (play === true) {
                var force = true;
                if (segments) {
                    animRef.current.playSegments(segments, force);
                    wasPlayingSegmentsRef.current = true;
                    if (direction === -1) {
                        var lastFrame = segments[1];
                        playReverse(lastFrame);
                    }
                } else {
                    if (wasPlayingSegmentsRef.current) animRef.current.resetSegments(force);
                    wasPlayingSegmentsRef.current = false;
                    if (direction === -1) {
                        var _lastFrame = animRef.current.getDuration(true);
                        playReverse(_lastFrame);
                    } else animRef.current.play();
                }
            } else if (play === false) animRef.current.pause();
        }, [
            play,
            segments,
            ready
        ]);
        (0, _react.useEffect)(function() {
            if (!ready) return;
            if (Number.isNaN(speed)) return;
            animRef.current.setSpeed(speed);
        }, [
            speed,
            ready
        ]);
        (0, _react.useEffect)(function() {
            if (!ready) return;
            animRef.current.setDirection(direction);
        }, [
            direction,
            ready
        ]);
        (0, _react.useEffect)(function() {
            if (!ready) return;
            if (goTo == null) return;
            var isFrame = true;
            if (play) animRef.current.goToAndPlay(goTo, isFrame);
            else animRef.current.goToAndStop(goTo, isFrame);
        }, [
            goTo,
            play,
            ready
        ]);
        return /*#__PURE__*/ (0, _reactDefault.default).createElement("div", _extends({}, props, {
            ref: animElementRef
        }));
    });
    Lottie.propTypes = {
        animationData: propTypes.object,
        path: propTypes.string,
        play: propTypes.bool,
        goTo: propTypes.number,
        speed: propTypes.number,
        direction: propTypes.number,
        loop: propTypes.oneOfType([
            propTypes.number,
            propTypes.bool
        ]),
        segments: propTypes.oneOfType([
            propTypes.arrayOf(propTypes.number),
            propTypes.bool
        ]),
        rendererSettings: propTypes.object,
        renderer: propTypes.string,
        audioFactory: propTypes.func,
        onComplete: propTypes.func,
        onLoopComplete: propTypes.func,
        onEnterFrame: propTypes.func,
        onSegmentStart: propTypes.func
    };
    Lottie.defaultProps = {
        animationData: null,
        path: null,
        play: null,
        segments: null,
        goTo: null,
        speed: 1,
        direction: 1,
        loop: true,
        rendererSettings: {},
        renderer: "svg",
        audioFactory: null,
        onLoad: function onLoad() {},
        onComplete: function onComplete() {},
        onLoopComplete: function onLoopComplete() {},
        onEnterFrame: function onEnterFrame() {},
        onSegmentStart: function onSegmentStart() {}
    };
    return Lottie;
};
var LottiePlayer = makeLottiePlayer((0, _lottieWebDefault.default));
exports.default = LottiePlayer;

},{"lottie-web":"b4rLL","react":"2kGyk","fast-deep-equal/es6/react":"fCF2B","rfdc/default":"hJtbI","@parcel/transformer-js/src/esmodule-helpers.js":"hqSvo"}],"b4rLL":[function(require,module,exports) {
typeof navigator !== "undefined" && function(global, factory) {
    module.exports = factory();
}(this, function() {
    "use strict";
    var svgNS = "http://www.w3.org/2000/svg";
    var locationHref = "";
    var _useWebWorker = false;
    var initialDefaultFrame = -999999;
    var setWebWorker = function setWebWorker(flag) {
        _useWebWorker = !!flag;
    };
    var getWebWorker = function getWebWorker() {
        return _useWebWorker;
    };
    var setLocationHref = function setLocationHref(value) {
        locationHref = value;
    };
    var getLocationHref = function getLocationHref() {
        return locationHref;
    };
    function createTag(type) {
        // return {appendChild:function(){},setAttribute:function(){},style:{}}
        return document.createElement(type);
    }
    function extendPrototype(sources, destination) {
        var i;
        var len = sources.length;
        var sourcePrototype;
        for(i = 0; i < len; i += 1){
            sourcePrototype = sources[i].prototype;
            for(var attr in sourcePrototype)if (Object.prototype.hasOwnProperty.call(sourcePrototype, attr)) destination.prototype[attr] = sourcePrototype[attr];
        }
    }
    function getDescriptor(object, prop) {
        return Object.getOwnPropertyDescriptor(object, prop);
    }
    function createProxyFunction(prototype) {
        function ProxyFunction() {}
        ProxyFunction.prototype = prototype;
        return ProxyFunction;
    }
    // import Howl from '../../3rd_party/howler';
    var audioControllerFactory = function() {
        function AudioController(audioFactory) {
            this.audios = [];
            this.audioFactory = audioFactory;
            this._volume = 1;
            this._isMuted = false;
        }
        AudioController.prototype = {
            addAudio: function addAudio(audio) {
                this.audios.push(audio);
            },
            pause: function pause() {
                var i;
                var len = this.audios.length;
                for(i = 0; i < len; i += 1)this.audios[i].pause();
            },
            resume: function resume() {
                var i;
                var len = this.audios.length;
                for(i = 0; i < len; i += 1)this.audios[i].resume();
            },
            setRate: function setRate(rateValue) {
                var i;
                var len = this.audios.length;
                for(i = 0; i < len; i += 1)this.audios[i].setRate(rateValue);
            },
            createAudio: function createAudio(assetPath) {
                if (this.audioFactory) return this.audioFactory(assetPath);
                if (window.Howl) return new window.Howl({
                    src: [
                        assetPath
                    ]
                });
                return {
                    isPlaying: false,
                    play: function play() {
                        this.isPlaying = true;
                    },
                    seek: function seek() {
                        this.isPlaying = false;
                    },
                    playing: function playing() {},
                    rate: function rate() {},
                    setVolume: function setVolume() {}
                };
            },
            setAudioFactory: function setAudioFactory(audioFactory) {
                this.audioFactory = audioFactory;
            },
            setVolume: function setVolume(value) {
                this._volume = value;
                this._updateVolume();
            },
            mute: function mute() {
                this._isMuted = true;
                this._updateVolume();
            },
            unmute: function unmute() {
                this._isMuted = false;
                this._updateVolume();
            },
            getVolume: function getVolume() {
                return this._volume;
            },
            _updateVolume: function _updateVolume() {
                var i;
                var len = this.audios.length;
                for(i = 0; i < len; i += 1)this.audios[i].volume(this._volume * (this._isMuted ? 0 : 1));
            }
        };
        return function() {
            return new AudioController();
        };
    }();
    var createTypedArray = function() {
        function createRegularArray(type, len) {
            var i = 0;
            var arr = [];
            var value;
            switch(type){
                case "int16":
                case "uint8c":
                    value = 1;
                    break;
                default:
                    value = 1.1;
                    break;
            }
            for(i = 0; i < len; i += 1)arr.push(value);
            return arr;
        }
        function createTypedArrayFactory(type, len) {
            if (type === "float32") return new Float32Array(len);
            if (type === "int16") return new Int16Array(len);
            if (type === "uint8c") return new Uint8ClampedArray(len);
            return createRegularArray(type, len);
        }
        if (typeof Uint8ClampedArray === "function" && typeof Float32Array === "function") return createTypedArrayFactory;
        return createRegularArray;
    }();
    function createSizedArray(len) {
        return Array.apply(null, {
            length: len
        });
    }
    function _typeof$6(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof$6 = function _typeof(obj) {
            return typeof obj;
        };
        else _typeof$6 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
        return _typeof$6(obj);
    }
    var subframeEnabled = true;
    var expressionsPlugin = null;
    var idPrefix$1 = "";
    var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    var _shouldRoundValues = false;
    var bmPow = Math.pow;
    var bmSqrt = Math.sqrt;
    var bmFloor = Math.floor;
    var bmMax = Math.max;
    var bmMin = Math.min;
    var BMMath = {};
    (function() {
        var propertyNames = [
            "abs",
            "acos",
            "acosh",
            "asin",
            "asinh",
            "atan",
            "atanh",
            "atan2",
            "ceil",
            "cbrt",
            "expm1",
            "clz32",
            "cos",
            "cosh",
            "exp",
            "floor",
            "fround",
            "hypot",
            "imul",
            "log",
            "log1p",
            "log2",
            "log10",
            "max",
            "min",
            "pow",
            "random",
            "round",
            "sign",
            "sin",
            "sinh",
            "sqrt",
            "tan",
            "tanh",
            "trunc",
            "E",
            "LN10",
            "LN2",
            "LOG10E",
            "LOG2E",
            "PI",
            "SQRT1_2",
            "SQRT2"
        ];
        var i;
        var len = propertyNames.length;
        for(i = 0; i < len; i += 1)BMMath[propertyNames[i]] = Math[propertyNames[i]];
    })();
    function ProjectInterface$1() {
        return {};
    }
    BMMath.random = Math.random;
    BMMath.abs = function(val) {
        var tOfVal = _typeof$6(val);
        if (tOfVal === "object" && val.length) {
            var absArr = createSizedArray(val.length);
            var i;
            var len = val.length;
            for(i = 0; i < len; i += 1)absArr[i] = Math.abs(val[i]);
            return absArr;
        }
        return Math.abs(val);
    };
    var defaultCurveSegments = 150;
    var degToRads = Math.PI / 180;
    var roundCorner = 0.5519;
    function roundValues(flag) {
        _shouldRoundValues = !!flag;
    }
    function bmRnd(value) {
        if (_shouldRoundValues) return Math.round(value);
        return value;
    }
    function styleDiv(element) {
        element.style.position = "absolute";
        element.style.top = 0;
        element.style.left = 0;
        element.style.display = "block";
        element.style.transformOrigin = "0 0";
        element.style.webkitTransformOrigin = "0 0";
        element.style.backfaceVisibility = "visible";
        element.style.webkitBackfaceVisibility = "visible";
        element.style.transformStyle = "preserve-3d";
        element.style.webkitTransformStyle = "preserve-3d";
        element.style.mozTransformStyle = "preserve-3d";
    }
    function BMEnterFrameEvent(type, currentTime, totalTime, frameMultiplier) {
        this.type = type;
        this.currentTime = currentTime;
        this.totalTime = totalTime;
        this.direction = frameMultiplier < 0 ? -1 : 1;
    }
    function BMCompleteEvent(type, frameMultiplier) {
        this.type = type;
        this.direction = frameMultiplier < 0 ? -1 : 1;
    }
    function BMCompleteLoopEvent(type, totalLoops, currentLoop, frameMultiplier) {
        this.type = type;
        this.currentLoop = currentLoop;
        this.totalLoops = totalLoops;
        this.direction = frameMultiplier < 0 ? -1 : 1;
    }
    function BMSegmentStartEvent(type, firstFrame, totalFrames) {
        this.type = type;
        this.firstFrame = firstFrame;
        this.totalFrames = totalFrames;
    }
    function BMDestroyEvent(type, target) {
        this.type = type;
        this.target = target;
    }
    function BMRenderFrameErrorEvent(nativeError, currentTime) {
        this.type = "renderFrameError";
        this.nativeError = nativeError;
        this.currentTime = currentTime;
    }
    function BMConfigErrorEvent(nativeError) {
        this.type = "configError";
        this.nativeError = nativeError;
    }
    function BMAnimationConfigErrorEvent(type, nativeError) {
        this.type = type;
        this.nativeError = nativeError;
    }
    var createElementID = function() {
        var _count = 0;
        return function createID() {
            _count += 1;
            return idPrefix$1 + "__lottie_element_" + _count;
        };
    }();
    function HSVtoRGB(h, s, v) {
        var r;
        var g;
        var b;
        var i;
        var f;
        var p;
        var q;
        var t;
        i = Math.floor(h * 6);
        f = h * 6 - i;
        p = v * (1 - s);
        q = v * (1 - f * s);
        t = v * (1 - (1 - f) * s);
        switch(i % 6){
            case 0:
                r = v;
                g = t;
                b = p;
                break;
            case 1:
                r = q;
                g = v;
                b = p;
                break;
            case 2:
                r = p;
                g = v;
                b = t;
                break;
            case 3:
                r = p;
                g = q;
                b = v;
                break;
            case 4:
                r = t;
                g = p;
                b = v;
                break;
            case 5:
                r = v;
                g = p;
                b = q;
                break;
            default:
                break;
        }
        return [
            r,
            g,
            b
        ];
    }
    function RGBtoHSV(r, g, b) {
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var d = max - min;
        var h;
        var s = max === 0 ? 0 : d / max;
        var v = max / 255;
        switch(max){
            case min:
                h = 0;
                break;
            case r:
                h = g - b + d * (g < b ? 6 : 0);
                h /= 6 * d;
                break;
            case g:
                h = b - r + d * 2;
                h /= 6 * d;
                break;
            case b:
                h = r - g + d * 4;
                h /= 6 * d;
                break;
            default:
                break;
        }
        return [
            h,
            s,
            v
        ];
    }
    function addSaturationToRGB(color, offset) {
        var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
        hsv[1] += offset;
        if (hsv[1] > 1) hsv[1] = 1;
        else if (hsv[1] <= 0) hsv[1] = 0;
        return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
    }
    function addBrightnessToRGB(color, offset) {
        var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
        hsv[2] += offset;
        if (hsv[2] > 1) hsv[2] = 1;
        else if (hsv[2] < 0) hsv[2] = 0;
        return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
    }
    function addHueToRGB(color, offset) {
        var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
        hsv[0] += offset / 360;
        if (hsv[0] > 1) hsv[0] -= 1;
        else if (hsv[0] < 0) hsv[0] += 1;
        return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
    }
    var rgbToHex = function() {
        var colorMap = [];
        var i;
        var hex;
        for(i = 0; i < 256; i += 1){
            hex = i.toString(16);
            colorMap[i] = hex.length === 1 ? "0" + hex : hex;
        }
        return function(r, g, b) {
            if (r < 0) r = 0;
            if (g < 0) g = 0;
            if (b < 0) b = 0;
            return "#" + colorMap[r] + colorMap[g] + colorMap[b];
        };
    }();
    var setSubframeEnabled = function setSubframeEnabled(flag) {
        subframeEnabled = !!flag;
    };
    var getSubframeEnabled = function getSubframeEnabled() {
        return subframeEnabled;
    };
    var setExpressionsPlugin = function setExpressionsPlugin(value) {
        expressionsPlugin = value;
    };
    var getExpressionsPlugin = function getExpressionsPlugin() {
        return expressionsPlugin;
    };
    var setDefaultCurveSegments = function setDefaultCurveSegments(value) {
        defaultCurveSegments = value;
    };
    var getDefaultCurveSegments = function getDefaultCurveSegments() {
        return defaultCurveSegments;
    };
    var setIdPrefix = function setIdPrefix(value) {
        idPrefix$1 = value;
    };
    var getIdPrefix = function getIdPrefix() {
        return idPrefix$1;
    };
    function createNS(type) {
        // return {appendChild:function(){},setAttribute:function(){},style:{}}
        return document.createElementNS(svgNS, type);
    }
    function _typeof$5(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof$5 = function _typeof(obj) {
            return typeof obj;
        };
        else _typeof$5 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
        return _typeof$5(obj);
    }
    var dataManager = function() {
        var _counterId = 1;
        var processes = [];
        var workerFn;
        var workerInstance;
        var workerProxy = {
            onmessage: function onmessage() {},
            postMessage: function postMessage(path) {
                workerFn({
                    data: path
                });
            }
        };
        var _workerSelf = {
            postMessage: function postMessage(data) {
                workerProxy.onmessage({
                    data: data
                });
            }
        };
        function createWorker(fn) {
            if (window.Worker && window.Blob && getWebWorker()) {
                var blob = new Blob([
                    "var _workerSelf = self; self.onmessage = ",
                    fn.toString()
                ], {
                    type: "text/javascript"
                }); // var blob = new Blob(['self.onmessage = ', fn.toString()], { type: 'text/javascript' });
                var url = URL.createObjectURL(blob);
                return new Worker(url);
            }
            workerFn = fn;
            return workerProxy;
        }
        function setupWorker() {
            if (!workerInstance) {
                workerInstance = createWorker(function workerStart(e) {
                    function dataFunctionManager() {
                        function completeLayers(layers, comps) {
                            var layerData;
                            var i;
                            var len = layers.length;
                            var j;
                            var jLen;
                            var k;
                            var kLen;
                            for(i = 0; i < len; i += 1){
                                layerData = layers[i];
                                if ("ks" in layerData && !layerData.completed) {
                                    layerData.completed = true;
                                    if (layerData.tt) layers[i - 1].td = layerData.tt;
                                    if (layerData.hasMask) {
                                        var maskProps = layerData.masksProperties;
                                        jLen = maskProps.length;
                                        for(j = 0; j < jLen; j += 1)if (maskProps[j].pt.k.i) convertPathsToAbsoluteValues(maskProps[j].pt.k);
                                        else {
                                            kLen = maskProps[j].pt.k.length;
                                            for(k = 0; k < kLen; k += 1){
                                                if (maskProps[j].pt.k[k].s) convertPathsToAbsoluteValues(maskProps[j].pt.k[k].s[0]);
                                                if (maskProps[j].pt.k[k].e) convertPathsToAbsoluteValues(maskProps[j].pt.k[k].e[0]);
                                            }
                                        }
                                    }
                                    if (layerData.ty === 0) {
                                        layerData.layers = findCompLayers(layerData.refId, comps);
                                        completeLayers(layerData.layers, comps);
                                    } else if (layerData.ty === 4) completeShapes(layerData.shapes);
                                    else if (layerData.ty === 5) completeText(layerData);
                                }
                            }
                        }
                        function completeChars(chars, assets) {
                            if (chars) {
                                var i = 0;
                                var len = chars.length;
                                for(i = 0; i < len; i += 1)if (chars[i].t === 1) {
                                    // var compData = findComp(chars[i].data.refId, assets);
                                    chars[i].data.layers = findCompLayers(chars[i].data.refId, assets); // chars[i].data.ip = 0;
                                    // chars[i].data.op = 99999;
                                    // chars[i].data.st = 0;
                                    // chars[i].data.sr = 1;
                                    // chars[i].w = compData.w;
                                    // chars[i].data.ks = {
                                    //   a: { k: [0, 0, 0], a: 0 },
                                    //   p: { k: [0, -compData.h, 0], a: 0 },
                                    //   r: { k: 0, a: 0 },
                                    //   s: { k: [100, 100], a: 0 },
                                    //   o: { k: 100, a: 0 },
                                    // };
                                    completeLayers(chars[i].data.layers, assets);
                                }
                            }
                        }
                        function findComp(id, comps) {
                            var i = 0;
                            var len = comps.length;
                            while(i < len){
                                if (comps[i].id === id) return comps[i];
                                i += 1;
                            }
                            return null;
                        }
                        function findCompLayers(id, comps) {
                            var comp = findComp(id, comps);
                            if (comp) {
                                if (!comp.layers.__used) {
                                    comp.layers.__used = true;
                                    return comp.layers;
                                }
                                return JSON.parse(JSON.stringify(comp.layers));
                            }
                            return null;
                        }
                        function completeShapes(arr) {
                            var i;
                            var len = arr.length;
                            var j;
                            var jLen;
                            for(i = len - 1; i >= 0; i -= 1){
                                if (arr[i].ty === "sh") {
                                    if (arr[i].ks.k.i) convertPathsToAbsoluteValues(arr[i].ks.k);
                                    else {
                                        jLen = arr[i].ks.k.length;
                                        for(j = 0; j < jLen; j += 1){
                                            if (arr[i].ks.k[j].s) convertPathsToAbsoluteValues(arr[i].ks.k[j].s[0]);
                                            if (arr[i].ks.k[j].e) convertPathsToAbsoluteValues(arr[i].ks.k[j].e[0]);
                                        }
                                    }
                                } else if (arr[i].ty === "gr") completeShapes(arr[i].it);
                            }
                        }
                        function convertPathsToAbsoluteValues(path) {
                            var i;
                            var len = path.i.length;
                            for(i = 0; i < len; i += 1){
                                path.i[i][0] += path.v[i][0];
                                path.i[i][1] += path.v[i][1];
                                path.o[i][0] += path.v[i][0];
                                path.o[i][1] += path.v[i][1];
                            }
                        }
                        function checkVersion(minimum, animVersionString) {
                            var animVersion = animVersionString ? animVersionString.split(".") : [
                                100,
                                100,
                                100
                            ];
                            if (minimum[0] > animVersion[0]) return true;
                            if (animVersion[0] > minimum[0]) return false;
                            if (minimum[1] > animVersion[1]) return true;
                            if (animVersion[1] > minimum[1]) return false;
                            if (minimum[2] > animVersion[2]) return true;
                            if (animVersion[2] > minimum[2]) return false;
                            return null;
                        }
                        var checkText = function() {
                            var minimumVersion = [
                                4,
                                4,
                                14
                            ];
                            function updateTextLayer(textLayer) {
                                var documentData = textLayer.t.d;
                                textLayer.t.d = {
                                    k: [
                                        {
                                            s: documentData,
                                            t: 0
                                        }
                                    ]
                                };
                            }
                            function iterateLayers(layers) {
                                var i;
                                var len = layers.length;
                                for(i = 0; i < len; i += 1)if (layers[i].ty === 5) updateTextLayer(layers[i]);
                            }
                            return function(animationData) {
                                if (checkVersion(minimumVersion, animationData.v)) {
                                    iterateLayers(animationData.layers);
                                    if (animationData.assets) {
                                        var i;
                                        var len = animationData.assets.length;
                                        for(i = 0; i < len; i += 1)if (animationData.assets[i].layers) iterateLayers(animationData.assets[i].layers);
                                    }
                                }
                            };
                        }();
                        var checkChars = function() {
                            var minimumVersion = [
                                4,
                                7,
                                99
                            ];
                            return function(animationData) {
                                if (animationData.chars && !checkVersion(minimumVersion, animationData.v)) {
                                    var i;
                                    var len = animationData.chars.length;
                                    for(i = 0; i < len; i += 1){
                                        var charData = animationData.chars[i];
                                        if (charData.data && charData.data.shapes) {
                                            completeShapes(charData.data.shapes);
                                            charData.data.ip = 0;
                                            charData.data.op = 99999;
                                            charData.data.st = 0;
                                            charData.data.sr = 1;
                                            charData.data.ks = {
                                                p: {
                                                    k: [
                                                        0,
                                                        0
                                                    ],
                                                    a: 0
                                                },
                                                s: {
                                                    k: [
                                                        100,
                                                        100
                                                    ],
                                                    a: 0
                                                },
                                                a: {
                                                    k: [
                                                        0,
                                                        0
                                                    ],
                                                    a: 0
                                                },
                                                r: {
                                                    k: 0,
                                                    a: 0
                                                },
                                                o: {
                                                    k: 100,
                                                    a: 0
                                                }
                                            };
                                            if (!animationData.chars[i].t) {
                                                charData.data.shapes.push({
                                                    ty: "no"
                                                });
                                                charData.data.shapes[0].it.push({
                                                    p: {
                                                        k: [
                                                            0,
                                                            0
                                                        ],
                                                        a: 0
                                                    },
                                                    s: {
                                                        k: [
                                                            100,
                                                            100
                                                        ],
                                                        a: 0
                                                    },
                                                    a: {
                                                        k: [
                                                            0,
                                                            0
                                                        ],
                                                        a: 0
                                                    },
                                                    r: {
                                                        k: 0,
                                                        a: 0
                                                    },
                                                    o: {
                                                        k: 100,
                                                        a: 0
                                                    },
                                                    sk: {
                                                        k: 0,
                                                        a: 0
                                                    },
                                                    sa: {
                                                        k: 0,
                                                        a: 0
                                                    },
                                                    ty: "tr"
                                                });
                                            }
                                        }
                                    }
                                }
                            };
                        }();
                        var checkPathProperties = function() {
                            var minimumVersion = [
                                5,
                                7,
                                15
                            ];
                            function updateTextLayer(textLayer) {
                                var pathData = textLayer.t.p;
                                if (typeof pathData.a === "number") pathData.a = {
                                    a: 0,
                                    k: pathData.a
                                };
                                if (typeof pathData.p === "number") pathData.p = {
                                    a: 0,
                                    k: pathData.p
                                };
                                if (typeof pathData.r === "number") pathData.r = {
                                    a: 0,
                                    k: pathData.r
                                };
                            }
                            function iterateLayers(layers) {
                                var i;
                                var len = layers.length;
                                for(i = 0; i < len; i += 1)if (layers[i].ty === 5) updateTextLayer(layers[i]);
                            }
                            return function(animationData) {
                                if (checkVersion(minimumVersion, animationData.v)) {
                                    iterateLayers(animationData.layers);
                                    if (animationData.assets) {
                                        var i;
                                        var len = animationData.assets.length;
                                        for(i = 0; i < len; i += 1)if (animationData.assets[i].layers) iterateLayers(animationData.assets[i].layers);
                                    }
                                }
                            };
                        }();
                        var checkColors = function() {
                            var minimumVersion = [
                                4,
                                1,
                                9
                            ];
                            function iterateShapes(shapes) {
                                var i;
                                var len = shapes.length;
                                var j;
                                var jLen;
                                for(i = 0; i < len; i += 1){
                                    if (shapes[i].ty === "gr") iterateShapes(shapes[i].it);
                                    else if (shapes[i].ty === "fl" || shapes[i].ty === "st") {
                                        if (shapes[i].c.k && shapes[i].c.k[0].i) {
                                            jLen = shapes[i].c.k.length;
                                            for(j = 0; j < jLen; j += 1){
                                                if (shapes[i].c.k[j].s) {
                                                    shapes[i].c.k[j].s[0] /= 255;
                                                    shapes[i].c.k[j].s[1] /= 255;
                                                    shapes[i].c.k[j].s[2] /= 255;
                                                    shapes[i].c.k[j].s[3] /= 255;
                                                }
                                                if (shapes[i].c.k[j].e) {
                                                    shapes[i].c.k[j].e[0] /= 255;
                                                    shapes[i].c.k[j].e[1] /= 255;
                                                    shapes[i].c.k[j].e[2] /= 255;
                                                    shapes[i].c.k[j].e[3] /= 255;
                                                }
                                            }
                                        } else {
                                            shapes[i].c.k[0] /= 255;
                                            shapes[i].c.k[1] /= 255;
                                            shapes[i].c.k[2] /= 255;
                                            shapes[i].c.k[3] /= 255;
                                        }
                                    }
                                }
                            }
                            function iterateLayers(layers) {
                                var i;
                                var len = layers.length;
                                for(i = 0; i < len; i += 1)if (layers[i].ty === 4) iterateShapes(layers[i].shapes);
                            }
                            return function(animationData) {
                                if (checkVersion(minimumVersion, animationData.v)) {
                                    iterateLayers(animationData.layers);
                                    if (animationData.assets) {
                                        var i;
                                        var len = animationData.assets.length;
                                        for(i = 0; i < len; i += 1)if (animationData.assets[i].layers) iterateLayers(animationData.assets[i].layers);
                                    }
                                }
                            };
                        }();
                        var checkShapes = function() {
                            var minimumVersion = [
                                4,
                                4,
                                18
                            ];
                            function completeClosingShapes(arr) {
                                var i;
                                var len = arr.length;
                                var j;
                                var jLen;
                                for(i = len - 1; i >= 0; i -= 1){
                                    if (arr[i].ty === "sh") {
                                        if (arr[i].ks.k.i) arr[i].ks.k.c = arr[i].closed;
                                        else {
                                            jLen = arr[i].ks.k.length;
                                            for(j = 0; j < jLen; j += 1){
                                                if (arr[i].ks.k[j].s) arr[i].ks.k[j].s[0].c = arr[i].closed;
                                                if (arr[i].ks.k[j].e) arr[i].ks.k[j].e[0].c = arr[i].closed;
                                            }
                                        }
                                    } else if (arr[i].ty === "gr") completeClosingShapes(arr[i].it);
                                }
                            }
                            function iterateLayers(layers) {
                                var layerData;
                                var i;
                                var len = layers.length;
                                var j;
                                var jLen;
                                var k;
                                var kLen;
                                for(i = 0; i < len; i += 1){
                                    layerData = layers[i];
                                    if (layerData.hasMask) {
                                        var maskProps = layerData.masksProperties;
                                        jLen = maskProps.length;
                                        for(j = 0; j < jLen; j += 1)if (maskProps[j].pt.k.i) maskProps[j].pt.k.c = maskProps[j].cl;
                                        else {
                                            kLen = maskProps[j].pt.k.length;
                                            for(k = 0; k < kLen; k += 1){
                                                if (maskProps[j].pt.k[k].s) maskProps[j].pt.k[k].s[0].c = maskProps[j].cl;
                                                if (maskProps[j].pt.k[k].e) maskProps[j].pt.k[k].e[0].c = maskProps[j].cl;
                                            }
                                        }
                                    }
                                    if (layerData.ty === 4) completeClosingShapes(layerData.shapes);
                                }
                            }
                            return function(animationData) {
                                if (checkVersion(minimumVersion, animationData.v)) {
                                    iterateLayers(animationData.layers);
                                    if (animationData.assets) {
                                        var i;
                                        var len = animationData.assets.length;
                                        for(i = 0; i < len; i += 1)if (animationData.assets[i].layers) iterateLayers(animationData.assets[i].layers);
                                    }
                                }
                            };
                        }();
                        function completeData(animationData) {
                            if (animationData.__complete) return;
                            checkColors(animationData);
                            checkText(animationData);
                            checkChars(animationData);
                            checkPathProperties(animationData);
                            checkShapes(animationData);
                            completeLayers(animationData.layers, animationData.assets);
                            completeChars(animationData.chars, animationData.assets);
                            animationData.__complete = true;
                        }
                        function completeText(data) {
                            data.t.a.length === 0 && data.t.p;
                        }
                        var moduleOb = {};
                        moduleOb.completeData = completeData;
                        moduleOb.checkColors = checkColors;
                        moduleOb.checkChars = checkChars;
                        moduleOb.checkPathProperties = checkPathProperties;
                        moduleOb.checkShapes = checkShapes;
                        moduleOb.completeLayers = completeLayers;
                        return moduleOb;
                    }
                    if (!_workerSelf.dataManager) _workerSelf.dataManager = dataFunctionManager();
                    if (!_workerSelf.assetLoader) _workerSelf.assetLoader = function() {
                        function formatResponse(xhr) {
                            // using typeof doubles the time of execution of this method,
                            // so if available, it's better to use the header to validate the type
                            var contentTypeHeader = xhr.getResponseHeader("content-type");
                            if (contentTypeHeader && xhr.responseType === "json" && contentTypeHeader.indexOf("json") !== -1) return xhr.response;
                            if (xhr.response && _typeof$5(xhr.response) === "object") return xhr.response;
                            if (xhr.response && typeof xhr.response === "string") return JSON.parse(xhr.response);
                            if (xhr.responseText) return JSON.parse(xhr.responseText);
                            return null;
                        }
                        function loadAsset(path, fullPath, callback, errorCallback) {
                            var response;
                            var xhr = new XMLHttpRequest(); // set responseType after calling open or IE will break.
                            try {
                                // This crashes on Android WebView prior to KitKat
                                xhr.responseType = "json";
                            } catch (err) {} // eslint-disable-line no-empty
                            xhr.onreadystatechange = function() {
                                if (xhr.readyState === 4) {
                                    if (xhr.status === 200) {
                                        response = formatResponse(xhr);
                                        callback(response);
                                    } else try {
                                        response = formatResponse(xhr);
                                        callback(response);
                                    } catch (err) {
                                        if (errorCallback) errorCallback(err);
                                    }
                                }
                            };
                            try {
                                xhr.open("GET", path, true);
                            } catch (error) {
                                xhr.open("GET", fullPath + "/" + path, true);
                            }
                            xhr.send();
                        }
                        return {
                            load: loadAsset
                        };
                    }();
                    if (e.data.type === "loadAnimation") _workerSelf.assetLoader.load(e.data.path, e.data.fullPath, function(data) {
                        _workerSelf.dataManager.completeData(data);
                        _workerSelf.postMessage({
                            id: e.data.id,
                            payload: data,
                            status: "success"
                        });
                    }, function() {
                        _workerSelf.postMessage({
                            id: e.data.id,
                            status: "error"
                        });
                    });
                    else if (e.data.type === "complete") {
                        var animation = e.data.animation;
                        _workerSelf.dataManager.completeData(animation);
                        _workerSelf.postMessage({
                            id: e.data.id,
                            payload: animation,
                            status: "success"
                        });
                    } else if (e.data.type === "loadData") _workerSelf.assetLoader.load(e.data.path, e.data.fullPath, function(data) {
                        _workerSelf.postMessage({
                            id: e.data.id,
                            payload: data,
                            status: "success"
                        });
                    }, function() {
                        _workerSelf.postMessage({
                            id: e.data.id,
                            status: "error"
                        });
                    });
                });
                workerInstance.onmessage = function(event) {
                    var data = event.data;
                    var id = data.id;
                    var process = processes[id];
                    processes[id] = null;
                    if (data.status === "success") process.onComplete(data.payload);
                    else if (process.onError) process.onError();
                };
            }
        }
        function createProcess(onComplete, onError) {
            _counterId += 1;
            var id = "processId_" + _counterId;
            processes[id] = {
                onComplete: onComplete,
                onError: onError
            };
            return id;
        }
        function loadAnimation(path, onComplete, onError) {
            setupWorker();
            var processId = createProcess(onComplete, onError);
            workerInstance.postMessage({
                type: "loadAnimation",
                path: path,
                fullPath: window.location.origin + window.location.pathname,
                id: processId
            });
        }
        function loadData(path, onComplete, onError) {
            setupWorker();
            var processId = createProcess(onComplete, onError);
            workerInstance.postMessage({
                type: "loadData",
                path: path,
                fullPath: window.location.origin + window.location.pathname,
                id: processId
            });
        }
        function completeAnimation(anim, onComplete, onError) {
            setupWorker();
            var processId = createProcess(onComplete, onError);
            workerInstance.postMessage({
                type: "complete",
                animation: anim,
                id: processId
            });
        }
        return {
            loadAnimation: loadAnimation,
            loadData: loadData,
            completeAnimation: completeAnimation
        };
    }();
    var ImagePreloader = function() {
        var proxyImage = function() {
            var canvas = createTag("canvas");
            canvas.width = 1;
            canvas.height = 1;
            var ctx = canvas.getContext("2d");
            ctx.fillStyle = "rgba(0,0,0,0)";
            ctx.fillRect(0, 0, 1, 1);
            return canvas;
        }();
        function imageLoaded() {
            this.loadedAssets += 1;
            if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
                if (this.imagesLoadedCb) this.imagesLoadedCb(null);
            }
        }
        function footageLoaded() {
            this.loadedFootagesCount += 1;
            if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
                if (this.imagesLoadedCb) this.imagesLoadedCb(null);
            }
        }
        function getAssetsPath(assetData, assetsPath, originalPath) {
            var path = "";
            if (assetData.e) path = assetData.p;
            else if (assetsPath) {
                var imagePath = assetData.p;
                if (imagePath.indexOf("images/") !== -1) imagePath = imagePath.split("/")[1];
                path = assetsPath + imagePath;
            } else {
                path = originalPath;
                path += assetData.u ? assetData.u : "";
                path += assetData.p;
            }
            return path;
        }
        function testImageLoaded(img) {
            var _count = 0;
            var intervalId = setInterval((function() {
                var box = img.getBBox();
                if (box.width || _count > 500) {
                    this._imageLoaded();
                    clearInterval(intervalId);
                }
                _count += 1;
            }).bind(this), 50);
        }
        function createImageData(assetData) {
            var path = getAssetsPath(assetData, this.assetsPath, this.path);
            var img = createNS("image");
            if (isSafari) this.testImageLoaded(img);
            else img.addEventListener("load", this._imageLoaded, false);
            img.addEventListener("error", (function() {
                ob.img = proxyImage;
                this._imageLoaded();
            }).bind(this), false);
            img.setAttributeNS("http://www.w3.org/1999/xlink", "href", path);
            if (this._elementHelper.append) this._elementHelper.append(img);
            else this._elementHelper.appendChild(img);
            var ob = {
                img: img,
                assetData: assetData
            };
            return ob;
        }
        function createImgData(assetData) {
            var path = getAssetsPath(assetData, this.assetsPath, this.path);
            var img = createTag("img");
            img.crossOrigin = "anonymous";
            img.addEventListener("load", this._imageLoaded, false);
            img.addEventListener("error", (function() {
                ob.img = proxyImage;
                this._imageLoaded();
            }).bind(this), false);
            img.src = path;
            var ob = {
                img: img,
                assetData: assetData
            };
            return ob;
        }
        function createFootageData(data) {
            var ob = {
                assetData: data
            };
            var path = getAssetsPath(data, this.assetsPath, this.path);
            dataManager.loadData(path, (function(footageData) {
                ob.img = footageData;
                this._footageLoaded();
            }).bind(this), (function() {
                ob.img = {};
                this._footageLoaded();
            }).bind(this));
            return ob;
        }
        function loadAssets(assets, cb) {
            this.imagesLoadedCb = cb;
            var i;
            var len = assets.length;
            for(i = 0; i < len; i += 1)if (!assets[i].layers) {
                if (!assets[i].t || assets[i].t === "seq") {
                    this.totalImages += 1;
                    this.images.push(this._createImageData(assets[i]));
                } else if (assets[i].t === 3) {
                    this.totalFootages += 1;
                    this.images.push(this.createFootageData(assets[i]));
                }
            }
        }
        function setPath(path) {
            this.path = path || "";
        }
        function setAssetsPath(path) {
            this.assetsPath = path || "";
        }
        function getAsset(assetData) {
            var i = 0;
            var len = this.images.length;
            while(i < len){
                if (this.images[i].assetData === assetData) return this.images[i].img;
                i += 1;
            }
            return null;
        }
        function destroy() {
            this.imagesLoadedCb = null;
            this.images.length = 0;
        }
        function loadedImages() {
            return this.totalImages === this.loadedAssets;
        }
        function loadedFootages() {
            return this.totalFootages === this.loadedFootagesCount;
        }
        function setCacheType(type, elementHelper) {
            if (type === "svg") {
                this._elementHelper = elementHelper;
                this._createImageData = this.createImageData.bind(this);
            } else this._createImageData = this.createImgData.bind(this);
        }
        function ImagePreloaderFactory() {
            this._imageLoaded = imageLoaded.bind(this);
            this._footageLoaded = footageLoaded.bind(this);
            this.testImageLoaded = testImageLoaded.bind(this);
            this.createFootageData = createFootageData.bind(this);
            this.assetsPath = "";
            this.path = "";
            this.totalImages = 0;
            this.totalFootages = 0;
            this.loadedAssets = 0;
            this.loadedFootagesCount = 0;
            this.imagesLoadedCb = null;
            this.images = [];
        }
        ImagePreloaderFactory.prototype = {
            loadAssets: loadAssets,
            setAssetsPath: setAssetsPath,
            setPath: setPath,
            loadedImages: loadedImages,
            loadedFootages: loadedFootages,
            destroy: destroy,
            getAsset: getAsset,
            createImgData: createImgData,
            createImageData: createImageData,
            imageLoaded: imageLoaded,
            footageLoaded: footageLoaded,
            setCacheType: setCacheType
        };
        return ImagePreloaderFactory;
    }();
    function BaseEvent() {}
    BaseEvent.prototype = {
        triggerEvent: function triggerEvent(eventName, args) {
            if (this._cbs[eventName]) {
                var callbacks = this._cbs[eventName];
                for(var i = 0; i < callbacks.length; i += 1)callbacks[i](args);
            }
        },
        addEventListener: function addEventListener(eventName, callback) {
            if (!this._cbs[eventName]) this._cbs[eventName] = [];
            this._cbs[eventName].push(callback);
            return (function() {
                this.removeEventListener(eventName, callback);
            }).bind(this);
        },
        removeEventListener: function removeEventListener(eventName, callback) {
            if (!callback) this._cbs[eventName] = null;
            else if (this._cbs[eventName]) {
                var i = 0;
                var len = this._cbs[eventName].length;
                while(i < len){
                    if (this._cbs[eventName][i] === callback) {
                        this._cbs[eventName].splice(i, 1);
                        i -= 1;
                        len -= 1;
                    }
                    i += 1;
                }
                if (!this._cbs[eventName].length) this._cbs[eventName] = null;
            }
        }
    };
    var markerParser = function() {
        function parsePayloadLines(payload) {
            var lines = payload.split("\r\n");
            var keys = {};
            var line;
            var keysCount = 0;
            for(var i = 0; i < lines.length; i += 1){
                line = lines[i].split(":");
                if (line.length === 2) {
                    keys[line[0]] = line[1].trim();
                    keysCount += 1;
                }
            }
            if (keysCount === 0) throw new Error();
            return keys;
        }
        return function(_markers) {
            var markers = [];
            for(var i = 0; i < _markers.length; i += 1){
                var _marker = _markers[i];
                var markerData = {
                    time: _marker.tm,
                    duration: _marker.dr
                };
                try {
                    markerData.payload = JSON.parse(_markers[i].cm);
                } catch (_) {
                    try {
                        markerData.payload = parsePayloadLines(_markers[i].cm);
                    } catch (__) {
                        markerData.payload = {
                            name: _markers[i].cm
                        };
                    }
                }
                markers.push(markerData);
            }
            return markers;
        };
    }();
    var ProjectInterface = function() {
        function registerComposition(comp) {
            this.compositions.push(comp);
        }
        return function() {
            function _thisProjectFunction(name) {
                var i = 0;
                var len = this.compositions.length;
                while(i < len){
                    if (this.compositions[i].data && this.compositions[i].data.nm === name) {
                        if (this.compositions[i].prepareFrame && this.compositions[i].data.xt) this.compositions[i].prepareFrame(this.currentFrame);
                        return this.compositions[i].compInterface;
                    }
                    i += 1;
                }
                return null;
            }
            _thisProjectFunction.compositions = [];
            _thisProjectFunction.currentFrame = 0;
            _thisProjectFunction.registerComposition = registerComposition;
            return _thisProjectFunction;
        };
    }();
    var renderers = {};
    var registerRenderer = function registerRenderer(key, value) {
        renderers[key] = value;
    };
    function getRenderer(key) {
        return renderers[key];
    }
    function _typeof$4(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof$4 = function _typeof(obj) {
            return typeof obj;
        };
        else _typeof$4 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
        return _typeof$4(obj);
    }
    var AnimationItem = function AnimationItem() {
        this._cbs = [];
        this.name = "";
        this.path = "";
        this.isLoaded = false;
        this.currentFrame = 0;
        this.currentRawFrame = 0;
        this.firstFrame = 0;
        this.totalFrames = 0;
        this.frameRate = 0;
        this.frameMult = 0;
        this.playSpeed = 1;
        this.playDirection = 1;
        this.playCount = 0;
        this.animationData = {};
        this.assets = [];
        this.isPaused = true;
        this.autoplay = false;
        this.loop = true;
        this.renderer = null;
        this.animationID = createElementID();
        this.assetsPath = "";
        this.timeCompleted = 0;
        this.segmentPos = 0;
        this.isSubframeEnabled = getSubframeEnabled();
        this.segments = [];
        this._idle = true;
        this._completedLoop = false;
        this.projectInterface = ProjectInterface();
        this.imagePreloader = new ImagePreloader();
        this.audioController = audioControllerFactory();
        this.markers = [];
        this.configAnimation = this.configAnimation.bind(this);
        this.onSetupError = this.onSetupError.bind(this);
        this.onSegmentComplete = this.onSegmentComplete.bind(this);
        this.drawnFrameEvent = new BMEnterFrameEvent("drawnFrame", 0, 0, 0);
    };
    extendPrototype([
        BaseEvent
    ], AnimationItem);
    AnimationItem.prototype.setParams = function(params) {
        if (params.wrapper || params.container) this.wrapper = params.wrapper || params.container;
        var animType = "svg";
        if (params.animType) animType = params.animType;
        else if (params.renderer) animType = params.renderer;
        var RendererClass = getRenderer(animType);
        this.renderer = new RendererClass(this, params.rendererSettings);
        this.imagePreloader.setCacheType(animType, this.renderer.globalData.defs);
        this.renderer.setProjectInterface(this.projectInterface);
        this.animType = animType;
        if (params.loop === "" || params.loop === null || params.loop === undefined || params.loop === true) this.loop = true;
        else if (params.loop === false) this.loop = false;
        else this.loop = parseInt(params.loop, 10);
        this.autoplay = "autoplay" in params ? params.autoplay : true;
        this.name = params.name ? params.name : "";
        this.autoloadSegments = Object.prototype.hasOwnProperty.call(params, "autoloadSegments") ? params.autoloadSegments : true;
        this.assetsPath = params.assetsPath;
        this.initialSegment = params.initialSegment;
        if (params.audioFactory) this.audioController.setAudioFactory(params.audioFactory);
        if (params.animationData) this.setupAnimation(params.animationData);
        else if (params.path) {
            if (params.path.lastIndexOf("\\") !== -1) this.path = params.path.substr(0, params.path.lastIndexOf("\\") + 1);
            else this.path = params.path.substr(0, params.path.lastIndexOf("/") + 1);
            this.fileName = params.path.substr(params.path.lastIndexOf("/") + 1);
            this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf(".json"));
            dataManager.loadAnimation(params.path, this.configAnimation, this.onSetupError);
        }
    };
    AnimationItem.prototype.onSetupError = function() {
        this.trigger("data_failed");
    };
    AnimationItem.prototype.setupAnimation = function(data) {
        dataManager.completeAnimation(data, this.configAnimation);
    };
    AnimationItem.prototype.setData = function(wrapper, animationData) {
        if (animationData) {
            if (_typeof$4(animationData) !== "object") animationData = JSON.parse(animationData);
        }
        var params = {
            wrapper: wrapper,
            animationData: animationData
        };
        var wrapperAttributes = wrapper.attributes;
        params.path = wrapperAttributes.getNamedItem("data-animation-path") // eslint-disable-line no-nested-ternary
         ? wrapperAttributes.getNamedItem("data-animation-path").value : wrapperAttributes.getNamedItem("data-bm-path") // eslint-disable-line no-nested-ternary
         ? wrapperAttributes.getNamedItem("data-bm-path").value : wrapperAttributes.getNamedItem("bm-path") ? wrapperAttributes.getNamedItem("bm-path").value : "";
        params.animType = wrapperAttributes.getNamedItem("data-anim-type") // eslint-disable-line no-nested-ternary
         ? wrapperAttributes.getNamedItem("data-anim-type").value : wrapperAttributes.getNamedItem("data-bm-type") // eslint-disable-line no-nested-ternary
         ? wrapperAttributes.getNamedItem("data-bm-type").value : wrapperAttributes.getNamedItem("bm-type") // eslint-disable-line no-nested-ternary
         ? wrapperAttributes.getNamedItem("bm-type").value : wrapperAttributes.getNamedItem("data-bm-renderer") // eslint-disable-line no-nested-ternary
         ? wrapperAttributes.getNamedItem("data-bm-renderer").value : wrapperAttributes.getNamedItem("bm-renderer") ? wrapperAttributes.getNamedItem("bm-renderer").value : "canvas";
        var loop = wrapperAttributes.getNamedItem("data-anim-loop") // eslint-disable-line no-nested-ternary
         ? wrapperAttributes.getNamedItem("data-anim-loop").value : wrapperAttributes.getNamedItem("data-bm-loop") // eslint-disable-line no-nested-ternary
         ? wrapperAttributes.getNamedItem("data-bm-loop").value : wrapperAttributes.getNamedItem("bm-loop") ? wrapperAttributes.getNamedItem("bm-loop").value : "";
        if (loop === "false") params.loop = false;
        else if (loop === "true") params.loop = true;
        else if (loop !== "") params.loop = parseInt(loop, 10);
        var autoplay = wrapperAttributes.getNamedItem("data-anim-autoplay") // eslint-disable-line no-nested-ternary
         ? wrapperAttributes.getNamedItem("data-anim-autoplay").value : wrapperAttributes.getNamedItem("data-bm-autoplay") // eslint-disable-line no-nested-ternary
         ? wrapperAttributes.getNamedItem("data-bm-autoplay").value : wrapperAttributes.getNamedItem("bm-autoplay") ? wrapperAttributes.getNamedItem("bm-autoplay").value : true;
        params.autoplay = autoplay !== "false";
        params.name = wrapperAttributes.getNamedItem("data-name") // eslint-disable-line no-nested-ternary
         ? wrapperAttributes.getNamedItem("data-name").value : wrapperAttributes.getNamedItem("data-bm-name") // eslint-disable-line no-nested-ternary
         ? wrapperAttributes.getNamedItem("data-bm-name").value : wrapperAttributes.getNamedItem("bm-name") ? wrapperAttributes.getNamedItem("bm-name").value : "";
        var prerender = wrapperAttributes.getNamedItem("data-anim-prerender") // eslint-disable-line no-nested-ternary
         ? wrapperAttributes.getNamedItem("data-anim-prerender").value : wrapperAttributes.getNamedItem("data-bm-prerender") // eslint-disable-line no-nested-ternary
         ? wrapperAttributes.getNamedItem("data-bm-prerender").value : wrapperAttributes.getNamedItem("bm-prerender") ? wrapperAttributes.getNamedItem("bm-prerender").value : "";
        if (prerender === "false") params.prerender = false;
        this.setParams(params);
    };
    AnimationItem.prototype.includeLayers = function(data) {
        if (data.op > this.animationData.op) {
            this.animationData.op = data.op;
            this.totalFrames = Math.floor(data.op - this.animationData.ip);
        }
        var layers = this.animationData.layers;
        var i;
        var len = layers.length;
        var newLayers = data.layers;
        var j;
        var jLen = newLayers.length;
        for(j = 0; j < jLen; j += 1){
            i = 0;
            while(i < len){
                if (layers[i].id === newLayers[j].id) {
                    layers[i] = newLayers[j];
                    break;
                }
                i += 1;
            }
        }
        if (data.chars || data.fonts) {
            this.renderer.globalData.fontManager.addChars(data.chars);
            this.renderer.globalData.fontManager.addFonts(data.fonts, this.renderer.globalData.defs);
        }
        if (data.assets) {
            len = data.assets.length;
            for(i = 0; i < len; i += 1)this.animationData.assets.push(data.assets[i]);
        }
        this.animationData.__complete = false;
        dataManager.completeAnimation(this.animationData, this.onSegmentComplete);
    };
    AnimationItem.prototype.onSegmentComplete = function(data) {
        this.animationData = data;
        var expressionsPlugin = getExpressionsPlugin();
        if (expressionsPlugin) expressionsPlugin.initExpressions(this);
        this.loadNextSegment();
    };
    AnimationItem.prototype.loadNextSegment = function() {
        var segments = this.animationData.segments;
        if (!segments || segments.length === 0 || !this.autoloadSegments) {
            this.trigger("data_ready");
            this.timeCompleted = this.totalFrames;
            return;
        }
        var segment = segments.shift();
        this.timeCompleted = segment.time * this.frameRate;
        var segmentPath = this.path + this.fileName + "_" + this.segmentPos + ".json";
        this.segmentPos += 1;
        dataManager.loadData(segmentPath, this.includeLayers.bind(this), (function() {
            this.trigger("data_failed");
        }).bind(this));
    };
    AnimationItem.prototype.loadSegments = function() {
        var segments = this.animationData.segments;
        if (!segments) this.timeCompleted = this.totalFrames;
        this.loadNextSegment();
    };
    AnimationItem.prototype.imagesLoaded = function() {
        this.trigger("loaded_images");
        this.checkLoaded();
    };
    AnimationItem.prototype.preloadImages = function() {
        this.imagePreloader.setAssetsPath(this.assetsPath);
        this.imagePreloader.setPath(this.path);
        this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this));
    };
    AnimationItem.prototype.configAnimation = function(animData) {
        if (!this.renderer) return;
        try {
            this.animationData = animData;
            if (this.initialSegment) {
                this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]);
                this.firstFrame = Math.round(this.initialSegment[0]);
            } else {
                this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip);
                this.firstFrame = Math.round(this.animationData.ip);
            }
            this.renderer.configAnimation(animData);
            if (!animData.assets) animData.assets = [];
            this.assets = this.animationData.assets;
            this.frameRate = this.animationData.fr;
            this.frameMult = this.animationData.fr / 1000;
            this.renderer.searchExtraCompositions(animData.assets);
            this.markers = markerParser(animData.markers || []);
            this.trigger("config_ready");
            this.preloadImages();
            this.loadSegments();
            this.updaFrameModifier();
            this.waitForFontsLoaded();
            if (this.isPaused) this.audioController.pause();
        } catch (error) {
            this.triggerConfigError(error);
        }
    };
    AnimationItem.prototype.waitForFontsLoaded = function() {
        if (!this.renderer) return;
        if (this.renderer.globalData.fontManager.isLoaded) this.checkLoaded();
        else setTimeout(this.waitForFontsLoaded.bind(this), 20);
    };
    AnimationItem.prototype.checkLoaded = function() {
        if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== "canvas") && this.imagePreloader.loadedFootages()) {
            this.isLoaded = true;
            var expressionsPlugin = getExpressionsPlugin();
            if (expressionsPlugin) expressionsPlugin.initExpressions(this);
            this.renderer.initItems();
            setTimeout((function() {
                this.trigger("DOMLoaded");
            }).bind(this), 0);
            this.gotoFrame();
            if (this.autoplay) this.play();
        }
    };
    AnimationItem.prototype.resize = function() {
        this.renderer.updateContainerSize();
    };
    AnimationItem.prototype.setSubframe = function(flag) {
        this.isSubframeEnabled = !!flag;
    };
    AnimationItem.prototype.gotoFrame = function() {
        this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame; // eslint-disable-line no-bitwise
        if (this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted) this.currentFrame = this.timeCompleted;
        this.trigger("enterFrame");
        this.renderFrame();
        this.trigger("drawnFrame");
    };
    AnimationItem.prototype.renderFrame = function() {
        if (this.isLoaded === false || !this.renderer) return;
        try {
            this.renderer.renderFrame(this.currentFrame + this.firstFrame);
        } catch (error) {
            this.triggerRenderFrameError(error);
        }
    };
    AnimationItem.prototype.play = function(name) {
        if (name && this.name !== name) return;
        if (this.isPaused === true) {
            this.isPaused = false;
            this.trigger("_pause");
            this.audioController.resume();
            if (this._idle) {
                this._idle = false;
                this.trigger("_active");
            }
        }
    };
    AnimationItem.prototype.pause = function(name) {
        if (name && this.name !== name) return;
        if (this.isPaused === false) {
            this.isPaused = true;
            this.trigger("_play");
            this._idle = true;
            this.trigger("_idle");
            this.audioController.pause();
        }
    };
    AnimationItem.prototype.togglePause = function(name) {
        if (name && this.name !== name) return;
        if (this.isPaused === true) this.play();
        else this.pause();
    };
    AnimationItem.prototype.stop = function(name) {
        if (name && this.name !== name) return;
        this.pause();
        this.playCount = 0;
        this._completedLoop = false;
        this.setCurrentRawFrameValue(0);
    };
    AnimationItem.prototype.getMarkerData = function(markerName) {
        var marker;
        for(var i = 0; i < this.markers.length; i += 1){
            marker = this.markers[i];
            if (marker.payload && marker.payload.name === markerName) return marker;
        }
        return null;
    };
    AnimationItem.prototype.goToAndStop = function(value, isFrame, name) {
        if (name && this.name !== name) return;
        var numValue = Number(value);
        if (isNaN(numValue)) {
            var marker = this.getMarkerData(value);
            if (marker) this.goToAndStop(marker.time, true);
        } else if (isFrame) this.setCurrentRawFrameValue(value);
        else this.setCurrentRawFrameValue(value * this.frameModifier);
        this.pause();
    };
    AnimationItem.prototype.goToAndPlay = function(value, isFrame, name) {
        if (name && this.name !== name) return;
        var numValue = Number(value);
        if (isNaN(numValue)) {
            var marker = this.getMarkerData(value);
            if (marker) {
                if (!marker.duration) this.goToAndStop(marker.time, true);
                else this.playSegments([
                    marker.time,
                    marker.time + marker.duration
                ], true);
            }
        } else this.goToAndStop(numValue, isFrame, name);
        this.play();
    };
    AnimationItem.prototype.advanceTime = function(value) {
        if (this.isPaused === true || this.isLoaded === false) return;
        var nextValue = this.currentRawFrame + value * this.frameModifier;
        var _isComplete = false; // Checking if nextValue > totalFrames - 1 for addressing non looping and looping animations.
        // If animation won't loop, it should stop at totalFrames - 1. If it will loop it should complete the last frame and then loop.
        if (nextValue >= this.totalFrames - 1 && this.frameModifier > 0) {
            if (!this.loop || this.playCount === this.loop) {
                if (!this.checkSegments(nextValue > this.totalFrames ? nextValue % this.totalFrames : 0)) {
                    _isComplete = true;
                    nextValue = this.totalFrames - 1;
                }
            } else if (nextValue >= this.totalFrames) {
                this.playCount += 1;
                if (!this.checkSegments(nextValue % this.totalFrames)) {
                    this.setCurrentRawFrameValue(nextValue % this.totalFrames);
                    this._completedLoop = true;
                    this.trigger("loopComplete");
                }
            } else this.setCurrentRawFrameValue(nextValue);
        } else if (nextValue < 0) {
            if (!this.checkSegments(nextValue % this.totalFrames)) {
                if (this.loop && !(this.playCount-- <= 0 && this.loop !== true)) {
                    // eslint-disable-line no-plusplus
                    this.setCurrentRawFrameValue(this.totalFrames + nextValue % this.totalFrames);
                    if (!this._completedLoop) this._completedLoop = true;
                    else this.trigger("loopComplete");
                } else {
                    _isComplete = true;
                    nextValue = 0;
                }
            }
        } else this.setCurrentRawFrameValue(nextValue);
        if (_isComplete) {
            this.setCurrentRawFrameValue(nextValue);
            this.pause();
            this.trigger("complete");
        }
    };
    AnimationItem.prototype.adjustSegment = function(arr, offset) {
        this.playCount = 0;
        if (arr[1] < arr[0]) {
            if (this.frameModifier > 0) {
                if (this.playSpeed < 0) this.setSpeed(-this.playSpeed);
                else this.setDirection(-1);
            }
            this.totalFrames = arr[0] - arr[1];
            this.timeCompleted = this.totalFrames;
            this.firstFrame = arr[1];
            this.setCurrentRawFrameValue(this.totalFrames - 0.001 - offset);
        } else if (arr[1] > arr[0]) {
            if (this.frameModifier < 0) {
                if (this.playSpeed < 0) this.setSpeed(-this.playSpeed);
                else this.setDirection(1);
            }
            this.totalFrames = arr[1] - arr[0];
            this.timeCompleted = this.totalFrames;
            this.firstFrame = arr[0];
            this.setCurrentRawFrameValue(0.001 + offset);
        }
        this.trigger("segmentStart");
    };
    AnimationItem.prototype.setSegment = function(init, end) {
        var pendingFrame = -1;
        if (this.isPaused) {
            if (this.currentRawFrame + this.firstFrame < init) pendingFrame = init;
            else if (this.currentRawFrame + this.firstFrame > end) pendingFrame = end - init;
        }
        this.firstFrame = init;
        this.totalFrames = end - init;
        this.timeCompleted = this.totalFrames;
        if (pendingFrame !== -1) this.goToAndStop(pendingFrame, true);
    };
    AnimationItem.prototype.playSegments = function(arr, forceFlag) {
        if (forceFlag) this.segments.length = 0;
        if (_typeof$4(arr[0]) === "object") {
            var i;
            var len = arr.length;
            for(i = 0; i < len; i += 1)this.segments.push(arr[i]);
        } else this.segments.push(arr);
        if (this.segments.length && forceFlag) this.adjustSegment(this.segments.shift(), 0);
        if (this.isPaused) this.play();
    };
    AnimationItem.prototype.resetSegments = function(forceFlag) {
        this.segments.length = 0;
        this.segments.push([
            this.animationData.ip,
            this.animationData.op
        ]);
        if (forceFlag) this.checkSegments(0);
    };
    AnimationItem.prototype.checkSegments = function(offset) {
        if (this.segments.length) {
            this.adjustSegment(this.segments.shift(), offset);
            return true;
        }
        return false;
    };
    AnimationItem.prototype.destroy = function(name) {
        if (name && this.name !== name || !this.renderer) return;
        this.renderer.destroy();
        this.imagePreloader.destroy();
        this.trigger("destroy");
        this._cbs = null;
        this.onEnterFrame = null;
        this.onLoopComplete = null;
        this.onComplete = null;
        this.onSegmentStart = null;
        this.onDestroy = null;
        this.renderer = null;
        this.renderer = null;
        this.imagePreloader = null;
        this.projectInterface = null;
    };
    AnimationItem.prototype.setCurrentRawFrameValue = function(value) {
        this.currentRawFrame = value;
        this.gotoFrame();
    };
    AnimationItem.prototype.setSpeed = function(val) {
        this.playSpeed = val;
        this.updaFrameModifier();
    };
    AnimationItem.prototype.setDirection = function(val) {
        this.playDirection = val < 0 ? -1 : 1;
        this.updaFrameModifier();
    };
    AnimationItem.prototype.setVolume = function(val, name) {
        if (name && this.name !== name) return;
        this.audioController.setVolume(val);
    };
    AnimationItem.prototype.getVolume = function() {
        return this.audioController.getVolume();
    };
    AnimationItem.prototype.mute = function(name) {
        if (name && this.name !== name) return;
        this.audioController.mute();
    };
    AnimationItem.prototype.unmute = function(name) {
        if (name && this.name !== name) return;
        this.audioController.unmute();
    };
    AnimationItem.prototype.updaFrameModifier = function() {
        this.frameModifier = this.frameMult * this.playSpeed * this.playDirection;
        this.audioController.setRate(this.playSpeed * this.playDirection);
    };
    AnimationItem.prototype.getPath = function() {
        return this.path;
    };
    AnimationItem.prototype.getAssetsPath = function(assetData) {
        var path = "";
        if (assetData.e) path = assetData.p;
        else if (this.assetsPath) {
            var imagePath = assetData.p;
            if (imagePath.indexOf("images/") !== -1) imagePath = imagePath.split("/")[1];
            path = this.assetsPath + imagePath;
        } else {
            path = this.path;
            path += assetData.u ? assetData.u : "";
            path += assetData.p;
        }
        return path;
    };
    AnimationItem.prototype.getAssetData = function(id) {
        var i = 0;
        var len = this.assets.length;
        while(i < len){
            if (id === this.assets[i].id) return this.assets[i];
            i += 1;
        }
        return null;
    };
    AnimationItem.prototype.hide = function() {
        this.renderer.hide();
    };
    AnimationItem.prototype.show = function() {
        this.renderer.show();
    };
    AnimationItem.prototype.getDuration = function(isFrame) {
        return isFrame ? this.totalFrames : this.totalFrames / this.frameRate;
    };
    AnimationItem.prototype.updateDocumentData = function(path, documentData, index) {
        try {
            var element = this.renderer.getElementByPath(path);
            element.updateDocumentData(documentData, index);
        } catch (error) {}
    };
    AnimationItem.prototype.trigger = function(name) {
        if (this._cbs && this._cbs[name]) switch(name){
            case "enterFrame":
                this.triggerEvent(name, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameModifier));
                break;
            case "drawnFrame":
                this.drawnFrameEvent.currentTime = this.currentFrame;
                this.drawnFrameEvent.totalTime = this.totalFrames;
                this.drawnFrameEvent.direction = this.frameModifier;
                this.triggerEvent(name, this.drawnFrameEvent);
                break;
            case "loopComplete":
                this.triggerEvent(name, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));
                break;
            case "complete":
                this.triggerEvent(name, new BMCompleteEvent(name, this.frameMult));
                break;
            case "segmentStart":
                this.triggerEvent(name, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));
                break;
            case "destroy":
                this.triggerEvent(name, new BMDestroyEvent(name, this));
                break;
            default:
                this.triggerEvent(name);
        }
        if (name === "enterFrame" && this.onEnterFrame) this.onEnterFrame.call(this, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameMult));
        if (name === "loopComplete" && this.onLoopComplete) this.onLoopComplete.call(this, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));
        if (name === "complete" && this.onComplete) this.onComplete.call(this, new BMCompleteEvent(name, this.frameMult));
        if (name === "segmentStart" && this.onSegmentStart) this.onSegmentStart.call(this, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));
        if (name === "destroy" && this.onDestroy) this.onDestroy.call(this, new BMDestroyEvent(name, this));
    };
    AnimationItem.prototype.triggerRenderFrameError = function(nativeError) {
        var error = new BMRenderFrameErrorEvent(nativeError, this.currentFrame);
        this.triggerEvent("error", error);
        if (this.onError) this.onError.call(this, error);
    };
    AnimationItem.prototype.triggerConfigError = function(nativeError) {
        var error = new BMConfigErrorEvent(nativeError, this.currentFrame);
        this.triggerEvent("error", error);
        if (this.onError) this.onError.call(this, error);
    };
    var animationManager = function() {
        var moduleOb = {};
        var registeredAnimations = [];
        var initTime = 0;
        var len = 0;
        var playingAnimationsNum = 0;
        var _stopped = true;
        var _isFrozen = false;
        function removeElement(ev) {
            var i = 0;
            var animItem = ev.target;
            while(i < len){
                if (registeredAnimations[i].animation === animItem) {
                    registeredAnimations.splice(i, 1);
                    i -= 1;
                    len -= 1;
                    if (!animItem.isPaused) subtractPlayingCount();
                }
                i += 1;
            }
        }
        function registerAnimation(element, animationData) {
            if (!element) return null;
            var i = 0;
            while(i < len){
                if (registeredAnimations[i].elem === element && registeredAnimations[i].elem !== null) return registeredAnimations[i].animation;
                i += 1;
            }
            var animItem = new AnimationItem();
            setupAnimation(animItem, element);
            animItem.setData(element, animationData);
            return animItem;
        }
        function getRegisteredAnimations() {
            var i;
            var lenAnims = registeredAnimations.length;
            var animations = [];
            for(i = 0; i < lenAnims; i += 1)animations.push(registeredAnimations[i].animation);
            return animations;
        }
        function addPlayingCount() {
            playingAnimationsNum += 1;
            activate();
        }
        function subtractPlayingCount() {
            playingAnimationsNum -= 1;
        }
        function setupAnimation(animItem, element) {
            animItem.addEventListener("destroy", removeElement);
            animItem.addEventListener("_active", addPlayingCount);
            animItem.addEventListener("_idle", subtractPlayingCount);
            registeredAnimations.push({
                elem: element,
                animation: animItem
            });
            len += 1;
        }
        function loadAnimation(params) {
            var animItem = new AnimationItem();
            setupAnimation(animItem, null);
            animItem.setParams(params);
            return animItem;
        }
        function setSpeed(val, animation) {
            var i;
            for(i = 0; i < len; i += 1)registeredAnimations[i].animation.setSpeed(val, animation);
        }
        function setDirection(val, animation) {
            var i;
            for(i = 0; i < len; i += 1)registeredAnimations[i].animation.setDirection(val, animation);
        }
        function play(animation) {
            var i;
            for(i = 0; i < len; i += 1)registeredAnimations[i].animation.play(animation);
        }
        function resume(nowTime) {
            var elapsedTime = nowTime - initTime;
            var i;
            for(i = 0; i < len; i += 1)registeredAnimations[i].animation.advanceTime(elapsedTime);
            initTime = nowTime;
            if (playingAnimationsNum && !_isFrozen) window.requestAnimationFrame(resume);
            else _stopped = true;
        }
        function first(nowTime) {
            initTime = nowTime;
            window.requestAnimationFrame(resume);
        }
        function pause(animation) {
            var i;
            for(i = 0; i < len; i += 1)registeredAnimations[i].animation.pause(animation);
        }
        function goToAndStop(value, isFrame, animation) {
            var i;
            for(i = 0; i < len; i += 1)registeredAnimations[i].animation.goToAndStop(value, isFrame, animation);
        }
        function stop(animation) {
            var i;
            for(i = 0; i < len; i += 1)registeredAnimations[i].animation.stop(animation);
        }
        function togglePause(animation) {
            var i;
            for(i = 0; i < len; i += 1)registeredAnimations[i].animation.togglePause(animation);
        }
        function destroy(animation) {
            var i;
            for(i = len - 1; i >= 0; i -= 1)registeredAnimations[i].animation.destroy(animation);
        }
        function searchAnimations(animationData, standalone, renderer) {
            var animElements = [].concat([].slice.call(document.getElementsByClassName("lottie")), [].slice.call(document.getElementsByClassName("bodymovin")));
            var i;
            var lenAnims = animElements.length;
            for(i = 0; i < lenAnims; i += 1){
                if (renderer) animElements[i].setAttribute("data-bm-type", renderer);
                registerAnimation(animElements[i], animationData);
            }
            if (standalone && lenAnims === 0) {
                if (!renderer) renderer = "svg";
                var body = document.getElementsByTagName("body")[0];
                body.innerText = "";
                var div = createTag("div");
                div.style.width = "100%";
                div.style.height = "100%";
                div.setAttribute("data-bm-type", renderer);
                body.appendChild(div);
                registerAnimation(div, animationData);
            }
        }
        function resize() {
            var i;
            for(i = 0; i < len; i += 1)registeredAnimations[i].animation.resize();
        }
        function activate() {
            if (!_isFrozen && playingAnimationsNum) {
                if (_stopped) {
                    window.requestAnimationFrame(first);
                    _stopped = false;
                }
            }
        }
        function freeze() {
            _isFrozen = true;
        }
        function unfreeze() {
            _isFrozen = false;
            activate();
        }
        function setVolume(val, animation) {
            var i;
            for(i = 0; i < len; i += 1)registeredAnimations[i].animation.setVolume(val, animation);
        }
        function mute(animation) {
            var i;
            for(i = 0; i < len; i += 1)registeredAnimations[i].animation.mute(animation);
        }
        function unmute(animation) {
            var i;
            for(i = 0; i < len; i += 1)registeredAnimations[i].animation.unmute(animation);
        }
        moduleOb.registerAnimation = registerAnimation;
        moduleOb.loadAnimation = loadAnimation;
        moduleOb.setSpeed = setSpeed;
        moduleOb.setDirection = setDirection;
        moduleOb.play = play;
        moduleOb.pause = pause;
        moduleOb.stop = stop;
        moduleOb.togglePause = togglePause;
        moduleOb.searchAnimations = searchAnimations;
        moduleOb.resize = resize; // moduleOb.start = start;
        moduleOb.goToAndStop = goToAndStop;
        moduleOb.destroy = destroy;
        moduleOb.freeze = freeze;
        moduleOb.unfreeze = unfreeze;
        moduleOb.setVolume = setVolume;
        moduleOb.mute = mute;
        moduleOb.unmute = unmute;
        moduleOb.getRegisteredAnimations = getRegisteredAnimations;
        return moduleOb;
    }();
    /* eslint-disable */ var BezierFactory = function() {
        /**
       * BezierEasing - use bezier curve for transition easing function
       * by Gaëtan Renaudeau 2014 - 2015 – MIT License
       *
       * Credits: is based on Firefox's nsSMILKeySpline.cpp
       * Usage:
       * var spline = BezierEasing([ 0.25, 0.1, 0.25, 1.0 ])
       * spline.get(x) => returns the easing value | x must be in [0, 1] range
       *
       */ var ob = {};
        ob.getBezierEasing = getBezierEasing;
        var beziers = {};
        function getBezierEasing(a, b, c, d, nm) {
            var str = nm || ("bez_" + a + "_" + b + "_" + c + "_" + d).replace(/\./g, "p");
            if (beziers[str]) return beziers[str];
            var bezEasing = new BezierEasing([
                a,
                b,
                c,
                d
            ]);
            beziers[str] = bezEasing;
            return bezEasing;
        } // These values are established by empiricism with tests (tradeoff: performance VS precision)
        var NEWTON_ITERATIONS = 4;
        var NEWTON_MIN_SLOPE = 0.001;
        var SUBDIVISION_PRECISION = 0.0000001;
        var SUBDIVISION_MAX_ITERATIONS = 10;
        var kSplineTableSize = 11;
        var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
        var float32ArraySupported = typeof Float32Array === "function";
        function A(aA1, aA2) {
            return 1.0 - 3.0 * aA2 + 3.0 * aA1;
        }
        function B(aA1, aA2) {
            return 3.0 * aA2 - 6.0 * aA1;
        }
        function C(aA1) {
            return 3.0 * aA1;
        } // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
        function calcBezier(aT, aA1, aA2) {
            return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
        } // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
        function getSlope(aT, aA1, aA2) {
            return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
        }
        function binarySubdivide(aX, aA, aB, mX1, mX2) {
            var currentX, currentT, i = 0;
            do {
                currentT = aA + (aB - aA) / 2.0;
                currentX = calcBezier(currentT, mX1, mX2) - aX;
                if (currentX > 0.0) aB = currentT;
                else aA = currentT;
            }while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
            return currentT;
        }
        function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
            for(var i = 0; i < NEWTON_ITERATIONS; ++i){
                var currentSlope = getSlope(aGuessT, mX1, mX2);
                if (currentSlope === 0.0) return aGuessT;
                var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
                aGuessT -= currentX / currentSlope;
            }
            return aGuessT;
        }
        /**
       * points is an array of [ mX1, mY1, mX2, mY2 ]
       */ function BezierEasing(points) {
            this._p = points;
            this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
            this._precomputed = false;
            this.get = this.get.bind(this);
        }
        BezierEasing.prototype = {
            get: function get(x) {
                var mX1 = this._p[0], mY1 = this._p[1], mX2 = this._p[2], mY2 = this._p[3];
                if (!this._precomputed) this._precompute();
                if (mX1 === mY1 && mX2 === mY2) return x; // linear
                // Because JavaScript number are imprecise, we should guarantee the extremes are right.
                if (x === 0) return 0;
                if (x === 1) return 1;
                return calcBezier(this._getTForX(x), mY1, mY2);
            },
            // Private part
            _precompute: function _precompute() {
                var mX1 = this._p[0], mY1 = this._p[1], mX2 = this._p[2], mY2 = this._p[3];
                this._precomputed = true;
                if (mX1 !== mY1 || mX2 !== mY2) this._calcSampleValues();
            },
            _calcSampleValues: function _calcSampleValues() {
                var mX1 = this._p[0], mX2 = this._p[2];
                for(var i = 0; i < kSplineTableSize; ++i)this._mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
            },
            /**
           * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.
           */ _getTForX: function _getTForX(aX) {
                var mX1 = this._p[0], mX2 = this._p[2], mSampleValues = this._mSampleValues;
                var intervalStart = 0.0;
                var currentSample = 1;
                var lastSample = kSplineTableSize - 1;
                for(; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample)intervalStart += kSampleStepSize;
                --currentSample; // Interpolate to provide an initial guess for t
                var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]);
                var guessForT = intervalStart + dist * kSampleStepSize;
                var initialSlope = getSlope(guessForT, mX1, mX2);
                if (initialSlope >= NEWTON_MIN_SLOPE) return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
                if (initialSlope === 0.0) return guessForT;
                return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
            }
        };
        return ob;
    }();
    var pooling = function() {
        function _double(arr) {
            return arr.concat(createSizedArray(arr.length));
        }
        return {
            "double": _double
        };
    }();
    var poolFactory = function() {
        return function(initialLength, _create, _release) {
            var _length = 0;
            var _maxLength = initialLength;
            var pool = createSizedArray(_maxLength);
            var ob = {
                newElement: newElement,
                release: release
            };
            function newElement() {
                var element;
                if (_length) {
                    _length -= 1;
                    element = pool[_length];
                } else element = _create();
                return element;
            }
            function release(element) {
                if (_length === _maxLength) {
                    pool = pooling["double"](pool);
                    _maxLength *= 2;
                }
                if (_release) _release(element);
                pool[_length] = element;
                _length += 1;
            }
            return ob;
        };
    }();
    var bezierLengthPool = function() {
        function create() {
            return {
                addedLength: 0,
                percents: createTypedArray("float32", getDefaultCurveSegments()),
                lengths: createTypedArray("float32", getDefaultCurveSegments())
            };
        }
        return poolFactory(8, create);
    }();
    var segmentsLengthPool = function() {
        function create() {
            return {
                lengths: [],
                totalLength: 0
            };
        }
        function release(element) {
            var i;
            var len = element.lengths.length;
            for(i = 0; i < len; i += 1)bezierLengthPool.release(element.lengths[i]);
            element.lengths.length = 0;
        }
        return poolFactory(8, create, release);
    }();
    function bezFunction() {
        var math = Math;
        function pointOnLine2D(x1, y1, x2, y2, x3, y3) {
            var det1 = x1 * y2 + y1 * x3 + x2 * y3 - x3 * y2 - y3 * x1 - x2 * y1;
            return det1 > -0.001 && det1 < 0.001;
        }
        function pointOnLine3D(x1, y1, z1, x2, y2, z2, x3, y3, z3) {
            if (z1 === 0 && z2 === 0 && z3 === 0) return pointOnLine2D(x1, y1, x2, y2, x3, y3);
            var dist1 = math.sqrt(math.pow(x2 - x1, 2) + math.pow(y2 - y1, 2) + math.pow(z2 - z1, 2));
            var dist2 = math.sqrt(math.pow(x3 - x1, 2) + math.pow(y3 - y1, 2) + math.pow(z3 - z1, 2));
            var dist3 = math.sqrt(math.pow(x3 - x2, 2) + math.pow(y3 - y2, 2) + math.pow(z3 - z2, 2));
            var diffDist;
            if (dist1 > dist2) {
                if (dist1 > dist3) diffDist = dist1 - dist2 - dist3;
                else diffDist = dist3 - dist2 - dist1;
            } else if (dist3 > dist2) diffDist = dist3 - dist2 - dist1;
            else diffDist = dist2 - dist1 - dist3;
            return diffDist > -0.0001 && diffDist < 0.0001;
        }
        var getBezierLength = function() {
            return function(pt1, pt2, pt3, pt4) {
                var curveSegments = getDefaultCurveSegments();
                var k;
                var i;
                var len;
                var ptCoord;
                var perc;
                var addedLength = 0;
                var ptDistance;
                var point = [];
                var lastPoint = [];
                var lengthData = bezierLengthPool.newElement();
                len = pt3.length;
                for(k = 0; k < curveSegments; k += 1){
                    perc = k / (curveSegments - 1);
                    ptDistance = 0;
                    for(i = 0; i < len; i += 1){
                        ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * pt3[i] + 3 * (1 - perc) * bmPow(perc, 2) * pt4[i] + bmPow(perc, 3) * pt2[i];
                        point[i] = ptCoord;
                        if (lastPoint[i] !== null) ptDistance += bmPow(point[i] - lastPoint[i], 2);
                        lastPoint[i] = point[i];
                    }
                    if (ptDistance) {
                        ptDistance = bmSqrt(ptDistance);
                        addedLength += ptDistance;
                    }
                    lengthData.percents[k] = perc;
                    lengthData.lengths[k] = addedLength;
                }
                lengthData.addedLength = addedLength;
                return lengthData;
            };
        }();
        function getSegmentsLength(shapeData) {
            var segmentsLength = segmentsLengthPool.newElement();
            var closed = shapeData.c;
            var pathV = shapeData.v;
            var pathO = shapeData.o;
            var pathI = shapeData.i;
            var i;
            var len = shapeData._length;
            var lengths = segmentsLength.lengths;
            var totalLength = 0;
            for(i = 0; i < len - 1; i += 1){
                lengths[i] = getBezierLength(pathV[i], pathV[i + 1], pathO[i], pathI[i + 1]);
                totalLength += lengths[i].addedLength;
            }
            if (closed && len) {
                lengths[i] = getBezierLength(pathV[i], pathV[0], pathO[i], pathI[0]);
                totalLength += lengths[i].addedLength;
            }
            segmentsLength.totalLength = totalLength;
            return segmentsLength;
        }
        function BezierData(length) {
            this.segmentLength = 0;
            this.points = new Array(length);
        }
        function PointData(partial, point) {
            this.partialLength = partial;
            this.point = point;
        }
        var buildBezierData = function() {
            var storedData = {};
            return function(pt1, pt2, pt3, pt4) {
                var bezierName = (pt1[0] + "_" + pt1[1] + "_" + pt2[0] + "_" + pt2[1] + "_" + pt3[0] + "_" + pt3[1] + "_" + pt4[0] + "_" + pt4[1]).replace(/\./g, "p");
                if (!storedData[bezierName]) {
                    var curveSegments = getDefaultCurveSegments();
                    var k;
                    var i;
                    var len;
                    var ptCoord;
                    var perc;
                    var addedLength = 0;
                    var ptDistance;
                    var point;
                    var lastPoint = null;
                    if (pt1.length === 2 && (pt1[0] !== pt2[0] || pt1[1] !== pt2[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt1[0] + pt3[0], pt1[1] + pt3[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt2[0] + pt4[0], pt2[1] + pt4[1])) curveSegments = 2;
                    var bezierData = new BezierData(curveSegments);
                    len = pt3.length;
                    for(k = 0; k < curveSegments; k += 1){
                        point = createSizedArray(len);
                        perc = k / (curveSegments - 1);
                        ptDistance = 0;
                        for(i = 0; i < len; i += 1){
                            ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * (pt1[i] + pt3[i]) + 3 * (1 - perc) * bmPow(perc, 2) * (pt2[i] + pt4[i]) + bmPow(perc, 3) * pt2[i];
                            point[i] = ptCoord;
                            if (lastPoint !== null) ptDistance += bmPow(point[i] - lastPoint[i], 2);
                        }
                        ptDistance = bmSqrt(ptDistance);
                        addedLength += ptDistance;
                        bezierData.points[k] = new PointData(ptDistance, point);
                        lastPoint = point;
                    }
                    bezierData.segmentLength = addedLength;
                    storedData[bezierName] = bezierData;
                }
                return storedData[bezierName];
            };
        }();
        function getDistancePerc(perc, bezierData) {
            var percents = bezierData.percents;
            var lengths = bezierData.lengths;
            var len = percents.length;
            var initPos = bmFloor((len - 1) * perc);
            var lengthPos = perc * bezierData.addedLength;
            var lPerc = 0;
            if (initPos === len - 1 || initPos === 0 || lengthPos === lengths[initPos]) return percents[initPos];
            var dir = lengths[initPos] > lengthPos ? -1 : 1;
            var flag = true;
            while(flag){
                if (lengths[initPos] <= lengthPos && lengths[initPos + 1] > lengthPos) {
                    lPerc = (lengthPos - lengths[initPos]) / (lengths[initPos + 1] - lengths[initPos]);
                    flag = false;
                } else initPos += dir;
                if (initPos < 0 || initPos >= len - 1) {
                    // FIX for TypedArrays that don't store floating point values with enough accuracy
                    if (initPos === len - 1) return percents[initPos];
                    flag = false;
                }
            }
            return percents[initPos] + (percents[initPos + 1] - percents[initPos]) * lPerc;
        }
        function getPointInSegment(pt1, pt2, pt3, pt4, percent, bezierData) {
            var t1 = getDistancePerc(percent, bezierData);
            var u1 = 1 - t1;
            var ptX = math.round((u1 * u1 * u1 * pt1[0] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[0] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[0] + t1 * t1 * t1 * pt2[0]) * 1000) / 1000;
            var ptY = math.round((u1 * u1 * u1 * pt1[1] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[1] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[1] + t1 * t1 * t1 * pt2[1]) * 1000) / 1000;
            return [
                ptX,
                ptY
            ];
        }
        var bezierSegmentPoints = createTypedArray("float32", 8);
        function getNewSegment(pt1, pt2, pt3, pt4, startPerc, endPerc, bezierData) {
            if (startPerc < 0) startPerc = 0;
            else if (startPerc > 1) startPerc = 1;
            var t0 = getDistancePerc(startPerc, bezierData);
            endPerc = endPerc > 1 ? 1 : endPerc;
            var t1 = getDistancePerc(endPerc, bezierData);
            var i;
            var len = pt1.length;
            var u0 = 1 - t0;
            var u1 = 1 - t1;
            var u0u0u0 = u0 * u0 * u0;
            var t0u0u0_3 = t0 * u0 * u0 * 3; // eslint-disable-line camelcase
            var t0t0u0_3 = t0 * t0 * u0 * 3; // eslint-disable-line camelcase
            var t0t0t0 = t0 * t0 * t0; //
            var u0u0u1 = u0 * u0 * u1;
            var t0u0u1_3 = t0 * u0 * u1 + u0 * t0 * u1 + u0 * u0 * t1; // eslint-disable-line camelcase
            var t0t0u1_3 = t0 * t0 * u1 + u0 * t0 * t1 + t0 * u0 * t1; // eslint-disable-line camelcase
            var t0t0t1 = t0 * t0 * t1; //
            var u0u1u1 = u0 * u1 * u1;
            var t0u1u1_3 = t0 * u1 * u1 + u0 * t1 * u1 + u0 * u1 * t1; // eslint-disable-line camelcase
            var t0t1u1_3 = t0 * t1 * u1 + u0 * t1 * t1 + t0 * u1 * t1; // eslint-disable-line camelcase
            var t0t1t1 = t0 * t1 * t1; //
            var u1u1u1 = u1 * u1 * u1;
            var t1u1u1_3 = t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1; // eslint-disable-line camelcase
            var t1t1u1_3 = t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1; // eslint-disable-line camelcase
            var t1t1t1 = t1 * t1 * t1;
            for(i = 0; i < len; i += 1){
                bezierSegmentPoints[i * 4] = math.round((u0u0u0 * pt1[i] + t0u0u0_3 * pt3[i] + t0t0u0_3 * pt4[i] + t0t0t0 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase
                bezierSegmentPoints[i * 4 + 1] = math.round((u0u0u1 * pt1[i] + t0u0u1_3 * pt3[i] + t0t0u1_3 * pt4[i] + t0t0t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase
                bezierSegmentPoints[i * 4 + 2] = math.round((u0u1u1 * pt1[i] + t0u1u1_3 * pt3[i] + t0t1u1_3 * pt4[i] + t0t1t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase
                bezierSegmentPoints[i * 4 + 3] = math.round((u1u1u1 * pt1[i] + t1u1u1_3 * pt3[i] + t1t1u1_3 * pt4[i] + t1t1t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase
            }
            return bezierSegmentPoints;
        }
        return {
            getSegmentsLength: getSegmentsLength,
            getNewSegment: getNewSegment,
            getPointInSegment: getPointInSegment,
            buildBezierData: buildBezierData,
            pointOnLine2D: pointOnLine2D,
            pointOnLine3D: pointOnLine3D
        };
    }
    var bez = bezFunction();
    var PropertyFactory = function() {
        var initFrame = initialDefaultFrame;
        var mathAbs = Math.abs;
        function interpolateValue(frameNum, caching) {
            var offsetTime = this.offsetTime;
            var newValue;
            if (this.propType === "multidimensional") newValue = createTypedArray("float32", this.pv.length);
            var iterationIndex = caching.lastIndex;
            var i = iterationIndex;
            var len = this.keyframes.length - 1;
            var flag = true;
            var keyData;
            var nextKeyData;
            var keyframeMetadata;
            while(flag){
                keyData = this.keyframes[i];
                nextKeyData = this.keyframes[i + 1];
                if (i === len - 1 && frameNum >= nextKeyData.t - offsetTime) {
                    if (keyData.h) keyData = nextKeyData;
                    iterationIndex = 0;
                    break;
                }
                if (nextKeyData.t - offsetTime > frameNum) {
                    iterationIndex = i;
                    break;
                }
                if (i < len - 1) i += 1;
                else {
                    iterationIndex = 0;
                    flag = false;
                }
            }
            keyframeMetadata = this.keyframesMetadata[i] || {};
            var k;
            var kLen;
            var perc;
            var jLen;
            var j;
            var fnc;
            var nextKeyTime = nextKeyData.t - offsetTime;
            var keyTime = keyData.t - offsetTime;
            var endValue;
            if (keyData.to) {
                if (!keyframeMetadata.bezierData) keyframeMetadata.bezierData = bez.buildBezierData(keyData.s, nextKeyData.s || keyData.e, keyData.to, keyData.ti);
                var bezierData = keyframeMetadata.bezierData;
                if (frameNum >= nextKeyTime || frameNum < keyTime) {
                    var ind = frameNum >= nextKeyTime ? bezierData.points.length - 1 : 0;
                    kLen = bezierData.points[ind].point.length;
                    for(k = 0; k < kLen; k += 1)newValue[k] = bezierData.points[ind].point[k];
                     // caching._lastKeyframeIndex = -1;
                } else {
                    if (keyframeMetadata.__fnct) fnc = keyframeMetadata.__fnct;
                    else {
                        fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y, keyData.n).get;
                        keyframeMetadata.__fnct = fnc;
                    }
                    perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
                    var distanceInLine = bezierData.segmentLength * perc;
                    var segmentPerc;
                    var addedLength = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i ? caching._lastAddedLength : 0;
                    j = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i ? caching._lastPoint : 0;
                    flag = true;
                    jLen = bezierData.points.length;
                    while(flag){
                        addedLength += bezierData.points[j].partialLength;
                        if (distanceInLine === 0 || perc === 0 || j === bezierData.points.length - 1) {
                            kLen = bezierData.points[j].point.length;
                            for(k = 0; k < kLen; k += 1)newValue[k] = bezierData.points[j].point[k];
                            break;
                        } else if (distanceInLine >= addedLength && distanceInLine < addedLength + bezierData.points[j + 1].partialLength) {
                            segmentPerc = (distanceInLine - addedLength) / bezierData.points[j + 1].partialLength;
                            kLen = bezierData.points[j].point.length;
                            for(k = 0; k < kLen; k += 1)newValue[k] = bezierData.points[j].point[k] + (bezierData.points[j + 1].point[k] - bezierData.points[j].point[k]) * segmentPerc;
                            break;
                        }
                        if (j < jLen - 1) j += 1;
                        else flag = false;
                    }
                    caching._lastPoint = j;
                    caching._lastAddedLength = addedLength - bezierData.points[j].partialLength;
                    caching._lastKeyframeIndex = i;
                }
            } else {
                var outX;
                var outY;
                var inX;
                var inY;
                var keyValue;
                len = keyData.s.length;
                endValue = nextKeyData.s || keyData.e;
                if (this.sh && keyData.h !== 1) {
                    if (frameNum >= nextKeyTime) {
                        newValue[0] = endValue[0];
                        newValue[1] = endValue[1];
                        newValue[2] = endValue[2];
                    } else if (frameNum <= keyTime) {
                        newValue[0] = keyData.s[0];
                        newValue[1] = keyData.s[1];
                        newValue[2] = keyData.s[2];
                    } else {
                        var quatStart = createQuaternion(keyData.s);
                        var quatEnd = createQuaternion(endValue);
                        var time = (frameNum - keyTime) / (nextKeyTime - keyTime);
                        quaternionToEuler(newValue, slerp(quatStart, quatEnd, time));
                    }
                } else for(i = 0; i < len; i += 1){
                    if (keyData.h !== 1) {
                        if (frameNum >= nextKeyTime) perc = 1;
                        else if (frameNum < keyTime) perc = 0;
                        else {
                            if (keyData.o.x.constructor === Array) {
                                if (!keyframeMetadata.__fnct) keyframeMetadata.__fnct = [];
                                if (!keyframeMetadata.__fnct[i]) {
                                    outX = keyData.o.x[i] === undefined ? keyData.o.x[0] : keyData.o.x[i];
                                    outY = keyData.o.y[i] === undefined ? keyData.o.y[0] : keyData.o.y[i];
                                    inX = keyData.i.x[i] === undefined ? keyData.i.x[0] : keyData.i.x[i];
                                    inY = keyData.i.y[i] === undefined ? keyData.i.y[0] : keyData.i.y[i];
                                    fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                                    keyframeMetadata.__fnct[i] = fnc;
                                } else fnc = keyframeMetadata.__fnct[i];
                            } else if (!keyframeMetadata.__fnct) {
                                outX = keyData.o.x;
                                outY = keyData.o.y;
                                inX = keyData.i.x;
                                inY = keyData.i.y;
                                fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                                keyData.keyframeMetadata = fnc;
                            } else fnc = keyframeMetadata.__fnct;
                            perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
                        }
                    }
                    endValue = nextKeyData.s || keyData.e;
                    keyValue = keyData.h === 1 ? keyData.s[i] : keyData.s[i] + (endValue[i] - keyData.s[i]) * perc;
                    if (this.propType === "multidimensional") newValue[i] = keyValue;
                    else newValue = keyValue;
                }
            }
            caching.lastIndex = iterationIndex;
            return newValue;
        } // based on @Toji's https://github.com/toji/gl-matrix/
        function slerp(a, b, t) {
            var out = [];
            var ax = a[0];
            var ay = a[1];
            var az = a[2];
            var aw = a[3];
            var bx = b[0];
            var by = b[1];
            var bz = b[2];
            var bw = b[3];
            var omega;
            var cosom;
            var sinom;
            var scale0;
            var scale1;
            cosom = ax * bx + ay * by + az * bz + aw * bw;
            if (cosom < 0.0) {
                cosom = -cosom;
                bx = -bx;
                by = -by;
                bz = -bz;
                bw = -bw;
            }
            if (1.0 - cosom > 0.000001) {
                omega = Math.acos(cosom);
                sinom = Math.sin(omega);
                scale0 = Math.sin((1.0 - t) * omega) / sinom;
                scale1 = Math.sin(t * omega) / sinom;
            } else {
                scale0 = 1.0 - t;
                scale1 = t;
            }
            out[0] = scale0 * ax + scale1 * bx;
            out[1] = scale0 * ay + scale1 * by;
            out[2] = scale0 * az + scale1 * bz;
            out[3] = scale0 * aw + scale1 * bw;
            return out;
        }
        function quaternionToEuler(out, quat) {
            var qx = quat[0];
            var qy = quat[1];
            var qz = quat[2];
            var qw = quat[3];
            var heading = Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy * qy - 2 * qz * qz);
            var attitude = Math.asin(2 * qx * qy + 2 * qz * qw);
            var bank = Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx * qx - 2 * qz * qz);
            out[0] = heading / degToRads;
            out[1] = attitude / degToRads;
            out[2] = bank / degToRads;
        }
        function createQuaternion(values) {
            var heading = values[0] * degToRads;
            var attitude = values[1] * degToRads;
            var bank = values[2] * degToRads;
            var c1 = Math.cos(heading / 2);
            var c2 = Math.cos(attitude / 2);
            var c3 = Math.cos(bank / 2);
            var s1 = Math.sin(heading / 2);
            var s2 = Math.sin(attitude / 2);
            var s3 = Math.sin(bank / 2);
            var w = c1 * c2 * c3 - s1 * s2 * s3;
            var x = s1 * s2 * c3 + c1 * c2 * s3;
            var y = s1 * c2 * c3 + c1 * s2 * s3;
            var z = c1 * s2 * c3 - s1 * c2 * s3;
            return [
                x,
                y,
                z,
                w
            ];
        }
        function getValueAtCurrentTime() {
            var frameNum = this.comp.renderedFrame - this.offsetTime;
            var initTime = this.keyframes[0].t - this.offsetTime;
            var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
            if (!(frameNum === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= endTime && frameNum >= endTime || this._caching.lastFrame < initTime && frameNum < initTime))) {
                if (this._caching.lastFrame >= frameNum) {
                    this._caching._lastKeyframeIndex = -1;
                    this._caching.lastIndex = 0;
                }
                var renderResult = this.interpolateValue(frameNum, this._caching);
                this.pv = renderResult;
            }
            this._caching.lastFrame = frameNum;
            return this.pv;
        }
        function setVValue(val) {
            var multipliedValue;
            if (this.propType === "unidimensional") {
                multipliedValue = val * this.mult;
                if (mathAbs(this.v - multipliedValue) > 0.00001) {
                    this.v = multipliedValue;
                    this._mdf = true;
                }
            } else {
                var i = 0;
                var len = this.v.length;
                while(i < len){
                    multipliedValue = val[i] * this.mult;
                    if (mathAbs(this.v[i] - multipliedValue) > 0.00001) {
                        this.v[i] = multipliedValue;
                        this._mdf = true;
                    }
                    i += 1;
                }
            }
        }
        function processEffectsSequence() {
            if (this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) return;
            if (this.lock) {
                this.setVValue(this.pv);
                return;
            }
            this.lock = true;
            this._mdf = this._isFirstFrame;
            var i;
            var len = this.effectsSequence.length;
            var finalValue = this.kf ? this.pv : this.data.k;
            for(i = 0; i < len; i += 1)finalValue = this.effectsSequence[i](finalValue);
            this.setVValue(finalValue);
            this._isFirstFrame = false;
            this.lock = false;
            this.frameId = this.elem.globalData.frameId;
        }
        function addEffect(effectFunction) {
            this.effectsSequence.push(effectFunction);
            this.container.addDynamicProperty(this);
        }
        function ValueProperty(elem, data, mult, container) {
            this.propType = "unidimensional";
            this.mult = mult || 1;
            this.data = data;
            this.v = mult ? data.k * mult : data.k;
            this.pv = data.k;
            this._mdf = false;
            this.elem = elem;
            this.container = container;
            this.comp = elem.comp;
            this.k = false;
            this.kf = false;
            this.vel = 0;
            this.effectsSequence = [];
            this._isFirstFrame = true;
            this.getValue = processEffectsSequence;
            this.setVValue = setVValue;
            this.addEffect = addEffect;
        }
        function MultiDimensionalProperty(elem, data, mult, container) {
            this.propType = "multidimensional";
            this.mult = mult || 1;
            this.data = data;
            this._mdf = false;
            this.elem = elem;
            this.container = container;
            this.comp = elem.comp;
            this.k = false;
            this.kf = false;
            this.frameId = -1;
            var i;
            var len = data.k.length;
            this.v = createTypedArray("float32", len);
            this.pv = createTypedArray("float32", len);
            this.vel = createTypedArray("float32", len);
            for(i = 0; i < len; i += 1){
                this.v[i] = data.k[i] * this.mult;
                this.pv[i] = data.k[i];
            }
            this._isFirstFrame = true;
            this.effectsSequence = [];
            this.getValue = processEffectsSequence;
            this.setVValue = setVValue;
            this.addEffect = addEffect;
        }
        function KeyframedValueProperty(elem, data, mult, container) {
            this.propType = "unidimensional";
            this.keyframes = data.k;
            this.keyframesMetadata = [];
            this.offsetTime = elem.data.st;
            this.frameId = -1;
            this._caching = {
                lastFrame: initFrame,
                lastIndex: 0,
                value: 0,
                _lastKeyframeIndex: -1
            };
            this.k = true;
            this.kf = true;
            this.data = data;
            this.mult = mult || 1;
            this.elem = elem;
            this.container = container;
            this.comp = elem.comp;
            this.v = initFrame;
            this.pv = initFrame;
            this._isFirstFrame = true;
            this.getValue = processEffectsSequence;
            this.setVValue = setVValue;
            this.interpolateValue = interpolateValue;
            this.effectsSequence = [
                getValueAtCurrentTime.bind(this)
            ];
            this.addEffect = addEffect;
        }
        function KeyframedMultidimensionalProperty(elem, data, mult, container) {
            this.propType = "multidimensional";
            var i;
            var len = data.k.length;
            var s;
            var e;
            var to;
            var ti;
            for(i = 0; i < len - 1; i += 1)if (data.k[i].to && data.k[i].s && data.k[i + 1] && data.k[i + 1].s) {
                s = data.k[i].s;
                e = data.k[i + 1].s;
                to = data.k[i].to;
                ti = data.k[i].ti;
                if (s.length === 2 && !(s[0] === e[0] && s[1] === e[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], s[0] + to[0], s[1] + to[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], e[0] + ti[0], e[1] + ti[1]) || s.length === 3 && !(s[0] === e[0] && s[1] === e[1] && s[2] === e[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], s[0] + to[0], s[1] + to[1], s[2] + to[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], e[0] + ti[0], e[1] + ti[1], e[2] + ti[2])) {
                    data.k[i].to = null;
                    data.k[i].ti = null;
                }
                if (s[0] === e[0] && s[1] === e[1] && to[0] === 0 && to[1] === 0 && ti[0] === 0 && ti[1] === 0) {
                    if (s.length === 2 || s[2] === e[2] && to[2] === 0 && ti[2] === 0) {
                        data.k[i].to = null;
                        data.k[i].ti = null;
                    }
                }
            }
            this.effectsSequence = [
                getValueAtCurrentTime.bind(this)
            ];
            this.data = data;
            this.keyframes = data.k;
            this.keyframesMetadata = [];
            this.offsetTime = elem.data.st;
            this.k = true;
            this.kf = true;
            this._isFirstFrame = true;
            this.mult = mult || 1;
            this.elem = elem;
            this.container = container;
            this.comp = elem.comp;
            this.getValue = processEffectsSequence;
            this.setVValue = setVValue;
            this.interpolateValue = interpolateValue;
            this.frameId = -1;
            var arrLen = data.k[0].s.length;
            this.v = createTypedArray("float32", arrLen);
            this.pv = createTypedArray("float32", arrLen);
            for(i = 0; i < arrLen; i += 1){
                this.v[i] = initFrame;
                this.pv[i] = initFrame;
            }
            this._caching = {
                lastFrame: initFrame,
                lastIndex: 0,
                value: createTypedArray("float32", arrLen)
            };
            this.addEffect = addEffect;
        }
        function getProp(elem, data, type, mult, container) {
            var p;
            if (!data.k.length) p = new ValueProperty(elem, data, mult, container);
            else if (typeof data.k[0] === "number") p = new MultiDimensionalProperty(elem, data, mult, container);
            else switch(type){
                case 0:
                    p = new KeyframedValueProperty(elem, data, mult, container);
                    break;
                case 1:
                    p = new KeyframedMultidimensionalProperty(elem, data, mult, container);
                    break;
                default:
                    break;
            }
            if (p.effectsSequence.length) container.addDynamicProperty(p);
            return p;
        }
        var ob = {
            getProp: getProp
        };
        return ob;
    }();
    function DynamicPropertyContainer() {}
    DynamicPropertyContainer.prototype = {
        addDynamicProperty: function addDynamicProperty(prop) {
            if (this.dynamicProperties.indexOf(prop) === -1) {
                this.dynamicProperties.push(prop);
                this.container.addDynamicProperty(this);
                this._isAnimated = true;
            }
        },
        iterateDynamicProperties: function iterateDynamicProperties() {
            this._mdf = false;
            var i;
            var len = this.dynamicProperties.length;
            for(i = 0; i < len; i += 1){
                this.dynamicProperties[i].getValue();
                if (this.dynamicProperties[i]._mdf) this._mdf = true;
            }
        },
        initDynamicPropertyContainer: function initDynamicPropertyContainer(container) {
            this.container = container;
            this.dynamicProperties = [];
            this._mdf = false;
            this._isAnimated = false;
        }
    };
    var pointPool = function() {
        function create() {
            return createTypedArray("float32", 2);
        }
        return poolFactory(8, create);
    }();
    function ShapePath() {
        this.c = false;
        this._length = 0;
        this._maxLength = 8;
        this.v = createSizedArray(this._maxLength);
        this.o = createSizedArray(this._maxLength);
        this.i = createSizedArray(this._maxLength);
    }
    ShapePath.prototype.setPathData = function(closed, len) {
        this.c = closed;
        this.setLength(len);
        var i = 0;
        while(i < len){
            this.v[i] = pointPool.newElement();
            this.o[i] = pointPool.newElement();
            this.i[i] = pointPool.newElement();
            i += 1;
        }
    };
    ShapePath.prototype.setLength = function(len) {
        while(this._maxLength < len)this.doubleArrayLength();
        this._length = len;
    };
    ShapePath.prototype.doubleArrayLength = function() {
        this.v = this.v.concat(createSizedArray(this._maxLength));
        this.i = this.i.concat(createSizedArray(this._maxLength));
        this.o = this.o.concat(createSizedArray(this._maxLength));
        this._maxLength *= 2;
    };
    ShapePath.prototype.setXYAt = function(x, y, type, pos, replace) {
        var arr;
        this._length = Math.max(this._length, pos + 1);
        if (this._length >= this._maxLength) this.doubleArrayLength();
        switch(type){
            case "v":
                arr = this.v;
                break;
            case "i":
                arr = this.i;
                break;
            case "o":
                arr = this.o;
                break;
            default:
                arr = [];
                break;
        }
        if (!arr[pos] || arr[pos] && !replace) arr[pos] = pointPool.newElement();
        arr[pos][0] = x;
        arr[pos][1] = y;
    };
    ShapePath.prototype.setTripleAt = function(vX, vY, oX, oY, iX, iY, pos, replace) {
        this.setXYAt(vX, vY, "v", pos, replace);
        this.setXYAt(oX, oY, "o", pos, replace);
        this.setXYAt(iX, iY, "i", pos, replace);
    };
    ShapePath.prototype.reverse = function() {
        var newPath = new ShapePath();
        newPath.setPathData(this.c, this._length);
        var vertices = this.v;
        var outPoints = this.o;
        var inPoints = this.i;
        var init = 0;
        if (this.c) {
            newPath.setTripleAt(vertices[0][0], vertices[0][1], inPoints[0][0], inPoints[0][1], outPoints[0][0], outPoints[0][1], 0, false);
            init = 1;
        }
        var cnt = this._length - 1;
        var len = this._length;
        var i;
        for(i = init; i < len; i += 1){
            newPath.setTripleAt(vertices[cnt][0], vertices[cnt][1], inPoints[cnt][0], inPoints[cnt][1], outPoints[cnt][0], outPoints[cnt][1], i, false);
            cnt -= 1;
        }
        return newPath;
    };
    var shapePool = function() {
        function create() {
            return new ShapePath();
        }
        function release(shapePath) {
            var len = shapePath._length;
            var i;
            for(i = 0; i < len; i += 1){
                pointPool.release(shapePath.v[i]);
                pointPool.release(shapePath.i[i]);
                pointPool.release(shapePath.o[i]);
                shapePath.v[i] = null;
                shapePath.i[i] = null;
                shapePath.o[i] = null;
            }
            shapePath._length = 0;
            shapePath.c = false;
        }
        function clone(shape) {
            var cloned = factory.newElement();
            var i;
            var len = shape._length === undefined ? shape.v.length : shape._length;
            cloned.setLength(len);
            cloned.c = shape.c;
            for(i = 0; i < len; i += 1)cloned.setTripleAt(shape.v[i][0], shape.v[i][1], shape.o[i][0], shape.o[i][1], shape.i[i][0], shape.i[i][1], i);
            return cloned;
        }
        var factory = poolFactory(4, create, release);
        factory.clone = clone;
        return factory;
    }();
    function ShapeCollection() {
        this._length = 0;
        this._maxLength = 4;
        this.shapes = createSizedArray(this._maxLength);
    }
    ShapeCollection.prototype.addShape = function(shapeData) {
        if (this._length === this._maxLength) {
            this.shapes = this.shapes.concat(createSizedArray(this._maxLength));
            this._maxLength *= 2;
        }
        this.shapes[this._length] = shapeData;
        this._length += 1;
    };
    ShapeCollection.prototype.releaseShapes = function() {
        var i;
        for(i = 0; i < this._length; i += 1)shapePool.release(this.shapes[i]);
        this._length = 0;
    };
    var shapeCollectionPool = function() {
        var ob = {
            newShapeCollection: newShapeCollection,
            release: release
        };
        var _length = 0;
        var _maxLength = 4;
        var pool = createSizedArray(_maxLength);
        function newShapeCollection() {
            var shapeCollection;
            if (_length) {
                _length -= 1;
                shapeCollection = pool[_length];
            } else shapeCollection = new ShapeCollection();
            return shapeCollection;
        }
        function release(shapeCollection) {
            var i;
            var len = shapeCollection._length;
            for(i = 0; i < len; i += 1)shapePool.release(shapeCollection.shapes[i]);
            shapeCollection._length = 0;
            if (_length === _maxLength) {
                pool = pooling["double"](pool);
                _maxLength *= 2;
            }
            pool[_length] = shapeCollection;
            _length += 1;
        }
        return ob;
    }();
    var ShapePropertyFactory = function() {
        var initFrame = -999999;
        function interpolateShape(frameNum, previousValue, caching) {
            var iterationIndex = caching.lastIndex;
            var keyPropS;
            var keyPropE;
            var isHold;
            var j;
            var k;
            var jLen;
            var kLen;
            var perc;
            var vertexValue;
            var kf = this.keyframes;
            if (frameNum < kf[0].t - this.offsetTime) {
                keyPropS = kf[0].s[0];
                isHold = true;
                iterationIndex = 0;
            } else if (frameNum >= kf[kf.length - 1].t - this.offsetTime) {
                keyPropS = kf[kf.length - 1].s ? kf[kf.length - 1].s[0] : kf[kf.length - 2].e[0];
                /* if(kf[kf.length - 1].s){
                  keyPropS = kf[kf.length - 1].s[0];
              }else{
                  keyPropS = kf[kf.length - 2].e[0];
              } */ isHold = true;
            } else {
                var i = iterationIndex;
                var len = kf.length - 1;
                var flag = true;
                var keyData;
                var nextKeyData;
                var keyframeMetadata;
                while(flag){
                    keyData = kf[i];
                    nextKeyData = kf[i + 1];
                    if (nextKeyData.t - this.offsetTime > frameNum) break;
                    if (i < len - 1) i += 1;
                    else flag = false;
                }
                keyframeMetadata = this.keyframesMetadata[i] || {};
                isHold = keyData.h === 1;
                iterationIndex = i;
                if (!isHold) {
                    if (frameNum >= nextKeyData.t - this.offsetTime) perc = 1;
                    else if (frameNum < keyData.t - this.offsetTime) perc = 0;
                    else {
                        var fnc;
                        if (keyframeMetadata.__fnct) fnc = keyframeMetadata.__fnct;
                        else {
                            fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y).get;
                            keyframeMetadata.__fnct = fnc;
                        }
                        perc = fnc((frameNum - (keyData.t - this.offsetTime)) / (nextKeyData.t - this.offsetTime - (keyData.t - this.offsetTime)));
                    }
                    keyPropE = nextKeyData.s ? nextKeyData.s[0] : keyData.e[0];
                }
                keyPropS = keyData.s[0];
            }
            jLen = previousValue._length;
            kLen = keyPropS.i[0].length;
            caching.lastIndex = iterationIndex;
            for(j = 0; j < jLen; j += 1)for(k = 0; k < kLen; k += 1){
                vertexValue = isHold ? keyPropS.i[j][k] : keyPropS.i[j][k] + (keyPropE.i[j][k] - keyPropS.i[j][k]) * perc;
                previousValue.i[j][k] = vertexValue;
                vertexValue = isHold ? keyPropS.o[j][k] : keyPropS.o[j][k] + (keyPropE.o[j][k] - keyPropS.o[j][k]) * perc;
                previousValue.o[j][k] = vertexValue;
                vertexValue = isHold ? keyPropS.v[j][k] : keyPropS.v[j][k] + (keyPropE.v[j][k] - keyPropS.v[j][k]) * perc;
                previousValue.v[j][k] = vertexValue;
            }
        }
        function interpolateShapeCurrentTime() {
            var frameNum = this.comp.renderedFrame - this.offsetTime;
            var initTime = this.keyframes[0].t - this.offsetTime;
            var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
            var lastFrame = this._caching.lastFrame;
            if (!(lastFrame !== initFrame && (lastFrame < initTime && frameNum < initTime || lastFrame > endTime && frameNum > endTime))) {
                /// /
                this._caching.lastIndex = lastFrame < frameNum ? this._caching.lastIndex : 0;
                this.interpolateShape(frameNum, this.pv, this._caching); /// /
            }
            this._caching.lastFrame = frameNum;
            return this.pv;
        }
        function resetShape() {
            this.paths = this.localShapeCollection;
        }
        function shapesEqual(shape1, shape2) {
            if (shape1._length !== shape2._length || shape1.c !== shape2.c) return false;
            var i;
            var len = shape1._length;
            for(i = 0; i < len; i += 1){
                if (shape1.v[i][0] !== shape2.v[i][0] || shape1.v[i][1] !== shape2.v[i][1] || shape1.o[i][0] !== shape2.o[i][0] || shape1.o[i][1] !== shape2.o[i][1] || shape1.i[i][0] !== shape2.i[i][0] || shape1.i[i][1] !== shape2.i[i][1]) return false;
            }
            return true;
        }
        function setVValue(newPath) {
            if (!shapesEqual(this.v, newPath)) {
                this.v = shapePool.clone(newPath);
                this.localShapeCollection.releaseShapes();
                this.localShapeCollection.addShape(this.v);
                this._mdf = true;
                this.paths = this.localShapeCollection;
            }
        }
        function processEffectsSequence() {
            if (this.elem.globalData.frameId === this.frameId) return;
            if (!this.effectsSequence.length) {
                this._mdf = false;
                return;
            }
            if (this.lock) {
                this.setVValue(this.pv);
                return;
            }
            this.lock = true;
            this._mdf = false;
            var finalValue;
            if (this.kf) finalValue = this.pv;
            else if (this.data.ks) finalValue = this.data.ks.k;
            else finalValue = this.data.pt.k;
            var i;
            var len = this.effectsSequence.length;
            for(i = 0; i < len; i += 1)finalValue = this.effectsSequence[i](finalValue);
            this.setVValue(finalValue);
            this.lock = false;
            this.frameId = this.elem.globalData.frameId;
        }
        function ShapeProperty(elem, data, type) {
            this.propType = "shape";
            this.comp = elem.comp;
            this.container = elem;
            this.elem = elem;
            this.data = data;
            this.k = false;
            this.kf = false;
            this._mdf = false;
            var pathData = type === 3 ? data.pt.k : data.ks.k;
            this.v = shapePool.clone(pathData);
            this.pv = shapePool.clone(this.v);
            this.localShapeCollection = shapeCollectionPool.newShapeCollection();
            this.paths = this.localShapeCollection;
            this.paths.addShape(this.v);
            this.reset = resetShape;
            this.effectsSequence = [];
        }
        function addEffect(effectFunction) {
            this.effectsSequence.push(effectFunction);
            this.container.addDynamicProperty(this);
        }
        ShapeProperty.prototype.interpolateShape = interpolateShape;
        ShapeProperty.prototype.getValue = processEffectsSequence;
        ShapeProperty.prototype.setVValue = setVValue;
        ShapeProperty.prototype.addEffect = addEffect;
        function KeyframedShapeProperty(elem, data, type) {
            this.propType = "shape";
            this.comp = elem.comp;
            this.elem = elem;
            this.container = elem;
            this.offsetTime = elem.data.st;
            this.keyframes = type === 3 ? data.pt.k : data.ks.k;
            this.keyframesMetadata = [];
            this.k = true;
            this.kf = true;
            var len = this.keyframes[0].s[0].i.length;
            this.v = shapePool.newElement();
            this.v.setPathData(this.keyframes[0].s[0].c, len);
            this.pv = shapePool.clone(this.v);
            this.localShapeCollection = shapeCollectionPool.newShapeCollection();
            this.paths = this.localShapeCollection;
            this.paths.addShape(this.v);
            this.lastFrame = initFrame;
            this.reset = resetShape;
            this._caching = {
                lastFrame: initFrame,
                lastIndex: 0
            };
            this.effectsSequence = [
                interpolateShapeCurrentTime.bind(this)
            ];
        }
        KeyframedShapeProperty.prototype.getValue = processEffectsSequence;
        KeyframedShapeProperty.prototype.interpolateShape = interpolateShape;
        KeyframedShapeProperty.prototype.setVValue = setVValue;
        KeyframedShapeProperty.prototype.addEffect = addEffect;
        var EllShapeProperty = function() {
            var cPoint = roundCorner;
            function EllShapePropertyFactory(elem, data) {
                this.v = shapePool.newElement();
                this.v.setPathData(true, 4);
                this.localShapeCollection = shapeCollectionPool.newShapeCollection();
                this.paths = this.localShapeCollection;
                this.localShapeCollection.addShape(this.v);
                this.d = data.d;
                this.elem = elem;
                this.comp = elem.comp;
                this.frameId = -1;
                this.initDynamicPropertyContainer(elem);
                this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
                this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);
                if (this.dynamicProperties.length) this.k = true;
                else {
                    this.k = false;
                    this.convertEllToPath();
                }
            }
            EllShapePropertyFactory.prototype = {
                reset: resetShape,
                getValue: function getValue() {
                    if (this.elem.globalData.frameId === this.frameId) return;
                    this.frameId = this.elem.globalData.frameId;
                    this.iterateDynamicProperties();
                    if (this._mdf) this.convertEllToPath();
                },
                convertEllToPath: function convertEllToPath() {
                    var p0 = this.p.v[0];
                    var p1 = this.p.v[1];
                    var s0 = this.s.v[0] / 2;
                    var s1 = this.s.v[1] / 2;
                    var _cw = this.d !== 3;
                    var _v = this.v;
                    _v.v[0][0] = p0;
                    _v.v[0][1] = p1 - s1;
                    _v.v[1][0] = _cw ? p0 + s0 : p0 - s0;
                    _v.v[1][1] = p1;
                    _v.v[2][0] = p0;
                    _v.v[2][1] = p1 + s1;
                    _v.v[3][0] = _cw ? p0 - s0 : p0 + s0;
                    _v.v[3][1] = p1;
                    _v.i[0][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
                    _v.i[0][1] = p1 - s1;
                    _v.i[1][0] = _cw ? p0 + s0 : p0 - s0;
                    _v.i[1][1] = p1 - s1 * cPoint;
                    _v.i[2][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
                    _v.i[2][1] = p1 + s1;
                    _v.i[3][0] = _cw ? p0 - s0 : p0 + s0;
                    _v.i[3][1] = p1 + s1 * cPoint;
                    _v.o[0][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
                    _v.o[0][1] = p1 - s1;
                    _v.o[1][0] = _cw ? p0 + s0 : p0 - s0;
                    _v.o[1][1] = p1 + s1 * cPoint;
                    _v.o[2][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
                    _v.o[2][1] = p1 + s1;
                    _v.o[3][0] = _cw ? p0 - s0 : p0 + s0;
                    _v.o[3][1] = p1 - s1 * cPoint;
                }
            };
            extendPrototype([
                DynamicPropertyContainer
            ], EllShapePropertyFactory);
            return EllShapePropertyFactory;
        }();
        var StarShapeProperty = function() {
            function StarShapePropertyFactory(elem, data) {
                this.v = shapePool.newElement();
                this.v.setPathData(true, 0);
                this.elem = elem;
                this.comp = elem.comp;
                this.data = data;
                this.frameId = -1;
                this.d = data.d;
                this.initDynamicPropertyContainer(elem);
                if (data.sy === 1) {
                    this.ir = PropertyFactory.getProp(elem, data.ir, 0, 0, this);
                    this.is = PropertyFactory.getProp(elem, data.is, 0, 0.01, this);
                    this.convertToPath = this.convertStarToPath;
                } else this.convertToPath = this.convertPolygonToPath;
                this.pt = PropertyFactory.getProp(elem, data.pt, 0, 0, this);
                this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
                this.r = PropertyFactory.getProp(elem, data.r, 0, degToRads, this);
                this.or = PropertyFactory.getProp(elem, data.or, 0, 0, this);
                this.os = PropertyFactory.getProp(elem, data.os, 0, 0.01, this);
                this.localShapeCollection = shapeCollectionPool.newShapeCollection();
                this.localShapeCollection.addShape(this.v);
                this.paths = this.localShapeCollection;
                if (this.dynamicProperties.length) this.k = true;
                else {
                    this.k = false;
                    this.convertToPath();
                }
            }
            StarShapePropertyFactory.prototype = {
                reset: resetShape,
                getValue: function getValue() {
                    if (this.elem.globalData.frameId === this.frameId) return;
                    this.frameId = this.elem.globalData.frameId;
                    this.iterateDynamicProperties();
                    if (this._mdf) this.convertToPath();
                },
                convertStarToPath: function convertStarToPath() {
                    var numPts = Math.floor(this.pt.v) * 2;
                    var angle = Math.PI * 2 / numPts;
                    /* this.v.v.length = numPts;
                  this.v.i.length = numPts;
                  this.v.o.length = numPts; */ var longFlag = true;
                    var longRad = this.or.v;
                    var shortRad = this.ir.v;
                    var longRound = this.os.v;
                    var shortRound = this.is.v;
                    var longPerimSegment = 2 * Math.PI * longRad / (numPts * 2);
                    var shortPerimSegment = 2 * Math.PI * shortRad / (numPts * 2);
                    var i;
                    var rad;
                    var roundness;
                    var perimSegment;
                    var currentAng = -Math.PI / 2;
                    currentAng += this.r.v;
                    var dir = this.data.d === 3 ? -1 : 1;
                    this.v._length = 0;
                    for(i = 0; i < numPts; i += 1){
                        rad = longFlag ? longRad : shortRad;
                        roundness = longFlag ? longRound : shortRound;
                        perimSegment = longFlag ? longPerimSegment : shortPerimSegment;
                        var x = rad * Math.cos(currentAng);
                        var y = rad * Math.sin(currentAng);
                        var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);
                        var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);
                        x += +this.p.v[0];
                        y += +this.p.v[1];
                        this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);
                        /* this.v.v[i] = [x,y];
                      this.v.i[i] = [x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir];
                      this.v.o[i] = [x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir];
                      this.v._length = numPts; */ longFlag = !longFlag;
                        currentAng += angle * dir;
                    }
                },
                convertPolygonToPath: function convertPolygonToPath() {
                    var numPts = Math.floor(this.pt.v);
                    var angle = Math.PI * 2 / numPts;
                    var rad = this.or.v;
                    var roundness = this.os.v;
                    var perimSegment = 2 * Math.PI * rad / (numPts * 4);
                    var i;
                    var currentAng = -Math.PI * 0.5;
                    var dir = this.data.d === 3 ? -1 : 1;
                    currentAng += this.r.v;
                    this.v._length = 0;
                    for(i = 0; i < numPts; i += 1){
                        var x = rad * Math.cos(currentAng);
                        var y = rad * Math.sin(currentAng);
                        var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);
                        var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);
                        x += +this.p.v[0];
                        y += +this.p.v[1];
                        this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);
                        currentAng += angle * dir;
                    }
                    this.paths.length = 0;
                    this.paths[0] = this.v;
                }
            };
            extendPrototype([
                DynamicPropertyContainer
            ], StarShapePropertyFactory);
            return StarShapePropertyFactory;
        }();
        var RectShapeProperty = function() {
            function RectShapePropertyFactory(elem, data) {
                this.v = shapePool.newElement();
                this.v.c = true;
                this.localShapeCollection = shapeCollectionPool.newShapeCollection();
                this.localShapeCollection.addShape(this.v);
                this.paths = this.localShapeCollection;
                this.elem = elem;
                this.comp = elem.comp;
                this.frameId = -1;
                this.d = data.d;
                this.initDynamicPropertyContainer(elem);
                this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
                this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);
                this.r = PropertyFactory.getProp(elem, data.r, 0, 0, this);
                if (this.dynamicProperties.length) this.k = true;
                else {
                    this.k = false;
                    this.convertRectToPath();
                }
            }
            RectShapePropertyFactory.prototype = {
                convertRectToPath: function convertRectToPath() {
                    var p0 = this.p.v[0];
                    var p1 = this.p.v[1];
                    var v0 = this.s.v[0] / 2;
                    var v1 = this.s.v[1] / 2;
                    var round = bmMin(v0, v1, this.r.v);
                    var cPoint = round * (1 - roundCorner);
                    this.v._length = 0;
                    if (this.d === 2 || this.d === 1) {
                        this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, 0, true);
                        this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, p0 + v0, p1 + v1 - round, 1, true);
                        if (round !== 0) {
                            this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, 2, true);
                            this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0 + round, p1 + v1, 3, true);
                            this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, 4, true);
                            this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1 + round, 5, true);
                            this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, 6, true);
                            this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, p0 + v0 - round, p1 - v1, 7, true);
                        } else {
                            this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0, p1 + v1, 2);
                            this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1, 3);
                        }
                    } else {
                        this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, p0 + v0, p1 - v1 + round, 0, true);
                        if (round !== 0) {
                            this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, 1, true);
                            this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0 + round, p1 - v1, 2, true);
                            this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, 3, true);
                            this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1 - round, 4, true);
                            this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, 5, true);
                            this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0 - round, p1 + v1, 6, true);
                            this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, 7, true);
                        } else {
                            this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0, p1 - v1, 1, true);
                            this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1, 2, true);
                            this.v.setTripleAt(p0 + v0, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0, p1 + v1, 3, true);
                        }
                    }
                },
                getValue: function getValue() {
                    if (this.elem.globalData.frameId === this.frameId) return;
                    this.frameId = this.elem.globalData.frameId;
                    this.iterateDynamicProperties();
                    if (this._mdf) this.convertRectToPath();
                },
                reset: resetShape
            };
            extendPrototype([
                DynamicPropertyContainer
            ], RectShapePropertyFactory);
            return RectShapePropertyFactory;
        }();
        function getShapeProp(elem, data, type) {
            var prop;
            if (type === 3 || type === 4) {
                var dataProp = type === 3 ? data.pt : data.ks;
                var keys = dataProp.k;
                if (keys.length) prop = new KeyframedShapeProperty(elem, data, type);
                else prop = new ShapeProperty(elem, data, type);
            } else if (type === 5) prop = new RectShapeProperty(elem, data);
            else if (type === 6) prop = new EllShapeProperty(elem, data);
            else if (type === 7) prop = new StarShapeProperty(elem, data);
            if (prop.k) elem.addDynamicProperty(prop);
            return prop;
        }
        function getConstructorFunction() {
            return ShapeProperty;
        }
        function getKeyframedConstructorFunction() {
            return KeyframedShapeProperty;
        }
        var ob = {};
        ob.getShapeProp = getShapeProp;
        ob.getConstructorFunction = getConstructorFunction;
        ob.getKeyframedConstructorFunction = getKeyframedConstructorFunction;
        return ob;
    }();
    /*!
   Transformation Matrix v2.0
   (c) Epistemex 2014-2015
   www.epistemex.com
   By Ken Fyrstenberg
   Contributions by leeoniya.
   License: MIT, header required.
   */ /**
   * 2D transformation matrix object initialized with identity matrix.
   *
   * The matrix can synchronize a canvas context by supplying the context
   * as an argument, or later apply current absolute transform to an
   * existing context.
   *
   * All values are handled as floating point values.
   *
   * @param {CanvasRenderingContext2D} [context] - Optional context to sync with Matrix
   * @prop {number} a - scale x
   * @prop {number} b - shear y
   * @prop {number} c - shear x
   * @prop {number} d - scale y
   * @prop {number} e - translate x
   * @prop {number} f - translate y
   * @prop {CanvasRenderingContext2D|null} [context=null] - set or get current canvas context
   * @constructor
   */ var Matrix = function() {
        var _cos = Math.cos;
        var _sin = Math.sin;
        var _tan = Math.tan;
        var _rnd = Math.round;
        function reset() {
            this.props[0] = 1;
            this.props[1] = 0;
            this.props[2] = 0;
            this.props[3] = 0;
            this.props[4] = 0;
            this.props[5] = 1;
            this.props[6] = 0;
            this.props[7] = 0;
            this.props[8] = 0;
            this.props[9] = 0;
            this.props[10] = 1;
            this.props[11] = 0;
            this.props[12] = 0;
            this.props[13] = 0;
            this.props[14] = 0;
            this.props[15] = 1;
            return this;
        }
        function rotate(angle) {
            if (angle === 0) return this;
            var mCos = _cos(angle);
            var mSin = _sin(angle);
            return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }
        function rotateX(angle) {
            if (angle === 0) return this;
            var mCos = _cos(angle);
            var mSin = _sin(angle);
            return this._t(1, 0, 0, 0, 0, mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1);
        }
        function rotateY(angle) {
            if (angle === 0) return this;
            var mCos = _cos(angle);
            var mSin = _sin(angle);
            return this._t(mCos, 0, mSin, 0, 0, 1, 0, 0, -mSin, 0, mCos, 0, 0, 0, 0, 1);
        }
        function rotateZ(angle) {
            if (angle === 0) return this;
            var mCos = _cos(angle);
            var mSin = _sin(angle);
            return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }
        function shear(sx, sy) {
            return this._t(1, sy, sx, 1, 0, 0);
        }
        function skew(ax, ay) {
            return this.shear(_tan(ax), _tan(ay));
        }
        function skewFromAxis(ax, angle) {
            var mCos = _cos(angle);
            var mSin = _sin(angle);
            return this._t(mCos, mSin, 0, 0, -mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, _tan(ax), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); // return this._t(mCos, mSin, -mSin, mCos, 0, 0)._t(1, 0, _tan(ax), 1, 0, 0)._t(mCos, -mSin, mSin, mCos, 0, 0);
        }
        function scale(sx, sy, sz) {
            if (!sz && sz !== 0) sz = 1;
            if (sx === 1 && sy === 1 && sz === 1) return this;
            return this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);
        }
        function setTransform(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
            this.props[0] = a;
            this.props[1] = b;
            this.props[2] = c;
            this.props[3] = d;
            this.props[4] = e;
            this.props[5] = f;
            this.props[6] = g;
            this.props[7] = h;
            this.props[8] = i;
            this.props[9] = j;
            this.props[10] = k;
            this.props[11] = l;
            this.props[12] = m;
            this.props[13] = n;
            this.props[14] = o;
            this.props[15] = p;
            return this;
        }
        function translate(tx, ty, tz) {
            tz = tz || 0;
            if (tx !== 0 || ty !== 0 || tz !== 0) return this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1);
            return this;
        }
        function transform(a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2) {
            var _p = this.props;
            if (a2 === 1 && b2 === 0 && c2 === 0 && d2 === 0 && e2 === 0 && f2 === 1 && g2 === 0 && h2 === 0 && i2 === 0 && j2 === 0 && k2 === 1 && l2 === 0) {
                // NOTE: commenting this condition because TurboFan deoptimizes code when present
                // if(m2 !== 0 || n2 !== 0 || o2 !== 0){
                _p[12] = _p[12] * a2 + _p[15] * m2;
                _p[13] = _p[13] * f2 + _p[15] * n2;
                _p[14] = _p[14] * k2 + _p[15] * o2;
                _p[15] *= p2; // }
                this._identityCalculated = false;
                return this;
            }
            var a1 = _p[0];
            var b1 = _p[1];
            var c1 = _p[2];
            var d1 = _p[3];
            var e1 = _p[4];
            var f1 = _p[5];
            var g1 = _p[6];
            var h1 = _p[7];
            var i1 = _p[8];
            var j1 = _p[9];
            var k1 = _p[10];
            var l1 = _p[11];
            var m1 = _p[12];
            var n1 = _p[13];
            var o1 = _p[14];
            var p1 = _p[15];
            /* matrix order (canvas compatible):
           * ace
           * bdf
           * 001
           */ _p[0] = a1 * a2 + b1 * e2 + c1 * i2 + d1 * m2;
            _p[1] = a1 * b2 + b1 * f2 + c1 * j2 + d1 * n2;
            _p[2] = a1 * c2 + b1 * g2 + c1 * k2 + d1 * o2;
            _p[3] = a1 * d2 + b1 * h2 + c1 * l2 + d1 * p2;
            _p[4] = e1 * a2 + f1 * e2 + g1 * i2 + h1 * m2;
            _p[5] = e1 * b2 + f1 * f2 + g1 * j2 + h1 * n2;
            _p[6] = e1 * c2 + f1 * g2 + g1 * k2 + h1 * o2;
            _p[7] = e1 * d2 + f1 * h2 + g1 * l2 + h1 * p2;
            _p[8] = i1 * a2 + j1 * e2 + k1 * i2 + l1 * m2;
            _p[9] = i1 * b2 + j1 * f2 + k1 * j2 + l1 * n2;
            _p[10] = i1 * c2 + j1 * g2 + k1 * k2 + l1 * o2;
            _p[11] = i1 * d2 + j1 * h2 + k1 * l2 + l1 * p2;
            _p[12] = m1 * a2 + n1 * e2 + o1 * i2 + p1 * m2;
            _p[13] = m1 * b2 + n1 * f2 + o1 * j2 + p1 * n2;
            _p[14] = m1 * c2 + n1 * g2 + o1 * k2 + p1 * o2;
            _p[15] = m1 * d2 + n1 * h2 + o1 * l2 + p1 * p2;
            this._identityCalculated = false;
            return this;
        }
        function isIdentity() {
            if (!this._identityCalculated) {
                this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1);
                this._identityCalculated = true;
            }
            return this._identity;
        }
        function equals(matr) {
            var i = 0;
            while(i < 16){
                if (matr.props[i] !== this.props[i]) return false;
                i += 1;
            }
            return true;
        }
        function clone(matr) {
            var i;
            for(i = 0; i < 16; i += 1)matr.props[i] = this.props[i];
            return matr;
        }
        function cloneFromProps(props) {
            var i;
            for(i = 0; i < 16; i += 1)this.props[i] = props[i];
        }
        function applyToPoint(x, y, z) {
            return {
                x: x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],
                y: x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],
                z: x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]
            };
        /* return {
           x: x * me.a + y * me.c + me.e,
           y: x * me.b + y * me.d + me.f
           }; */ }
        function applyToX(x, y, z) {
            return x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12];
        }
        function applyToY(x, y, z) {
            return x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13];
        }
        function applyToZ(x, y, z) {
            return x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14];
        }
        function getInverseMatrix() {
            var determinant = this.props[0] * this.props[5] - this.props[1] * this.props[4];
            var a = this.props[5] / determinant;
            var b = -this.props[1] / determinant;
            var c = -this.props[4] / determinant;
            var d = this.props[0] / determinant;
            var e = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / determinant;
            var f = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / determinant;
            var inverseMatrix = new Matrix();
            inverseMatrix.props[0] = a;
            inverseMatrix.props[1] = b;
            inverseMatrix.props[4] = c;
            inverseMatrix.props[5] = d;
            inverseMatrix.props[12] = e;
            inverseMatrix.props[13] = f;
            return inverseMatrix;
        }
        function inversePoint(pt) {
            var inverseMatrix = this.getInverseMatrix();
            return inverseMatrix.applyToPointArray(pt[0], pt[1], pt[2] || 0);
        }
        function inversePoints(pts) {
            var i;
            var len = pts.length;
            var retPts = [];
            for(i = 0; i < len; i += 1)retPts[i] = inversePoint(pts[i]);
            return retPts;
        }
        function applyToTriplePoints(pt1, pt2, pt3) {
            var arr = createTypedArray("float32", 6);
            if (this.isIdentity()) {
                arr[0] = pt1[0];
                arr[1] = pt1[1];
                arr[2] = pt2[0];
                arr[3] = pt2[1];
                arr[4] = pt3[0];
                arr[5] = pt3[1];
            } else {
                var p0 = this.props[0];
                var p1 = this.props[1];
                var p4 = this.props[4];
                var p5 = this.props[5];
                var p12 = this.props[12];
                var p13 = this.props[13];
                arr[0] = pt1[0] * p0 + pt1[1] * p4 + p12;
                arr[1] = pt1[0] * p1 + pt1[1] * p5 + p13;
                arr[2] = pt2[0] * p0 + pt2[1] * p4 + p12;
                arr[3] = pt2[0] * p1 + pt2[1] * p5 + p13;
                arr[4] = pt3[0] * p0 + pt3[1] * p4 + p12;
                arr[5] = pt3[0] * p1 + pt3[1] * p5 + p13;
            }
            return arr;
        }
        function applyToPointArray(x, y, z) {
            var arr;
            if (this.isIdentity()) arr = [
                x,
                y,
                z
            ];
            else arr = [
                x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],
                x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],
                x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]
            ];
            return arr;
        }
        function applyToPointStringified(x, y) {
            if (this.isIdentity()) return x + "," + y;
            var _p = this.props;
            return Math.round((x * _p[0] + y * _p[4] + _p[12]) * 100) / 100 + "," + Math.round((x * _p[1] + y * _p[5] + _p[13]) * 100) / 100;
        }
        function toCSS() {
            // Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.
            /* if(this.isIdentity()) {
              return '';
          } */ var i = 0;
            var props = this.props;
            var cssValue = "matrix3d(";
            var v = 10000;
            while(i < 16){
                cssValue += _rnd(props[i] * v) / v;
                cssValue += i === 15 ? ")" : ",";
                i += 1;
            }
            return cssValue;
        }
        function roundMatrixProperty(val) {
            var v = 10000;
            if (val < 0.000001 && val > 0 || val > -0.000001 && val < 0) return _rnd(val * v) / v;
            return val;
        }
        function to2dCSS() {
            // Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.
            /* if(this.isIdentity()) {
              return '';
          } */ var props = this.props;
            var _a = roundMatrixProperty(props[0]);
            var _b = roundMatrixProperty(props[1]);
            var _c = roundMatrixProperty(props[4]);
            var _d = roundMatrixProperty(props[5]);
            var _e = roundMatrixProperty(props[12]);
            var _f = roundMatrixProperty(props[13]);
            return "matrix(" + _a + "," + _b + "," + _c + "," + _d + "," + _e + "," + _f + ")";
        }
        return function() {
            this.reset = reset;
            this.rotate = rotate;
            this.rotateX = rotateX;
            this.rotateY = rotateY;
            this.rotateZ = rotateZ;
            this.skew = skew;
            this.skewFromAxis = skewFromAxis;
            this.shear = shear;
            this.scale = scale;
            this.setTransform = setTransform;
            this.translate = translate;
            this.transform = transform;
            this.applyToPoint = applyToPoint;
            this.applyToX = applyToX;
            this.applyToY = applyToY;
            this.applyToZ = applyToZ;
            this.applyToPointArray = applyToPointArray;
            this.applyToTriplePoints = applyToTriplePoints;
            this.applyToPointStringified = applyToPointStringified;
            this.toCSS = toCSS;
            this.to2dCSS = to2dCSS;
            this.clone = clone;
            this.cloneFromProps = cloneFromProps;
            this.equals = equals;
            this.inversePoints = inversePoints;
            this.inversePoint = inversePoint;
            this.getInverseMatrix = getInverseMatrix;
            this._t = this.transform;
            this.isIdentity = isIdentity;
            this._identity = true;
            this._identityCalculated = false;
            this.props = createTypedArray("float32", 16);
            this.reset();
        };
    }();
    function _typeof$3(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof$3 = function _typeof(obj) {
            return typeof obj;
        };
        else _typeof$3 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
        return _typeof$3(obj);
    }
    var lottie = {};
    var standalone = "__[STANDALONE]__";
    var animationData = "__[ANIMATIONDATA]__";
    var renderer = "";
    function setLocation(href) {
        setLocationHref(href);
    }
    function searchAnimations() {
        if (standalone === true) animationManager.searchAnimations(animationData, standalone, renderer);
        else animationManager.searchAnimations();
    }
    function setSubframeRendering(flag) {
        setSubframeEnabled(flag);
    }
    function setPrefix(prefix) {
        setIdPrefix(prefix);
    }
    function loadAnimation(params) {
        if (standalone === true) params.animationData = JSON.parse(animationData);
        return animationManager.loadAnimation(params);
    }
    function setQuality(value) {
        if (typeof value === "string") switch(value){
            case "high":
                setDefaultCurveSegments(200);
                break;
            default:
            case "medium":
                setDefaultCurveSegments(50);
                break;
            case "low":
                setDefaultCurveSegments(10);
                break;
        }
        else if (!isNaN(value) && value > 1) setDefaultCurveSegments(value);
        if (getDefaultCurveSegments() >= 50) roundValues(false);
        else roundValues(true);
    }
    function inBrowser() {
        return typeof navigator !== "undefined";
    }
    function installPlugin(type, plugin) {
        if (type === "expressions") setExpressionsPlugin(plugin);
    }
    function getFactory(name) {
        switch(name){
            case "propertyFactory":
                return PropertyFactory;
            case "shapePropertyFactory":
                return ShapePropertyFactory;
            case "matrix":
                return Matrix;
            default:
                return null;
        }
    }
    lottie.play = animationManager.play;
    lottie.pause = animationManager.pause;
    lottie.setLocationHref = setLocation;
    lottie.togglePause = animationManager.togglePause;
    lottie.setSpeed = animationManager.setSpeed;
    lottie.setDirection = animationManager.setDirection;
    lottie.stop = animationManager.stop;
    lottie.searchAnimations = searchAnimations;
    lottie.registerAnimation = animationManager.registerAnimation;
    lottie.loadAnimation = loadAnimation;
    lottie.setSubframeRendering = setSubframeRendering;
    lottie.resize = animationManager.resize; // lottie.start = start;
    lottie.goToAndStop = animationManager.goToAndStop;
    lottie.destroy = animationManager.destroy;
    lottie.setQuality = setQuality;
    lottie.inBrowser = inBrowser;
    lottie.installPlugin = installPlugin;
    lottie.freeze = animationManager.freeze;
    lottie.unfreeze = animationManager.unfreeze;
    lottie.setVolume = animationManager.setVolume;
    lottie.mute = animationManager.mute;
    lottie.unmute = animationManager.unmute;
    lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations;
    lottie.useWebWorker = setWebWorker;
    lottie.setIDPrefix = setPrefix;
    lottie.__getFactory = getFactory;
    lottie.version = "5.9.6";
    function checkReady() {
        if (document.readyState === "complete") {
            clearInterval(readyStateCheckInterval);
            searchAnimations();
        }
    }
    function getQueryVariable(variable) {
        var vars = queryString.split("&");
        for(var i = 0; i < vars.length; i += 1){
            var pair = vars[i].split("=");
            if (decodeURIComponent(pair[0]) == variable) // eslint-disable-line eqeqeq
            return decodeURIComponent(pair[1]);
        }
        return null;
    }
    var queryString = "";
    if (standalone) {
        var scripts = document.getElementsByTagName("script");
        var index = scripts.length - 1;
        var myScript = scripts[index] || {
            src: ""
        };
        queryString = myScript.src ? myScript.src.replace(/^[^\?]+\??/, "") : ""; // eslint-disable-line no-useless-escape
        renderer = getQueryVariable("renderer");
    }
    var readyStateCheckInterval = setInterval(checkReady, 100); // this adds bodymovin to the window object for backwards compatibility
    try {
        if (!(_typeof$3(exports) === "object" && true) && !(typeof define === "function" && define.amd // eslint-disable-line no-undef
        )) window.bodymovin = lottie;
    } catch (err) {}
    var ShapeModifiers = function() {
        var ob = {};
        var modifiers = {};
        ob.registerModifier = registerModifier;
        ob.getModifier = getModifier;
        function registerModifier(nm, factory) {
            if (!modifiers[nm]) modifiers[nm] = factory;
        }
        function getModifier(nm, elem, data) {
            return new modifiers[nm](elem, data);
        }
        return ob;
    }();
    function ShapeModifier() {}
    ShapeModifier.prototype.initModifierProperties = function() {};
    ShapeModifier.prototype.addShapeToModifier = function() {};
    ShapeModifier.prototype.addShape = function(data) {
        if (!this.closed) {
            // Adding shape to dynamic properties. It covers the case where a shape has no effects applied, to reset it's _mdf state on every tick.
            data.sh.container.addDynamicProperty(data.sh);
            var shapeData = {
                shape: data.sh,
                data: data,
                localShapeCollection: shapeCollectionPool.newShapeCollection()
            };
            this.shapes.push(shapeData);
            this.addShapeToModifier(shapeData);
            if (this._isAnimated) data.setAsAnimated();
        }
    };
    ShapeModifier.prototype.init = function(elem, data) {
        this.shapes = [];
        this.elem = elem;
        this.initDynamicPropertyContainer(elem);
        this.initModifierProperties(elem, data);
        this.frameId = initialDefaultFrame;
        this.closed = false;
        this.k = false;
        if (this.dynamicProperties.length) this.k = true;
        else this.getValue(true);
    };
    ShapeModifier.prototype.processKeys = function() {
        if (this.elem.globalData.frameId === this.frameId) return;
        this.frameId = this.elem.globalData.frameId;
        this.iterateDynamicProperties();
    };
    extendPrototype([
        DynamicPropertyContainer
    ], ShapeModifier);
    function TrimModifier() {}
    extendPrototype([
        ShapeModifier
    ], TrimModifier);
    TrimModifier.prototype.initModifierProperties = function(elem, data) {
        this.s = PropertyFactory.getProp(elem, data.s, 0, 0.01, this);
        this.e = PropertyFactory.getProp(elem, data.e, 0, 0.01, this);
        this.o = PropertyFactory.getProp(elem, data.o, 0, 0, this);
        this.sValue = 0;
        this.eValue = 0;
        this.getValue = this.processKeys;
        this.m = data.m;
        this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length;
    };
    TrimModifier.prototype.addShapeToModifier = function(shapeData) {
        shapeData.pathsData = [];
    };
    TrimModifier.prototype.calculateShapeEdges = function(s, e, shapeLength, addedLength, totalModifierLength) {
        var segments = [];
        if (e <= 1) segments.push({
            s: s,
            e: e
        });
        else if (s >= 1) segments.push({
            s: s - 1,
            e: e - 1
        });
        else {
            segments.push({
                s: s,
                e: 1
            });
            segments.push({
                s: 0,
                e: e - 1
            });
        }
        var shapeSegments = [];
        var i;
        var len = segments.length;
        var segmentOb;
        for(i = 0; i < len; i += 1){
            segmentOb = segments[i];
            if (!(segmentOb.e * totalModifierLength < addedLength || segmentOb.s * totalModifierLength > addedLength + shapeLength)) {
                var shapeS;
                var shapeE;
                if (segmentOb.s * totalModifierLength <= addedLength) shapeS = 0;
                else shapeS = (segmentOb.s * totalModifierLength - addedLength) / shapeLength;
                if (segmentOb.e * totalModifierLength >= addedLength + shapeLength) shapeE = 1;
                else shapeE = (segmentOb.e * totalModifierLength - addedLength) / shapeLength;
                shapeSegments.push([
                    shapeS,
                    shapeE
                ]);
            }
        }
        if (!shapeSegments.length) shapeSegments.push([
            0,
            0
        ]);
        return shapeSegments;
    };
    TrimModifier.prototype.releasePathsData = function(pathsData) {
        var i;
        var len = pathsData.length;
        for(i = 0; i < len; i += 1)segmentsLengthPool.release(pathsData[i]);
        pathsData.length = 0;
        return pathsData;
    };
    TrimModifier.prototype.processShapes = function(_isFirstFrame) {
        var s;
        var e;
        if (this._mdf || _isFirstFrame) {
            var o = this.o.v % 360 / 360;
            if (o < 0) o += 1;
            if (this.s.v > 1) s = 1 + o;
            else if (this.s.v < 0) s = 0 + o;
            else s = this.s.v + o;
            if (this.e.v > 1) e = 1 + o;
            else if (this.e.v < 0) e = 0 + o;
            else e = this.e.v + o;
            if (s > e) {
                var _s = s;
                s = e;
                e = _s;
            }
            s = Math.round(s * 10000) * 0.0001;
            e = Math.round(e * 10000) * 0.0001;
            this.sValue = s;
            this.eValue = e;
        } else {
            s = this.sValue;
            e = this.eValue;
        }
        var shapePaths;
        var i;
        var len = this.shapes.length;
        var j;
        var jLen;
        var pathsData;
        var pathData;
        var totalShapeLength;
        var totalModifierLength = 0;
        if (e === s) for(i = 0; i < len; i += 1){
            this.shapes[i].localShapeCollection.releaseShapes();
            this.shapes[i].shape._mdf = true;
            this.shapes[i].shape.paths = this.shapes[i].localShapeCollection;
            if (this._mdf) this.shapes[i].pathsData.length = 0;
        }
        else if (!(e === 1 && s === 0 || e === 0 && s === 1)) {
            var segments = [];
            var shapeData;
            var localShapeCollection;
            for(i = 0; i < len; i += 1){
                shapeData = this.shapes[i]; // if shape hasn't changed and trim properties haven't changed, cached previous path can be used
                if (!shapeData.shape._mdf && !this._mdf && !_isFirstFrame && this.m !== 2) shapeData.shape.paths = shapeData.localShapeCollection;
                else {
                    shapePaths = shapeData.shape.paths;
                    jLen = shapePaths._length;
                    totalShapeLength = 0;
                    if (!shapeData.shape._mdf && shapeData.pathsData.length) totalShapeLength = shapeData.totalShapeLength;
                    else {
                        pathsData = this.releasePathsData(shapeData.pathsData);
                        for(j = 0; j < jLen; j += 1){
                            pathData = bez.getSegmentsLength(shapePaths.shapes[j]);
                            pathsData.push(pathData);
                            totalShapeLength += pathData.totalLength;
                        }
                        shapeData.totalShapeLength = totalShapeLength;
                        shapeData.pathsData = pathsData;
                    }
                    totalModifierLength += totalShapeLength;
                    shapeData.shape._mdf = true;
                }
            }
            var shapeS = s;
            var shapeE = e;
            var addedLength = 0;
            var edges;
            for(i = len - 1; i >= 0; i -= 1){
                shapeData = this.shapes[i];
                if (shapeData.shape._mdf) {
                    localShapeCollection = shapeData.localShapeCollection;
                    localShapeCollection.releaseShapes(); // if m === 2 means paths are trimmed individually so edges need to be found for this specific shape relative to whoel group
                    if (this.m === 2 && len > 1) {
                        edges = this.calculateShapeEdges(s, e, shapeData.totalShapeLength, addedLength, totalModifierLength);
                        addedLength += shapeData.totalShapeLength;
                    } else edges = [
                        [
                            shapeS,
                            shapeE
                        ]
                    ];
                    jLen = edges.length;
                    for(j = 0; j < jLen; j += 1){
                        shapeS = edges[j][0];
                        shapeE = edges[j][1];
                        segments.length = 0;
                        if (shapeE <= 1) segments.push({
                            s: shapeData.totalShapeLength * shapeS,
                            e: shapeData.totalShapeLength * shapeE
                        });
                        else if (shapeS >= 1) segments.push({
                            s: shapeData.totalShapeLength * (shapeS - 1),
                            e: shapeData.totalShapeLength * (shapeE - 1)
                        });
                        else {
                            segments.push({
                                s: shapeData.totalShapeLength * shapeS,
                                e: shapeData.totalShapeLength
                            });
                            segments.push({
                                s: 0,
                                e: shapeData.totalShapeLength * (shapeE - 1)
                            });
                        }
                        var newShapesData = this.addShapes(shapeData, segments[0]);
                        if (segments[0].s !== segments[0].e) {
                            if (segments.length > 1) {
                                var lastShapeInCollection = shapeData.shape.paths.shapes[shapeData.shape.paths._length - 1];
                                if (lastShapeInCollection.c) {
                                    var lastShape = newShapesData.pop();
                                    this.addPaths(newShapesData, localShapeCollection);
                                    newShapesData = this.addShapes(shapeData, segments[1], lastShape);
                                } else {
                                    this.addPaths(newShapesData, localShapeCollection);
                                    newShapesData = this.addShapes(shapeData, segments[1]);
                                }
                            }
                            this.addPaths(newShapesData, localShapeCollection);
                        }
                    }
                    shapeData.shape.paths = localShapeCollection;
                }
            }
        } else if (this._mdf) for(i = 0; i < len; i += 1){
            // Releasign Trim Cached paths data when no trim applied in case shapes are modified inbetween.
            // Don't remove this even if it's losing cached info.
            this.shapes[i].pathsData.length = 0;
            this.shapes[i].shape._mdf = true;
        }
    };
    TrimModifier.prototype.addPaths = function(newPaths, localShapeCollection) {
        var i;
        var len = newPaths.length;
        for(i = 0; i < len; i += 1)localShapeCollection.addShape(newPaths[i]);
    };
    TrimModifier.prototype.addSegment = function(pt1, pt2, pt3, pt4, shapePath, pos, newShape) {
        shapePath.setXYAt(pt2[0], pt2[1], "o", pos);
        shapePath.setXYAt(pt3[0], pt3[1], "i", pos + 1);
        if (newShape) shapePath.setXYAt(pt1[0], pt1[1], "v", pos);
        shapePath.setXYAt(pt4[0], pt4[1], "v", pos + 1);
    };
    TrimModifier.prototype.addSegmentFromArray = function(points, shapePath, pos, newShape) {
        shapePath.setXYAt(points[1], points[5], "o", pos);
        shapePath.setXYAt(points[2], points[6], "i", pos + 1);
        if (newShape) shapePath.setXYAt(points[0], points[4], "v", pos);
        shapePath.setXYAt(points[3], points[7], "v", pos + 1);
    };
    TrimModifier.prototype.addShapes = function(shapeData, shapeSegment, shapePath) {
        var pathsData = shapeData.pathsData;
        var shapePaths = shapeData.shape.paths.shapes;
        var i;
        var len = shapeData.shape.paths._length;
        var j;
        var jLen;
        var addedLength = 0;
        var currentLengthData;
        var segmentCount;
        var lengths;
        var segment;
        var shapes = [];
        var initPos;
        var newShape = true;
        if (!shapePath) {
            shapePath = shapePool.newElement();
            segmentCount = 0;
            initPos = 0;
        } else {
            segmentCount = shapePath._length;
            initPos = shapePath._length;
        }
        shapes.push(shapePath);
        for(i = 0; i < len; i += 1){
            lengths = pathsData[i].lengths;
            shapePath.c = shapePaths[i].c;
            jLen = shapePaths[i].c ? lengths.length : lengths.length + 1;
            for(j = 1; j < jLen; j += 1){
                currentLengthData = lengths[j - 1];
                if (addedLength + currentLengthData.addedLength < shapeSegment.s) {
                    addedLength += currentLengthData.addedLength;
                    shapePath.c = false;
                } else if (addedLength > shapeSegment.e) {
                    shapePath.c = false;
                    break;
                } else {
                    if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + currentLengthData.addedLength) {
                        this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[j], shapePaths[i].v[j], shapePath, segmentCount, newShape);
                        newShape = false;
                    } else {
                        segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[j], shapePaths[i].o[j - 1], shapePaths[i].i[j], (shapeSegment.s - addedLength) / currentLengthData.addedLength, (shapeSegment.e - addedLength) / currentLengthData.addedLength, lengths[j - 1]);
                        this.addSegmentFromArray(segment, shapePath, segmentCount, newShape); // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);
                        newShape = false;
                        shapePath.c = false;
                    }
                    addedLength += currentLengthData.addedLength;
                    segmentCount += 1;
                }
            }
            if (shapePaths[i].c && lengths.length) {
                currentLengthData = lengths[j - 1];
                if (addedLength <= shapeSegment.e) {
                    var segmentLength = lengths[j - 1].addedLength;
                    if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + segmentLength) {
                        this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[0], shapePaths[i].v[0], shapePath, segmentCount, newShape);
                        newShape = false;
                    } else {
                        segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[0], shapePaths[i].o[j - 1], shapePaths[i].i[0], (shapeSegment.s - addedLength) / segmentLength, (shapeSegment.e - addedLength) / segmentLength, lengths[j - 1]);
                        this.addSegmentFromArray(segment, shapePath, segmentCount, newShape); // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);
                        newShape = false;
                        shapePath.c = false;
                    }
                } else shapePath.c = false;
                addedLength += currentLengthData.addedLength;
                segmentCount += 1;
            }
            if (shapePath._length) {
                shapePath.setXYAt(shapePath.v[initPos][0], shapePath.v[initPos][1], "i", initPos);
                shapePath.setXYAt(shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1], "o", shapePath._length - 1);
            }
            if (addedLength > shapeSegment.e) break;
            if (i < len - 1) {
                shapePath = shapePool.newElement();
                newShape = true;
                shapes.push(shapePath);
                segmentCount = 0;
            }
        }
        return shapes;
    };
    function PuckerAndBloatModifier() {}
    extendPrototype([
        ShapeModifier
    ], PuckerAndBloatModifier);
    PuckerAndBloatModifier.prototype.initModifierProperties = function(elem, data) {
        this.getValue = this.processKeys;
        this.amount = PropertyFactory.getProp(elem, data.a, 0, null, this);
        this._isAnimated = !!this.amount.effectsSequence.length;
    };
    PuckerAndBloatModifier.prototype.processPath = function(path, amount) {
        var percent = amount / 100;
        var centerPoint = [
            0,
            0
        ];
        var pathLength = path._length;
        var i = 0;
        for(i = 0; i < pathLength; i += 1){
            centerPoint[0] += path.v[i][0];
            centerPoint[1] += path.v[i][1];
        }
        centerPoint[0] /= pathLength;
        centerPoint[1] /= pathLength;
        var clonedPath = shapePool.newElement();
        clonedPath.c = path.c;
        var vX;
        var vY;
        var oX;
        var oY;
        var iX;
        var iY;
        for(i = 0; i < pathLength; i += 1){
            vX = path.v[i][0] + (centerPoint[0] - path.v[i][0]) * percent;
            vY = path.v[i][1] + (centerPoint[1] - path.v[i][1]) * percent;
            oX = path.o[i][0] + (centerPoint[0] - path.o[i][0]) * -percent;
            oY = path.o[i][1] + (centerPoint[1] - path.o[i][1]) * -percent;
            iX = path.i[i][0] + (centerPoint[0] - path.i[i][0]) * -percent;
            iY = path.i[i][1] + (centerPoint[1] - path.i[i][1]) * -percent;
            clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, i);
        }
        return clonedPath;
    };
    PuckerAndBloatModifier.prototype.processShapes = function(_isFirstFrame) {
        var shapePaths;
        var i;
        var len = this.shapes.length;
        var j;
        var jLen;
        var amount = this.amount.v;
        if (amount !== 0) {
            var shapeData;
            var localShapeCollection;
            for(i = 0; i < len; i += 1){
                shapeData = this.shapes[i];
                localShapeCollection = shapeData.localShapeCollection;
                if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
                    localShapeCollection.releaseShapes();
                    shapeData.shape._mdf = true;
                    shapePaths = shapeData.shape.paths.shapes;
                    jLen = shapeData.shape.paths._length;
                    for(j = 0; j < jLen; j += 1)localShapeCollection.addShape(this.processPath(shapePaths[j], amount));
                }
                shapeData.shape.paths = shapeData.localShapeCollection;
            }
        }
        if (!this.dynamicProperties.length) this._mdf = false;
    };
    var TransformPropertyFactory = function() {
        var defaultVector = [
            0,
            0
        ];
        function applyToMatrix(mat) {
            var _mdf = this._mdf;
            this.iterateDynamicProperties();
            this._mdf = this._mdf || _mdf;
            if (this.a) mat.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
            if (this.s) mat.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
            if (this.sk) mat.skewFromAxis(-this.sk.v, this.sa.v);
            if (this.r) mat.rotate(-this.r.v);
            else mat.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
            if (this.data.p.s) {
                if (this.data.p.z) mat.translate(this.px.v, this.py.v, -this.pz.v);
                else mat.translate(this.px.v, this.py.v, 0);
            } else mat.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
        }
        function processKeys(forceRender) {
            if (this.elem.globalData.frameId === this.frameId) return;
            if (this._isDirty) {
                this.precalculateMatrix();
                this._isDirty = false;
            }
            this.iterateDynamicProperties();
            if (this._mdf || forceRender) {
                var frameRate;
                this.v.cloneFromProps(this.pre.props);
                if (this.appliedTransformations < 1) this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
                if (this.appliedTransformations < 2) this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
                if (this.sk && this.appliedTransformations < 3) this.v.skewFromAxis(-this.sk.v, this.sa.v);
                if (this.r && this.appliedTransformations < 4) this.v.rotate(-this.r.v);
                else if (!this.r && this.appliedTransformations < 4) this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
                if (this.autoOriented) {
                    var v1;
                    var v2;
                    frameRate = this.elem.globalData.frameRate;
                    if (this.p && this.p.keyframes && this.p.getValueAtTime) {
                        if (this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t) {
                            v1 = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / frameRate, 0);
                            v2 = this.p.getValueAtTime(this.p.keyframes[0].t / frameRate, 0);
                        } else if (this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t) {
                            v1 = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / frameRate, 0);
                            v2 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.05) / frameRate, 0);
                        } else {
                            v1 = this.p.pv;
                            v2 = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - 0.01) / frameRate, this.p.offsetTime);
                        }
                    } else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
                        v1 = [];
                        v2 = [];
                        var px = this.px;
                        var py = this.py;
                        if (px._caching.lastFrame + px.offsetTime <= px.keyframes[0].t) {
                            v1[0] = px.getValueAtTime((px.keyframes[0].t + 0.01) / frameRate, 0);
                            v1[1] = py.getValueAtTime((py.keyframes[0].t + 0.01) / frameRate, 0);
                            v2[0] = px.getValueAtTime(px.keyframes[0].t / frameRate, 0);
                            v2[1] = py.getValueAtTime(py.keyframes[0].t / frameRate, 0);
                        } else if (px._caching.lastFrame + px.offsetTime >= px.keyframes[px.keyframes.length - 1].t) {
                            v1[0] = px.getValueAtTime(px.keyframes[px.keyframes.length - 1].t / frameRate, 0);
                            v1[1] = py.getValueAtTime(py.keyframes[py.keyframes.length - 1].t / frameRate, 0);
                            v2[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t - 0.01) / frameRate, 0);
                            v2[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t - 0.01) / frameRate, 0);
                        } else {
                            v1 = [
                                px.pv,
                                py.pv
                            ];
                            v2[0] = px.getValueAtTime((px._caching.lastFrame + px.offsetTime - 0.01) / frameRate, px.offsetTime);
                            v2[1] = py.getValueAtTime((py._caching.lastFrame + py.offsetTime - 0.01) / frameRate, py.offsetTime);
                        }
                    } else {
                        v2 = defaultVector;
                        v1 = v2;
                    }
                    this.v.rotate(-Math.atan2(v1[1] - v2[1], v1[0] - v2[0]));
                }
                if (this.data.p && this.data.p.s) {
                    if (this.data.p.z) this.v.translate(this.px.v, this.py.v, -this.pz.v);
                    else this.v.translate(this.px.v, this.py.v, 0);
                } else this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
            }
            this.frameId = this.elem.globalData.frameId;
        }
        function precalculateMatrix() {
            if (!this.a.k) {
                this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
                this.appliedTransformations = 1;
            } else return;
            if (!this.s.effectsSequence.length) {
                this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
                this.appliedTransformations = 2;
            } else return;
            if (this.sk) {
                if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) {
                    this.pre.skewFromAxis(-this.sk.v, this.sa.v);
                    this.appliedTransformations = 3;
                } else return;
            }
            if (this.r) {
                if (!this.r.effectsSequence.length) {
                    this.pre.rotate(-this.r.v);
                    this.appliedTransformations = 4;
                }
            } else if (!this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length) {
                this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
                this.appliedTransformations = 4;
            }
        }
        function autoOrient() {
        // var prevP = this.getValueAtTime();
        }
        function addDynamicProperty(prop) {
            this._addDynamicProperty(prop);
            this.elem.addDynamicProperty(prop);
            this._isDirty = true;
        }
        function TransformProperty(elem, data, container) {
            this.elem = elem;
            this.frameId = -1;
            this.propType = "transform";
            this.data = data;
            this.v = new Matrix(); // Precalculated matrix with non animated properties
            this.pre = new Matrix();
            this.appliedTransformations = 0;
            this.initDynamicPropertyContainer(container || elem);
            if (data.p && data.p.s) {
                this.px = PropertyFactory.getProp(elem, data.p.x, 0, 0, this);
                this.py = PropertyFactory.getProp(elem, data.p.y, 0, 0, this);
                if (data.p.z) this.pz = PropertyFactory.getProp(elem, data.p.z, 0, 0, this);
            } else this.p = PropertyFactory.getProp(elem, data.p || {
                k: [
                    0,
                    0,
                    0
                ]
            }, 1, 0, this);
            if (data.rx) {
                this.rx = PropertyFactory.getProp(elem, data.rx, 0, degToRads, this);
                this.ry = PropertyFactory.getProp(elem, data.ry, 0, degToRads, this);
                this.rz = PropertyFactory.getProp(elem, data.rz, 0, degToRads, this);
                if (data.or.k[0].ti) {
                    var i;
                    var len = data.or.k.length;
                    for(i = 0; i < len; i += 1){
                        data.or.k[i].to = null;
                        data.or.k[i].ti = null;
                    }
                }
                this.or = PropertyFactory.getProp(elem, data.or, 1, degToRads, this); // sh Indicates it needs to be capped between -180 and 180
                this.or.sh = true;
            } else this.r = PropertyFactory.getProp(elem, data.r || {
                k: 0
            }, 0, degToRads, this);
            if (data.sk) {
                this.sk = PropertyFactory.getProp(elem, data.sk, 0, degToRads, this);
                this.sa = PropertyFactory.getProp(elem, data.sa, 0, degToRads, this);
            }
            this.a = PropertyFactory.getProp(elem, data.a || {
                k: [
                    0,
                    0,
                    0
                ]
            }, 1, 0, this);
            this.s = PropertyFactory.getProp(elem, data.s || {
                k: [
                    100,
                    100,
                    100
                ]
            }, 1, 0.01, this); // Opacity is not part of the transform properties, that's why it won't use this.dynamicProperties. That way transforms won't get updated if opacity changes.
            if (data.o) this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, elem);
            else this.o = {
                _mdf: false,
                v: 1
            };
            this._isDirty = true;
            if (!this.dynamicProperties.length) this.getValue(true);
        }
        TransformProperty.prototype = {
            applyToMatrix: applyToMatrix,
            getValue: processKeys,
            precalculateMatrix: precalculateMatrix,
            autoOrient: autoOrient
        };
        extendPrototype([
            DynamicPropertyContainer
        ], TransformProperty);
        TransformProperty.prototype.addDynamicProperty = addDynamicProperty;
        TransformProperty.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;
        function getTransformProperty(elem, data, container) {
            return new TransformProperty(elem, data, container);
        }
        return {
            getTransformProperty: getTransformProperty
        };
    }();
    function RepeaterModifier() {}
    extendPrototype([
        ShapeModifier
    ], RepeaterModifier);
    RepeaterModifier.prototype.initModifierProperties = function(elem, data) {
        this.getValue = this.processKeys;
        this.c = PropertyFactory.getProp(elem, data.c, 0, null, this);
        this.o = PropertyFactory.getProp(elem, data.o, 0, null, this);
        this.tr = TransformPropertyFactory.getTransformProperty(elem, data.tr, this);
        this.so = PropertyFactory.getProp(elem, data.tr.so, 0, 0.01, this);
        this.eo = PropertyFactory.getProp(elem, data.tr.eo, 0, 0.01, this);
        this.data = data;
        if (!this.dynamicProperties.length) this.getValue(true);
        this._isAnimated = !!this.dynamicProperties.length;
        this.pMatrix = new Matrix();
        this.rMatrix = new Matrix();
        this.sMatrix = new Matrix();
        this.tMatrix = new Matrix();
        this.matrix = new Matrix();
    };
    RepeaterModifier.prototype.applyTransforms = function(pMatrix, rMatrix, sMatrix, transform, perc, inv) {
        var dir = inv ? -1 : 1;
        var scaleX = transform.s.v[0] + (1 - transform.s.v[0]) * (1 - perc);
        var scaleY = transform.s.v[1] + (1 - transform.s.v[1]) * (1 - perc);
        pMatrix.translate(transform.p.v[0] * dir * perc, transform.p.v[1] * dir * perc, transform.p.v[2]);
        rMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);
        rMatrix.rotate(-transform.r.v * dir * perc);
        rMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);
        sMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);
        sMatrix.scale(inv ? 1 / scaleX : scaleX, inv ? 1 / scaleY : scaleY);
        sMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);
    };
    RepeaterModifier.prototype.init = function(elem, arr, pos, elemsData) {
        this.elem = elem;
        this.arr = arr;
        this.pos = pos;
        this.elemsData = elemsData;
        this._currentCopies = 0;
        this._elements = [];
        this._groups = [];
        this.frameId = -1;
        this.initDynamicPropertyContainer(elem);
        this.initModifierProperties(elem, arr[pos]);
        while(pos > 0){
            pos -= 1; // this._elements.unshift(arr.splice(pos,1)[0]);
            this._elements.unshift(arr[pos]);
        }
        if (this.dynamicProperties.length) this.k = true;
        else this.getValue(true);
    };
    RepeaterModifier.prototype.resetElements = function(elements) {
        var i;
        var len = elements.length;
        for(i = 0; i < len; i += 1){
            elements[i]._processed = false;
            if (elements[i].ty === "gr") this.resetElements(elements[i].it);
        }
    };
    RepeaterModifier.prototype.cloneElements = function(elements) {
        var newElements = JSON.parse(JSON.stringify(elements));
        this.resetElements(newElements);
        return newElements;
    };
    RepeaterModifier.prototype.changeGroupRender = function(elements, renderFlag) {
        var i;
        var len = elements.length;
        for(i = 0; i < len; i += 1){
            elements[i]._render = renderFlag;
            if (elements[i].ty === "gr") this.changeGroupRender(elements[i].it, renderFlag);
        }
    };
    RepeaterModifier.prototype.processShapes = function(_isFirstFrame) {
        var items;
        var itemsTransform;
        var i;
        var dir;
        var cont;
        var hasReloaded = false;
        if (this._mdf || _isFirstFrame) {
            var copies = Math.ceil(this.c.v);
            if (this._groups.length < copies) {
                while(this._groups.length < copies){
                    var group = {
                        it: this.cloneElements(this._elements),
                        ty: "gr"
                    };
                    group.it.push({
                        a: {
                            a: 0,
                            ix: 1,
                            k: [
                                0,
                                0
                            ]
                        },
                        nm: "Transform",
                        o: {
                            a: 0,
                            ix: 7,
                            k: 100
                        },
                        p: {
                            a: 0,
                            ix: 2,
                            k: [
                                0,
                                0
                            ]
                        },
                        r: {
                            a: 1,
                            ix: 6,
                            k: [
                                {
                                    s: 0,
                                    e: 0,
                                    t: 0
                                },
                                {
                                    s: 0,
                                    e: 0,
                                    t: 1
                                }
                            ]
                        },
                        s: {
                            a: 0,
                            ix: 3,
                            k: [
                                100,
                                100
                            ]
                        },
                        sa: {
                            a: 0,
                            ix: 5,
                            k: 0
                        },
                        sk: {
                            a: 0,
                            ix: 4,
                            k: 0
                        },
                        ty: "tr"
                    });
                    this.arr.splice(0, 0, group);
                    this._groups.splice(0, 0, group);
                    this._currentCopies += 1;
                }
                this.elem.reloadShapes();
                hasReloaded = true;
            }
            cont = 0;
            var renderFlag;
            for(i = 0; i <= this._groups.length - 1; i += 1){
                renderFlag = cont < copies;
                this._groups[i]._render = renderFlag;
                this.changeGroupRender(this._groups[i].it, renderFlag);
                if (!renderFlag) {
                    var elems = this.elemsData[i].it;
                    var transformData = elems[elems.length - 1];
                    if (transformData.transform.op.v !== 0) {
                        transformData.transform.op._mdf = true;
                        transformData.transform.op.v = 0;
                    } else transformData.transform.op._mdf = false;
                }
                cont += 1;
            }
            this._currentCopies = copies; /// /
            var offset = this.o.v;
            var offsetModulo = offset % 1;
            var roundOffset = offset > 0 ? Math.floor(offset) : Math.ceil(offset);
            var pProps = this.pMatrix.props;
            var rProps = this.rMatrix.props;
            var sProps = this.sMatrix.props;
            this.pMatrix.reset();
            this.rMatrix.reset();
            this.sMatrix.reset();
            this.tMatrix.reset();
            this.matrix.reset();
            var iteration = 0;
            if (offset > 0) {
                while(iteration < roundOffset){
                    this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
                    iteration += 1;
                }
                if (offsetModulo) {
                    this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, offsetModulo, false);
                    iteration += offsetModulo;
                }
            } else if (offset < 0) {
                while(iteration > roundOffset){
                    this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, true);
                    iteration -= 1;
                }
                if (offsetModulo) {
                    this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -offsetModulo, true);
                    iteration -= offsetModulo;
                }
            }
            i = this.data.m === 1 ? 0 : this._currentCopies - 1;
            dir = this.data.m === 1 ? 1 : -1;
            cont = this._currentCopies;
            var j;
            var jLen;
            while(cont){
                items = this.elemsData[i].it;
                itemsTransform = items[items.length - 1].transform.mProps.v.props;
                jLen = itemsTransform.length;
                items[items.length - 1].transform.mProps._mdf = true;
                items[items.length - 1].transform.op._mdf = true;
                items[items.length - 1].transform.op.v = this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (i / (this._currentCopies - 1));
                if (iteration !== 0) {
                    if (i !== 0 && dir === 1 || i !== this._currentCopies - 1 && dir === -1) this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
                    this.matrix.transform(rProps[0], rProps[1], rProps[2], rProps[3], rProps[4], rProps[5], rProps[6], rProps[7], rProps[8], rProps[9], rProps[10], rProps[11], rProps[12], rProps[13], rProps[14], rProps[15]);
                    this.matrix.transform(sProps[0], sProps[1], sProps[2], sProps[3], sProps[4], sProps[5], sProps[6], sProps[7], sProps[8], sProps[9], sProps[10], sProps[11], sProps[12], sProps[13], sProps[14], sProps[15]);
                    this.matrix.transform(pProps[0], pProps[1], pProps[2], pProps[3], pProps[4], pProps[5], pProps[6], pProps[7], pProps[8], pProps[9], pProps[10], pProps[11], pProps[12], pProps[13], pProps[14], pProps[15]);
                    for(j = 0; j < jLen; j += 1)itemsTransform[j] = this.matrix.props[j];
                    this.matrix.reset();
                } else {
                    this.matrix.reset();
                    for(j = 0; j < jLen; j += 1)itemsTransform[j] = this.matrix.props[j];
                }
                iteration += 1;
                cont -= 1;
                i += dir;
            }
        } else {
            cont = this._currentCopies;
            i = 0;
            dir = 1;
            while(cont){
                items = this.elemsData[i].it;
                itemsTransform = items[items.length - 1].transform.mProps.v.props;
                items[items.length - 1].transform.mProps._mdf = false;
                items[items.length - 1].transform.op._mdf = false;
                cont -= 1;
                i += dir;
            }
        }
        return hasReloaded;
    };
    RepeaterModifier.prototype.addShape = function() {};
    function RoundCornersModifier() {}
    extendPrototype([
        ShapeModifier
    ], RoundCornersModifier);
    RoundCornersModifier.prototype.initModifierProperties = function(elem, data) {
        this.getValue = this.processKeys;
        this.rd = PropertyFactory.getProp(elem, data.r, 0, null, this);
        this._isAnimated = !!this.rd.effectsSequence.length;
    };
    RoundCornersModifier.prototype.processPath = function(path, round) {
        var clonedPath = shapePool.newElement();
        clonedPath.c = path.c;
        var i;
        var len = path._length;
        var currentV;
        var currentI;
        var currentO;
        var closerV;
        var distance;
        var newPosPerc;
        var index = 0;
        var vX;
        var vY;
        var oX;
        var oY;
        var iX;
        var iY;
        for(i = 0; i < len; i += 1){
            currentV = path.v[i];
            currentO = path.o[i];
            currentI = path.i[i];
            if (currentV[0] === currentO[0] && currentV[1] === currentO[1] && currentV[0] === currentI[0] && currentV[1] === currentI[1]) {
                if ((i === 0 || i === len - 1) && !path.c) {
                    clonedPath.setTripleAt(currentV[0], currentV[1], currentO[0], currentO[1], currentI[0], currentI[1], index);
                    /* clonedPath.v[index] = currentV;
                  clonedPath.o[index] = currentO;
                  clonedPath.i[index] = currentI; */ index += 1;
                } else {
                    if (i === 0) closerV = path.v[len - 1];
                    else closerV = path.v[i - 1];
                    distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
                    newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
                    iX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
                    vX = iX;
                    iY = currentV[1] - (currentV[1] - closerV[1]) * newPosPerc;
                    vY = iY;
                    oX = vX - (vX - currentV[0]) * roundCorner;
                    oY = vY - (vY - currentV[1]) * roundCorner;
                    clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index);
                    index += 1;
                    if (i === len - 1) closerV = path.v[0];
                    else closerV = path.v[i + 1];
                    distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
                    newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
                    oX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
                    vX = oX;
                    oY = currentV[1] + (closerV[1] - currentV[1]) * newPosPerc;
                    vY = oY;
                    iX = vX - (vX - currentV[0]) * roundCorner;
                    iY = vY - (vY - currentV[1]) * roundCorner;
                    clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index);
                    index += 1;
                }
            } else {
                clonedPath.setTripleAt(path.v[i][0], path.v[i][1], path.o[i][0], path.o[i][1], path.i[i][0], path.i[i][1], index);
                index += 1;
            }
        }
        return clonedPath;
    };
    RoundCornersModifier.prototype.processShapes = function(_isFirstFrame) {
        var shapePaths;
        var i;
        var len = this.shapes.length;
        var j;
        var jLen;
        var rd = this.rd.v;
        if (rd !== 0) {
            var shapeData;
            var localShapeCollection;
            for(i = 0; i < len; i += 1){
                shapeData = this.shapes[i];
                localShapeCollection = shapeData.localShapeCollection;
                if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
                    localShapeCollection.releaseShapes();
                    shapeData.shape._mdf = true;
                    shapePaths = shapeData.shape.paths.shapes;
                    jLen = shapeData.shape.paths._length;
                    for(j = 0; j < jLen; j += 1)localShapeCollection.addShape(this.processPath(shapePaths[j], rd));
                }
                shapeData.shape.paths = shapeData.localShapeCollection;
            }
        }
        if (!this.dynamicProperties.length) this._mdf = false;
    };
    function getFontProperties(fontData) {
        var styles = fontData.fStyle ? fontData.fStyle.split(" ") : [];
        var fWeight = "normal";
        var fStyle = "normal";
        var len = styles.length;
        var styleName;
        for(var i = 0; i < len; i += 1){
            styleName = styles[i].toLowerCase();
            switch(styleName){
                case "italic":
                    fStyle = "italic";
                    break;
                case "bold":
                    fWeight = "700";
                    break;
                case "black":
                    fWeight = "900";
                    break;
                case "medium":
                    fWeight = "500";
                    break;
                case "regular":
                case "normal":
                    fWeight = "400";
                    break;
                case "light":
                case "thin":
                    fWeight = "200";
                    break;
                default:
                    break;
            }
        }
        return {
            style: fStyle,
            weight: fontData.fWeight || fWeight
        };
    }
    var FontManager = function() {
        var maxWaitingTime = 5000;
        var emptyChar = {
            w: 0,
            size: 0,
            shapes: [],
            data: {
                shapes: []
            }
        };
        var combinedCharacters = []; // Hindi characters
        combinedCharacters = combinedCharacters.concat([
            2304,
            2305,
            2306,
            2307,
            2362,
            2363,
            2364,
            2364,
            2366,
            2367,
            2368,
            2369,
            2370,
            2371,
            2372,
            2373,
            2374,
            2375,
            2376,
            2377,
            2378,
            2379,
            2380,
            2381,
            2382,
            2383,
            2387,
            2388,
            2389,
            2390,
            2391,
            2402,
            2403
        ]);
        var surrogateModifiers = [
            "d83cdffb",
            "d83cdffc",
            "d83cdffd",
            "d83cdffe",
            "d83cdfff"
        ];
        var zeroWidthJoiner = [
            65039,
            8205
        ];
        function trimFontOptions(font) {
            var familyArray = font.split(",");
            var i;
            var len = familyArray.length;
            var enabledFamilies = [];
            for(i = 0; i < len; i += 1)if (familyArray[i] !== "sans-serif" && familyArray[i] !== "monospace") enabledFamilies.push(familyArray[i]);
            return enabledFamilies.join(",");
        }
        function setUpNode(font, family) {
            var parentNode = createTag("span"); // Node is invisible to screen readers.
            parentNode.setAttribute("aria-hidden", true);
            parentNode.style.fontFamily = family;
            var node = createTag("span"); // Characters that vary significantly among different fonts
            node.innerText = "giItT1WQy@!-/#"; // Visible - so we can measure it - but not on the screen
            parentNode.style.position = "absolute";
            parentNode.style.left = "-10000px";
            parentNode.style.top = "-10000px"; // Large font size makes even subtle changes obvious
            parentNode.style.fontSize = "300px"; // Reset any font properties
            parentNode.style.fontVariant = "normal";
            parentNode.style.fontStyle = "normal";
            parentNode.style.fontWeight = "normal";
            parentNode.style.letterSpacing = "0";
            parentNode.appendChild(node);
            document.body.appendChild(parentNode); // Remember width with no applied web font
            var width = node.offsetWidth;
            node.style.fontFamily = trimFontOptions(font) + ", " + family;
            return {
                node: node,
                w: width,
                parent: parentNode
            };
        }
        function checkLoadedFonts() {
            var i;
            var len = this.fonts.length;
            var node;
            var w;
            var loadedCount = len;
            for(i = 0; i < len; i += 1){
                if (this.fonts[i].loaded) loadedCount -= 1;
                else if (this.fonts[i].fOrigin === "n" || this.fonts[i].origin === 0) this.fonts[i].loaded = true;
                else {
                    node = this.fonts[i].monoCase.node;
                    w = this.fonts[i].monoCase.w;
                    if (node.offsetWidth !== w) {
                        loadedCount -= 1;
                        this.fonts[i].loaded = true;
                    } else {
                        node = this.fonts[i].sansCase.node;
                        w = this.fonts[i].sansCase.w;
                        if (node.offsetWidth !== w) {
                            loadedCount -= 1;
                            this.fonts[i].loaded = true;
                        }
                    }
                    if (this.fonts[i].loaded) {
                        this.fonts[i].sansCase.parent.parentNode.removeChild(this.fonts[i].sansCase.parent);
                        this.fonts[i].monoCase.parent.parentNode.removeChild(this.fonts[i].monoCase.parent);
                    }
                }
            }
            if (loadedCount !== 0 && Date.now() - this.initTime < maxWaitingTime) setTimeout(this.checkLoadedFontsBinded, 20);
            else setTimeout(this.setIsLoadedBinded, 10);
        }
        function createHelper(fontData, def) {
            var engine = document.body && def ? "svg" : "canvas";
            var helper;
            var fontProps = getFontProperties(fontData);
            if (engine === "svg") {
                var tHelper = createNS("text");
                tHelper.style.fontSize = "100px"; // tHelper.style.fontFamily = fontData.fFamily;
                tHelper.setAttribute("font-family", fontData.fFamily);
                tHelper.setAttribute("font-style", fontProps.style);
                tHelper.setAttribute("font-weight", fontProps.weight);
                tHelper.textContent = "1";
                if (fontData.fClass) {
                    tHelper.style.fontFamily = "inherit";
                    tHelper.setAttribute("class", fontData.fClass);
                } else tHelper.style.fontFamily = fontData.fFamily;
                def.appendChild(tHelper);
                helper = tHelper;
            } else {
                var tCanvasHelper = new OffscreenCanvas(500, 500).getContext("2d");
                tCanvasHelper.font = fontProps.style + " " + fontProps.weight + " 100px " + fontData.fFamily;
                helper = tCanvasHelper;
            }
            function measure(text) {
                if (engine === "svg") {
                    helper.textContent = text;
                    return helper.getComputedTextLength();
                }
                return helper.measureText(text).width;
            }
            return {
                measureText: measure
            };
        }
        function addFonts(fontData, defs) {
            if (!fontData) {
                this.isLoaded = true;
                return;
            }
            if (this.chars) {
                this.isLoaded = true;
                this.fonts = fontData.list;
                return;
            }
            if (!document.body) {
                this.isLoaded = true;
                fontData.list.forEach(function(data) {
                    data.helper = createHelper(data);
                    data.cache = {};
                });
                this.fonts = fontData.list;
                return;
            }
            var fontArr = fontData.list;
            var i;
            var len = fontArr.length;
            var _pendingFonts = len;
            for(i = 0; i < len; i += 1){
                var shouldLoadFont = true;
                var loadedSelector;
                var j;
                fontArr[i].loaded = false;
                fontArr[i].monoCase = setUpNode(fontArr[i].fFamily, "monospace");
                fontArr[i].sansCase = setUpNode(fontArr[i].fFamily, "sans-serif");
                if (!fontArr[i].fPath) {
                    fontArr[i].loaded = true;
                    _pendingFonts -= 1;
                } else if (fontArr[i].fOrigin === "p" || fontArr[i].origin === 3) {
                    loadedSelector = document.querySelectorAll('style[f-forigin="p"][f-family="' + fontArr[i].fFamily + '"], style[f-origin="3"][f-family="' + fontArr[i].fFamily + '"]');
                    if (loadedSelector.length > 0) shouldLoadFont = false;
                    if (shouldLoadFont) {
                        var s = createTag("style");
                        s.setAttribute("f-forigin", fontArr[i].fOrigin);
                        s.setAttribute("f-origin", fontArr[i].origin);
                        s.setAttribute("f-family", fontArr[i].fFamily);
                        s.type = "text/css";
                        s.innerText = "@font-face {font-family: " + fontArr[i].fFamily + "; font-style: normal; src: url('" + fontArr[i].fPath + "');}";
                        defs.appendChild(s);
                    }
                } else if (fontArr[i].fOrigin === "g" || fontArr[i].origin === 1) {
                    loadedSelector = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]');
                    for(j = 0; j < loadedSelector.length; j += 1)if (loadedSelector[j].href.indexOf(fontArr[i].fPath) !== -1) // Font is already loaded
                    shouldLoadFont = false;
                    if (shouldLoadFont) {
                        var l = createTag("link");
                        l.setAttribute("f-forigin", fontArr[i].fOrigin);
                        l.setAttribute("f-origin", fontArr[i].origin);
                        l.type = "text/css";
                        l.rel = "stylesheet";
                        l.href = fontArr[i].fPath;
                        document.body.appendChild(l);
                    }
                } else if (fontArr[i].fOrigin === "t" || fontArr[i].origin === 2) {
                    loadedSelector = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]');
                    for(j = 0; j < loadedSelector.length; j += 1)if (fontArr[i].fPath === loadedSelector[j].src) // Font is already loaded
                    shouldLoadFont = false;
                    if (shouldLoadFont) {
                        var sc = createTag("link");
                        sc.setAttribute("f-forigin", fontArr[i].fOrigin);
                        sc.setAttribute("f-origin", fontArr[i].origin);
                        sc.setAttribute("rel", "stylesheet");
                        sc.setAttribute("href", fontArr[i].fPath);
                        defs.appendChild(sc);
                    }
                }
                fontArr[i].helper = createHelper(fontArr[i], defs);
                fontArr[i].cache = {};
                this.fonts.push(fontArr[i]);
            }
            if (_pendingFonts === 0) this.isLoaded = true;
            else // On some cases even if the font is loaded, it won't load correctly when measuring text on canvas.
            // Adding this timeout seems to fix it
            setTimeout(this.checkLoadedFonts.bind(this), 100);
        }
        function addChars(chars) {
            if (!chars) return;
            if (!this.chars) this.chars = [];
            var i;
            var len = chars.length;
            var j;
            var jLen = this.chars.length;
            var found;
            for(i = 0; i < len; i += 1){
                j = 0;
                found = false;
                while(j < jLen){
                    if (this.chars[j].style === chars[i].style && this.chars[j].fFamily === chars[i].fFamily && this.chars[j].ch === chars[i].ch) found = true;
                    j += 1;
                }
                if (!found) {
                    this.chars.push(chars[i]);
                    jLen += 1;
                }
            }
        }
        function getCharData(_char, style, font) {
            var i = 0;
            var len = this.chars.length;
            while(i < len){
                if (this.chars[i].ch === _char && this.chars[i].style === style && this.chars[i].fFamily === font) return this.chars[i];
                i += 1;
            }
            if ((typeof _char === "string" && _char.charCodeAt(0) !== 13 || !_char) && console && console.warn // eslint-disable-line no-console
             && !this._warned) {
                this._warned = true;
                console.warn("Missing character from exported characters list: ", _char, style, font); // eslint-disable-line no-console
            }
            return emptyChar;
        }
        function measureText(_char2, fontName, size) {
            var fontData = this.getFontByName(fontName);
            var index = _char2.charCodeAt(0);
            if (!fontData.cache[index + 1]) {
                var tHelper = fontData.helper;
                if (_char2 === " ") {
                    var doubleSize = tHelper.measureText("|" + _char2 + "|");
                    var singleSize = tHelper.measureText("||");
                    fontData.cache[index + 1] = (doubleSize - singleSize) / 100;
                } else fontData.cache[index + 1] = tHelper.measureText(_char2) / 100;
            }
            return fontData.cache[index + 1] * size;
        }
        function getFontByName(name) {
            var i = 0;
            var len = this.fonts.length;
            while(i < len){
                if (this.fonts[i].fName === name) return this.fonts[i];
                i += 1;
            }
            return this.fonts[0];
        }
        function isModifier(firstCharCode, secondCharCode) {
            var sum = firstCharCode.toString(16) + secondCharCode.toString(16);
            return surrogateModifiers.indexOf(sum) !== -1;
        }
        function isZeroWidthJoiner(firstCharCode, secondCharCode) {
            if (!secondCharCode) return firstCharCode === zeroWidthJoiner[1];
            return firstCharCode === zeroWidthJoiner[0] && secondCharCode === zeroWidthJoiner[1];
        }
        function isCombinedCharacter(_char3) {
            return combinedCharacters.indexOf(_char3) !== -1;
        }
        function setIsLoaded() {
            this.isLoaded = true;
        }
        var Font = function Font() {
            this.fonts = [];
            this.chars = null;
            this.typekitLoaded = 0;
            this.isLoaded = false;
            this._warned = false;
            this.initTime = Date.now();
            this.setIsLoadedBinded = this.setIsLoaded.bind(this);
            this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this);
        };
        Font.isModifier = isModifier;
        Font.isZeroWidthJoiner = isZeroWidthJoiner;
        Font.isCombinedCharacter = isCombinedCharacter;
        var fontPrototype = {
            addChars: addChars,
            addFonts: addFonts,
            getCharData: getCharData,
            getFontByName: getFontByName,
            measureText: measureText,
            checkLoadedFonts: checkLoadedFonts,
            setIsLoaded: setIsLoaded
        };
        Font.prototype = fontPrototype;
        return Font;
    }();
    function RenderableElement() {}
    RenderableElement.prototype = {
        initRenderable: function initRenderable() {
            // layer's visibility related to inpoint and outpoint. Rename isVisible to isInRange
            this.isInRange = false; // layer's display state
            this.hidden = false; // If layer's transparency equals 0, it can be hidden
            this.isTransparent = false; // list of animated components
            this.renderableComponents = [];
        },
        addRenderableComponent: function addRenderableComponent(component) {
            if (this.renderableComponents.indexOf(component) === -1) this.renderableComponents.push(component);
        },
        removeRenderableComponent: function removeRenderableComponent(component) {
            if (this.renderableComponents.indexOf(component) !== -1) this.renderableComponents.splice(this.renderableComponents.indexOf(component), 1);
        },
        prepareRenderableFrame: function prepareRenderableFrame(num) {
            this.checkLayerLimits(num);
        },
        checkTransparency: function checkTransparency() {
            if (this.finalTransform.mProp.o.v <= 0) {
                if (!this.isTransparent && this.globalData.renderConfig.hideOnTransparent) {
                    this.isTransparent = true;
                    this.hide();
                }
            } else if (this.isTransparent) {
                this.isTransparent = false;
                this.show();
            }
        },
        /**
       * @function
       * Initializes frame related properties.
       *
       * @param {number} num
       * current frame number in Layer's time
       *
       */ checkLayerLimits: function checkLayerLimits(num) {
            if (this.data.ip - this.data.st <= num && this.data.op - this.data.st > num) {
                if (this.isInRange !== true) {
                    this.globalData._mdf = true;
                    this._mdf = true;
                    this.isInRange = true;
                    this.show();
                }
            } else if (this.isInRange !== false) {
                this.globalData._mdf = true;
                this.isInRange = false;
                this.hide();
            }
        },
        renderRenderable: function renderRenderable() {
            var i;
            var len = this.renderableComponents.length;
            for(i = 0; i < len; i += 1)this.renderableComponents[i].renderFrame(this._isFirstFrame);
        /* this.maskManager.renderFrame(this.finalTransform.mat);
          this.renderableEffectsManager.renderFrame(this._isFirstFrame); */ },
        sourceRectAtTime: function sourceRectAtTime() {
            return {
                top: 0,
                left: 0,
                width: 100,
                height: 100
            };
        },
        getLayerSize: function getLayerSize() {
            if (this.data.ty === 5) return {
                w: this.data.textData.width,
                h: this.data.textData.height
            };
            return {
                w: this.data.width,
                h: this.data.height
            };
        }
    };
    var MaskManagerInterface = function() {
        function MaskInterface(mask, data) {
            this._mask = mask;
            this._data = data;
        }
        Object.defineProperty(MaskInterface.prototype, "maskPath", {
            get: function get() {
                if (this._mask.prop.k) this._mask.prop.getValue();
                return this._mask.prop;
            }
        });
        Object.defineProperty(MaskInterface.prototype, "maskOpacity", {
            get: function get() {
                if (this._mask.op.k) this._mask.op.getValue();
                return this._mask.op.v * 100;
            }
        });
        var MaskManager = function MaskManager(maskManager) {
            var _masksInterfaces = createSizedArray(maskManager.viewData.length);
            var i;
            var len = maskManager.viewData.length;
            for(i = 0; i < len; i += 1)_masksInterfaces[i] = new MaskInterface(maskManager.viewData[i], maskManager.masksProperties[i]);
            var maskFunction = function maskFunction(name) {
                i = 0;
                while(i < len){
                    if (maskManager.masksProperties[i].nm === name) return _masksInterfaces[i];
                    i += 1;
                }
                return null;
            };
            return maskFunction;
        };
        return MaskManager;
    }();
    var ExpressionPropertyInterface = function() {
        var defaultUnidimensionalValue = {
            pv: 0,
            v: 0,
            mult: 1
        };
        var defaultMultidimensionalValue = {
            pv: [
                0,
                0,
                0
            ],
            v: [
                0,
                0,
                0
            ],
            mult: 1
        };
        function completeProperty(expressionValue, property, type) {
            Object.defineProperty(expressionValue, "velocity", {
                get: function get() {
                    return property.getVelocityAtTime(property.comp.currentFrame);
                }
            });
            expressionValue.numKeys = property.keyframes ? property.keyframes.length : 0;
            expressionValue.key = function(pos) {
                if (!expressionValue.numKeys) return 0;
                var value = "";
                if ("s" in property.keyframes[pos - 1]) value = property.keyframes[pos - 1].s;
                else if ("e" in property.keyframes[pos - 2]) value = property.keyframes[pos - 2].e;
                else value = property.keyframes[pos - 2].s;
                var valueProp = type === "unidimensional" ? new Number(value) : Object.assign({}, value); // eslint-disable-line no-new-wrappers
                valueProp.time = property.keyframes[pos - 1].t / property.elem.comp.globalData.frameRate;
                valueProp.value = type === "unidimensional" ? value[0] : value;
                return valueProp;
            };
            expressionValue.valueAtTime = property.getValueAtTime;
            expressionValue.speedAtTime = property.getSpeedAtTime;
            expressionValue.velocityAtTime = property.getVelocityAtTime;
            expressionValue.propertyGroup = property.propertyGroup;
        }
        function UnidimensionalPropertyInterface(property) {
            if (!property || !("pv" in property)) property = defaultUnidimensionalValue;
            var mult = 1 / property.mult;
            var val = property.pv * mult;
            var expressionValue = new Number(val); // eslint-disable-line no-new-wrappers
            expressionValue.value = val;
            completeProperty(expressionValue, property, "unidimensional");
            return function() {
                if (property.k) property.getValue();
                val = property.v * mult;
                if (expressionValue.value !== val) {
                    expressionValue = new Number(val); // eslint-disable-line no-new-wrappers
                    expressionValue.value = val;
                    completeProperty(expressionValue, property, "unidimensional");
                }
                return expressionValue;
            };
        }
        function MultidimensionalPropertyInterface(property) {
            if (!property || !("pv" in property)) property = defaultMultidimensionalValue;
            var mult = 1 / property.mult;
            var len = property.data && property.data.l || property.pv.length;
            var expressionValue = createTypedArray("float32", len);
            var arrValue = createTypedArray("float32", len);
            expressionValue.value = arrValue;
            completeProperty(expressionValue, property, "multidimensional");
            return function() {
                if (property.k) property.getValue();
                for(var i = 0; i < len; i += 1){
                    arrValue[i] = property.v[i] * mult;
                    expressionValue[i] = arrValue[i];
                }
                return expressionValue;
            };
        } // TODO: try to avoid using this getter
        function defaultGetter() {
            return defaultUnidimensionalValue;
        }
        return function(property) {
            if (!property) return defaultGetter;
            if (property.propType === "unidimensional") return UnidimensionalPropertyInterface(property);
            return MultidimensionalPropertyInterface(property);
        };
    }();
    var TransformExpressionInterface = function() {
        return function(transform) {
            function _thisFunction(name) {
                switch(name){
                    case "scale":
                    case "Scale":
                    case "ADBE Scale":
                    case 6:
                        return _thisFunction.scale;
                    case "rotation":
                    case "Rotation":
                    case "ADBE Rotation":
                    case "ADBE Rotate Z":
                    case 10:
                        return _thisFunction.rotation;
                    case "ADBE Rotate X":
                        return _thisFunction.xRotation;
                    case "ADBE Rotate Y":
                        return _thisFunction.yRotation;
                    case "position":
                    case "Position":
                    case "ADBE Position":
                    case 2:
                        return _thisFunction.position;
                    case "ADBE Position_0":
                        return _thisFunction.xPosition;
                    case "ADBE Position_1":
                        return _thisFunction.yPosition;
                    case "ADBE Position_2":
                        return _thisFunction.zPosition;
                    case "anchorPoint":
                    case "AnchorPoint":
                    case "Anchor Point":
                    case "ADBE AnchorPoint":
                    case 1:
                        return _thisFunction.anchorPoint;
                    case "opacity":
                    case "Opacity":
                    case 11:
                        return _thisFunction.opacity;
                    default:
                        return null;
                }
            }
            Object.defineProperty(_thisFunction, "rotation", {
                get: ExpressionPropertyInterface(transform.r || transform.rz)
            });
            Object.defineProperty(_thisFunction, "zRotation", {
                get: ExpressionPropertyInterface(transform.rz || transform.r)
            });
            Object.defineProperty(_thisFunction, "xRotation", {
                get: ExpressionPropertyInterface(transform.rx)
            });
            Object.defineProperty(_thisFunction, "yRotation", {
                get: ExpressionPropertyInterface(transform.ry)
            });
            Object.defineProperty(_thisFunction, "scale", {
                get: ExpressionPropertyInterface(transform.s)
            });
            var _px;
            var _py;
            var _pz;
            var _transformFactory;
            if (transform.p) _transformFactory = ExpressionPropertyInterface(transform.p);
            else {
                _px = ExpressionPropertyInterface(transform.px);
                _py = ExpressionPropertyInterface(transform.py);
                if (transform.pz) _pz = ExpressionPropertyInterface(transform.pz);
            }
            Object.defineProperty(_thisFunction, "position", {
                get: function get() {
                    if (transform.p) return _transformFactory();
                    return [
                        _px(),
                        _py(),
                        _pz ? _pz() : 0
                    ];
                }
            });
            Object.defineProperty(_thisFunction, "xPosition", {
                get: ExpressionPropertyInterface(transform.px)
            });
            Object.defineProperty(_thisFunction, "yPosition", {
                get: ExpressionPropertyInterface(transform.py)
            });
            Object.defineProperty(_thisFunction, "zPosition", {
                get: ExpressionPropertyInterface(transform.pz)
            });
            Object.defineProperty(_thisFunction, "anchorPoint", {
                get: ExpressionPropertyInterface(transform.a)
            });
            Object.defineProperty(_thisFunction, "opacity", {
                get: ExpressionPropertyInterface(transform.o)
            });
            Object.defineProperty(_thisFunction, "skew", {
                get: ExpressionPropertyInterface(transform.sk)
            });
            Object.defineProperty(_thisFunction, "skewAxis", {
                get: ExpressionPropertyInterface(transform.sa)
            });
            Object.defineProperty(_thisFunction, "orientation", {
                get: ExpressionPropertyInterface(transform.or)
            });
            return _thisFunction;
        };
    }();
    var LayerExpressionInterface = function() {
        function getMatrix(time) {
            var toWorldMat = new Matrix();
            if (time !== undefined) {
                var propMatrix = this._elem.finalTransform.mProp.getValueAtTime(time);
                propMatrix.clone(toWorldMat);
            } else {
                var transformMat = this._elem.finalTransform.mProp;
                transformMat.applyToMatrix(toWorldMat);
            }
            return toWorldMat;
        }
        function toWorldVec(arr, time) {
            var toWorldMat = this.getMatrix(time);
            toWorldMat.props[12] = 0;
            toWorldMat.props[13] = 0;
            toWorldMat.props[14] = 0;
            return this.applyPoint(toWorldMat, arr);
        }
        function toWorld(arr, time) {
            var toWorldMat = this.getMatrix(time);
            return this.applyPoint(toWorldMat, arr);
        }
        function fromWorldVec(arr, time) {
            var toWorldMat = this.getMatrix(time);
            toWorldMat.props[12] = 0;
            toWorldMat.props[13] = 0;
            toWorldMat.props[14] = 0;
            return this.invertPoint(toWorldMat, arr);
        }
        function fromWorld(arr, time) {
            var toWorldMat = this.getMatrix(time);
            return this.invertPoint(toWorldMat, arr);
        }
        function applyPoint(matrix, arr) {
            if (this._elem.hierarchy && this._elem.hierarchy.length) {
                var i;
                var len = this._elem.hierarchy.length;
                for(i = 0; i < len; i += 1)this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);
            }
            return matrix.applyToPointArray(arr[0], arr[1], arr[2] || 0);
        }
        function invertPoint(matrix, arr) {
            if (this._elem.hierarchy && this._elem.hierarchy.length) {
                var i;
                var len = this._elem.hierarchy.length;
                for(i = 0; i < len; i += 1)this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);
            }
            return matrix.inversePoint(arr);
        }
        function fromComp(arr) {
            var toWorldMat = new Matrix();
            toWorldMat.reset();
            this._elem.finalTransform.mProp.applyToMatrix(toWorldMat);
            if (this._elem.hierarchy && this._elem.hierarchy.length) {
                var i;
                var len = this._elem.hierarchy.length;
                for(i = 0; i < len; i += 1)this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);
                return toWorldMat.inversePoint(arr);
            }
            return toWorldMat.inversePoint(arr);
        }
        function sampleImage() {
            return [
                1,
                1,
                1,
                1
            ];
        }
        return function(elem) {
            var transformInterface;
            function _registerMaskInterface(maskManager) {
                _thisLayerFunction.mask = new MaskManagerInterface(maskManager, elem);
            }
            function _registerEffectsInterface(effects) {
                _thisLayerFunction.effect = effects;
            }
            function _thisLayerFunction(name) {
                switch(name){
                    case "ADBE Root Vectors Group":
                    case "Contents":
                    case 2:
                        return _thisLayerFunction.shapeInterface;
                    case 1:
                    case 6:
                    case "Transform":
                    case "transform":
                    case "ADBE Transform Group":
                        return transformInterface;
                    case 4:
                    case "ADBE Effect Parade":
                    case "effects":
                    case "Effects":
                        return _thisLayerFunction.effect;
                    case "ADBE Text Properties":
                        return _thisLayerFunction.textInterface;
                    default:
                        return null;
                }
            }
            _thisLayerFunction.getMatrix = getMatrix;
            _thisLayerFunction.invertPoint = invertPoint;
            _thisLayerFunction.applyPoint = applyPoint;
            _thisLayerFunction.toWorld = toWorld;
            _thisLayerFunction.toWorldVec = toWorldVec;
            _thisLayerFunction.fromWorld = fromWorld;
            _thisLayerFunction.fromWorldVec = fromWorldVec;
            _thisLayerFunction.toComp = toWorld;
            _thisLayerFunction.fromComp = fromComp;
            _thisLayerFunction.sampleImage = sampleImage;
            _thisLayerFunction.sourceRectAtTime = elem.sourceRectAtTime.bind(elem);
            _thisLayerFunction._elem = elem;
            transformInterface = TransformExpressionInterface(elem.finalTransform.mProp);
            var anchorPointDescriptor = getDescriptor(transformInterface, "anchorPoint");
            Object.defineProperties(_thisLayerFunction, {
                hasParent: {
                    get: function get() {
                        return elem.hierarchy.length;
                    }
                },
                parent: {
                    get: function get() {
                        return elem.hierarchy[0].layerInterface;
                    }
                },
                rotation: getDescriptor(transformInterface, "rotation"),
                scale: getDescriptor(transformInterface, "scale"),
                position: getDescriptor(transformInterface, "position"),
                opacity: getDescriptor(transformInterface, "opacity"),
                anchorPoint: anchorPointDescriptor,
                anchor_point: anchorPointDescriptor,
                transform: {
                    get: function get() {
                        return transformInterface;
                    }
                },
                active: {
                    get: function get() {
                        return elem.isInRange;
                    }
                }
            });
            _thisLayerFunction.startTime = elem.data.st;
            _thisLayerFunction.index = elem.data.ind;
            _thisLayerFunction.source = elem.data.refId;
            _thisLayerFunction.height = elem.data.ty === 0 ? elem.data.h : 100;
            _thisLayerFunction.width = elem.data.ty === 0 ? elem.data.w : 100;
            _thisLayerFunction.inPoint = elem.data.ip / elem.comp.globalData.frameRate;
            _thisLayerFunction.outPoint = elem.data.op / elem.comp.globalData.frameRate;
            _thisLayerFunction._name = elem.data.nm;
            _thisLayerFunction.registerMaskInterface = _registerMaskInterface;
            _thisLayerFunction.registerEffectsInterface = _registerEffectsInterface;
            return _thisLayerFunction;
        };
    }();
    var propertyGroupFactory = function() {
        return function(interfaceFunction, parentPropertyGroup) {
            return function(val) {
                val = val === undefined ? 1 : val;
                if (val <= 0) return interfaceFunction;
                return parentPropertyGroup(val - 1);
            };
        };
    }();
    var PropertyInterface = function() {
        return function(propertyName, propertyGroup) {
            var interfaceFunction = {
                _name: propertyName
            };
            function _propertyGroup(val) {
                val = val === undefined ? 1 : val;
                if (val <= 0) return interfaceFunction;
                return propertyGroup(val - 1);
            }
            return _propertyGroup;
        };
    }();
    var EffectsExpressionInterface = function() {
        var ob = {
            createEffectsInterface: createEffectsInterface
        };
        function createEffectsInterface(elem, propertyGroup) {
            if (elem.effectsManager) {
                var effectElements = [];
                var effectsData = elem.data.ef;
                var i;
                var len = elem.effectsManager.effectElements.length;
                for(i = 0; i < len; i += 1)effectElements.push(createGroupInterface(effectsData[i], elem.effectsManager.effectElements[i], propertyGroup, elem));
                var effects = elem.data.ef || [];
                var groupInterface = function groupInterface(name) {
                    i = 0;
                    len = effects.length;
                    while(i < len){
                        if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) return effectElements[i];
                        i += 1;
                    }
                    return null;
                };
                Object.defineProperty(groupInterface, "numProperties", {
                    get: function get() {
                        return effects.length;
                    }
                });
                return groupInterface;
            }
            return null;
        }
        function createGroupInterface(data, elements, propertyGroup, elem) {
            function groupInterface(name) {
                var effects = data.ef;
                var i = 0;
                var len = effects.length;
                while(i < len){
                    if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {
                        if (effects[i].ty === 5) return effectElements[i];
                        return effectElements[i]();
                    }
                    i += 1;
                }
                throw new Error();
            }
            var _propertyGroup = propertyGroupFactory(groupInterface, propertyGroup);
            var effectElements = [];
            var i;
            var len = data.ef.length;
            for(i = 0; i < len; i += 1)if (data.ef[i].ty === 5) effectElements.push(createGroupInterface(data.ef[i], elements.effectElements[i], elements.effectElements[i].propertyGroup, elem));
            else effectElements.push(createValueInterface(elements.effectElements[i], data.ef[i].ty, elem, _propertyGroup));
            if (data.mn === "ADBE Color Control") Object.defineProperty(groupInterface, "color", {
                get: function get() {
                    return effectElements[0]();
                }
            });
            Object.defineProperties(groupInterface, {
                numProperties: {
                    get: function get() {
                        return data.np;
                    }
                },
                _name: {
                    value: data.nm
                },
                propertyGroup: {
                    value: _propertyGroup
                }
            });
            groupInterface.enabled = data.en !== 0;
            groupInterface.active = groupInterface.enabled;
            return groupInterface;
        }
        function createValueInterface(element, type, elem, propertyGroup) {
            var expressionProperty = ExpressionPropertyInterface(element.p);
            function interfaceFunction() {
                if (type === 10) return elem.comp.compInterface(element.p.v);
                return expressionProperty();
            }
            if (element.p.setGroupProperty) element.p.setGroupProperty(PropertyInterface("", propertyGroup));
            return interfaceFunction;
        }
        return ob;
    }();
    var CompExpressionInterface = function() {
        return function(comp) {
            function _thisLayerFunction(name) {
                var i = 0;
                var len = comp.layers.length;
                while(i < len){
                    if (comp.layers[i].nm === name || comp.layers[i].ind === name) return comp.elements[i].layerInterface;
                    i += 1;
                }
                return null; // return {active:false};
            }
            Object.defineProperty(_thisLayerFunction, "_name", {
                value: comp.data.nm
            });
            _thisLayerFunction.layer = _thisLayerFunction;
            _thisLayerFunction.pixelAspect = 1;
            _thisLayerFunction.height = comp.data.h || comp.globalData.compSize.h;
            _thisLayerFunction.width = comp.data.w || comp.globalData.compSize.w;
            _thisLayerFunction.pixelAspect = 1;
            _thisLayerFunction.frameDuration = 1 / comp.globalData.frameRate;
            _thisLayerFunction.displayStartTime = 0;
            _thisLayerFunction.numLayers = comp.layers.length;
            return _thisLayerFunction;
        };
    }();
    var ShapePathInterface = function() {
        return function pathInterfaceFactory(shape, view, propertyGroup) {
            var prop = view.sh;
            function interfaceFunction(val) {
                if (val === "Shape" || val === "shape" || val === "Path" || val === "path" || val === "ADBE Vector Shape" || val === 2) return interfaceFunction.path;
                return null;
            }
            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            prop.setGroupProperty(PropertyInterface("Path", _propertyGroup));
            Object.defineProperties(interfaceFunction, {
                path: {
                    get: function get() {
                        if (prop.k) prop.getValue();
                        return prop;
                    }
                },
                shape: {
                    get: function get() {
                        if (prop.k) prop.getValue();
                        return prop;
                    }
                },
                _name: {
                    value: shape.nm
                },
                ix: {
                    value: shape.ix
                },
                propertyIndex: {
                    value: shape.ix
                },
                mn: {
                    value: shape.mn
                },
                propertyGroup: {
                    value: propertyGroup
                }
            });
            return interfaceFunction;
        };
    }();
    var ShapeExpressionInterface = function() {
        function iterateElements(shapes, view, propertyGroup) {
            var arr = [];
            var i;
            var len = shapes ? shapes.length : 0;
            for(i = 0; i < len; i += 1){
                if (shapes[i].ty === "gr") arr.push(groupInterfaceFactory(shapes[i], view[i], propertyGroup));
                else if (shapes[i].ty === "fl") arr.push(fillInterfaceFactory(shapes[i], view[i], propertyGroup));
                else if (shapes[i].ty === "st") arr.push(strokeInterfaceFactory(shapes[i], view[i], propertyGroup));
                else if (shapes[i].ty === "tm") arr.push(trimInterfaceFactory(shapes[i], view[i], propertyGroup));
                else if (shapes[i].ty === "tr") ;
                else if (shapes[i].ty === "el") arr.push(ellipseInterfaceFactory(shapes[i], view[i], propertyGroup));
                else if (shapes[i].ty === "sr") arr.push(starInterfaceFactory(shapes[i], view[i], propertyGroup));
                else if (shapes[i].ty === "sh") arr.push(ShapePathInterface(shapes[i], view[i], propertyGroup));
                else if (shapes[i].ty === "rc") arr.push(rectInterfaceFactory(shapes[i], view[i], propertyGroup));
                else if (shapes[i].ty === "rd") arr.push(roundedInterfaceFactory(shapes[i], view[i], propertyGroup));
                else if (shapes[i].ty === "rp") arr.push(repeaterInterfaceFactory(shapes[i], view[i], propertyGroup));
                else if (shapes[i].ty === "gf") arr.push(gradientFillInterfaceFactory(shapes[i], view[i], propertyGroup));
                else arr.push(defaultInterfaceFactory(shapes[i], view[i], propertyGroup));
            }
            return arr;
        }
        function contentsInterfaceFactory(shape, view, propertyGroup) {
            var interfaces;
            var interfaceFunction = function _interfaceFunction(value) {
                var i = 0;
                var len = interfaces.length;
                while(i < len){
                    if (interfaces[i]._name === value || interfaces[i].mn === value || interfaces[i].propertyIndex === value || interfaces[i].ix === value || interfaces[i].ind === value) return interfaces[i];
                    i += 1;
                }
                if (typeof value === "number") return interfaces[value - 1];
                return null;
            };
            interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            interfaces = iterateElements(shape.it, view.it, interfaceFunction.propertyGroup);
            interfaceFunction.numProperties = interfaces.length;
            var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
            interfaceFunction.transform = transformInterface;
            interfaceFunction.propertyIndex = shape.cix;
            interfaceFunction._name = shape.nm;
            return interfaceFunction;
        }
        function groupInterfaceFactory(shape, view, propertyGroup) {
            var interfaceFunction = function _interfaceFunction(value) {
                switch(value){
                    case "ADBE Vectors Group":
                    case "Contents":
                    case 2:
                        return interfaceFunction.content;
                    // Not necessary for now. Keeping them here in case a new case appears
                    // case 'ADBE Vector Transform Group':
                    // case 3:
                    default:
                        return interfaceFunction.transform;
                }
            };
            interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            var content = contentsInterfaceFactory(shape, view, interfaceFunction.propertyGroup);
            var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
            interfaceFunction.content = content;
            interfaceFunction.transform = transformInterface;
            Object.defineProperty(interfaceFunction, "_name", {
                get: function get() {
                    return shape.nm;
                }
            }); // interfaceFunction.content = interfaceFunction;
            interfaceFunction.numProperties = shape.np;
            interfaceFunction.propertyIndex = shape.ix;
            interfaceFunction.nm = shape.nm;
            interfaceFunction.mn = shape.mn;
            return interfaceFunction;
        }
        function fillInterfaceFactory(shape, view, propertyGroup) {
            function interfaceFunction(val) {
                if (val === "Color" || val === "color") return interfaceFunction.color;
                if (val === "Opacity" || val === "opacity") return interfaceFunction.opacity;
                return null;
            }
            Object.defineProperties(interfaceFunction, {
                color: {
                    get: ExpressionPropertyInterface(view.c)
                },
                opacity: {
                    get: ExpressionPropertyInterface(view.o)
                },
                _name: {
                    value: shape.nm
                },
                mn: {
                    value: shape.mn
                }
            });
            view.c.setGroupProperty(PropertyInterface("Color", propertyGroup));
            view.o.setGroupProperty(PropertyInterface("Opacity", propertyGroup));
            return interfaceFunction;
        }
        function gradientFillInterfaceFactory(shape, view, propertyGroup) {
            function interfaceFunction(val) {
                if (val === "Start Point" || val === "start point") return interfaceFunction.startPoint;
                if (val === "End Point" || val === "end point") return interfaceFunction.endPoint;
                if (val === "Opacity" || val === "opacity") return interfaceFunction.opacity;
                return null;
            }
            Object.defineProperties(interfaceFunction, {
                startPoint: {
                    get: ExpressionPropertyInterface(view.s)
                },
                endPoint: {
                    get: ExpressionPropertyInterface(view.e)
                },
                opacity: {
                    get: ExpressionPropertyInterface(view.o)
                },
                type: {
                    get: function get() {
                        return "a";
                    }
                },
                _name: {
                    value: shape.nm
                },
                mn: {
                    value: shape.mn
                }
            });
            view.s.setGroupProperty(PropertyInterface("Start Point", propertyGroup));
            view.e.setGroupProperty(PropertyInterface("End Point", propertyGroup));
            view.o.setGroupProperty(PropertyInterface("Opacity", propertyGroup));
            return interfaceFunction;
        }
        function defaultInterfaceFactory() {
            function interfaceFunction() {
                return null;
            }
            return interfaceFunction;
        }
        function strokeInterfaceFactory(shape, view, propertyGroup) {
            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            var _dashPropertyGroup = propertyGroupFactory(dashOb, _propertyGroup);
            function addPropertyToDashOb(i) {
                Object.defineProperty(dashOb, shape.d[i].nm, {
                    get: ExpressionPropertyInterface(view.d.dataProps[i].p)
                });
            }
            var i;
            var len = shape.d ? shape.d.length : 0;
            var dashOb = {};
            for(i = 0; i < len; i += 1){
                addPropertyToDashOb(i);
                view.d.dataProps[i].p.setGroupProperty(_dashPropertyGroup);
            }
            function interfaceFunction(val) {
                if (val === "Color" || val === "color") return interfaceFunction.color;
                if (val === "Opacity" || val === "opacity") return interfaceFunction.opacity;
                if (val === "Stroke Width" || val === "stroke width") return interfaceFunction.strokeWidth;
                return null;
            }
            Object.defineProperties(interfaceFunction, {
                color: {
                    get: ExpressionPropertyInterface(view.c)
                },
                opacity: {
                    get: ExpressionPropertyInterface(view.o)
                },
                strokeWidth: {
                    get: ExpressionPropertyInterface(view.w)
                },
                dash: {
                    get: function get() {
                        return dashOb;
                    }
                },
                _name: {
                    value: shape.nm
                },
                mn: {
                    value: shape.mn
                }
            });
            view.c.setGroupProperty(PropertyInterface("Color", _propertyGroup));
            view.o.setGroupProperty(PropertyInterface("Opacity", _propertyGroup));
            view.w.setGroupProperty(PropertyInterface("Stroke Width", _propertyGroup));
            return interfaceFunction;
        }
        function trimInterfaceFactory(shape, view, propertyGroup) {
            function interfaceFunction(val) {
                if (val === shape.e.ix || val === "End" || val === "end") return interfaceFunction.end;
                if (val === shape.s.ix) return interfaceFunction.start;
                if (val === shape.o.ix) return interfaceFunction.offset;
                return null;
            }
            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            interfaceFunction.propertyIndex = shape.ix;
            view.s.setGroupProperty(PropertyInterface("Start", _propertyGroup));
            view.e.setGroupProperty(PropertyInterface("End", _propertyGroup));
            view.o.setGroupProperty(PropertyInterface("Offset", _propertyGroup));
            interfaceFunction.propertyIndex = shape.ix;
            interfaceFunction.propertyGroup = propertyGroup;
            Object.defineProperties(interfaceFunction, {
                start: {
                    get: ExpressionPropertyInterface(view.s)
                },
                end: {
                    get: ExpressionPropertyInterface(view.e)
                },
                offset: {
                    get: ExpressionPropertyInterface(view.o)
                },
                _name: {
                    value: shape.nm
                }
            });
            interfaceFunction.mn = shape.mn;
            return interfaceFunction;
        }
        function transformInterfaceFactory(shape, view, propertyGroup) {
            function interfaceFunction(value) {
                if (shape.a.ix === value || value === "Anchor Point") return interfaceFunction.anchorPoint;
                if (shape.o.ix === value || value === "Opacity") return interfaceFunction.opacity;
                if (shape.p.ix === value || value === "Position") return interfaceFunction.position;
                if (shape.r.ix === value || value === "Rotation" || value === "ADBE Vector Rotation") return interfaceFunction.rotation;
                if (shape.s.ix === value || value === "Scale") return interfaceFunction.scale;
                if (shape.sk && shape.sk.ix === value || value === "Skew") return interfaceFunction.skew;
                if (shape.sa && shape.sa.ix === value || value === "Skew Axis") return interfaceFunction.skewAxis;
                return null;
            }
            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            view.transform.mProps.o.setGroupProperty(PropertyInterface("Opacity", _propertyGroup));
            view.transform.mProps.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
            view.transform.mProps.a.setGroupProperty(PropertyInterface("Anchor Point", _propertyGroup));
            view.transform.mProps.s.setGroupProperty(PropertyInterface("Scale", _propertyGroup));
            view.transform.mProps.r.setGroupProperty(PropertyInterface("Rotation", _propertyGroup));
            if (view.transform.mProps.sk) {
                view.transform.mProps.sk.setGroupProperty(PropertyInterface("Skew", _propertyGroup));
                view.transform.mProps.sa.setGroupProperty(PropertyInterface("Skew Angle", _propertyGroup));
            }
            view.transform.op.setGroupProperty(PropertyInterface("Opacity", _propertyGroup));
            Object.defineProperties(interfaceFunction, {
                opacity: {
                    get: ExpressionPropertyInterface(view.transform.mProps.o)
                },
                position: {
                    get: ExpressionPropertyInterface(view.transform.mProps.p)
                },
                anchorPoint: {
                    get: ExpressionPropertyInterface(view.transform.mProps.a)
                },
                scale: {
                    get: ExpressionPropertyInterface(view.transform.mProps.s)
                },
                rotation: {
                    get: ExpressionPropertyInterface(view.transform.mProps.r)
                },
                skew: {
                    get: ExpressionPropertyInterface(view.transform.mProps.sk)
                },
                skewAxis: {
                    get: ExpressionPropertyInterface(view.transform.mProps.sa)
                },
                _name: {
                    value: shape.nm
                }
            });
            interfaceFunction.ty = "tr";
            interfaceFunction.mn = shape.mn;
            interfaceFunction.propertyGroup = propertyGroup;
            return interfaceFunction;
        }
        function ellipseInterfaceFactory(shape, view, propertyGroup) {
            function interfaceFunction(value) {
                if (shape.p.ix === value) return interfaceFunction.position;
                if (shape.s.ix === value) return interfaceFunction.size;
                return null;
            }
            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            interfaceFunction.propertyIndex = shape.ix;
            var prop = view.sh.ty === "tm" ? view.sh.prop : view.sh;
            prop.s.setGroupProperty(PropertyInterface("Size", _propertyGroup));
            prop.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
            Object.defineProperties(interfaceFunction, {
                size: {
                    get: ExpressionPropertyInterface(prop.s)
                },
                position: {
                    get: ExpressionPropertyInterface(prop.p)
                },
                _name: {
                    value: shape.nm
                }
            });
            interfaceFunction.mn = shape.mn;
            return interfaceFunction;
        }
        function starInterfaceFactory(shape, view, propertyGroup) {
            function interfaceFunction(value) {
                if (shape.p.ix === value) return interfaceFunction.position;
                if (shape.r.ix === value) return interfaceFunction.rotation;
                if (shape.pt.ix === value) return interfaceFunction.points;
                if (shape.or.ix === value || value === "ADBE Vector Star Outer Radius") return interfaceFunction.outerRadius;
                if (shape.os.ix === value) return interfaceFunction.outerRoundness;
                if (shape.ir && (shape.ir.ix === value || value === "ADBE Vector Star Inner Radius")) return interfaceFunction.innerRadius;
                if (shape.is && shape.is.ix === value) return interfaceFunction.innerRoundness;
                return null;
            }
            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            var prop = view.sh.ty === "tm" ? view.sh.prop : view.sh;
            interfaceFunction.propertyIndex = shape.ix;
            prop.or.setGroupProperty(PropertyInterface("Outer Radius", _propertyGroup));
            prop.os.setGroupProperty(PropertyInterface("Outer Roundness", _propertyGroup));
            prop.pt.setGroupProperty(PropertyInterface("Points", _propertyGroup));
            prop.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
            prop.r.setGroupProperty(PropertyInterface("Rotation", _propertyGroup));
            if (shape.ir) {
                prop.ir.setGroupProperty(PropertyInterface("Inner Radius", _propertyGroup));
                prop.is.setGroupProperty(PropertyInterface("Inner Roundness", _propertyGroup));
            }
            Object.defineProperties(interfaceFunction, {
                position: {
                    get: ExpressionPropertyInterface(prop.p)
                },
                rotation: {
                    get: ExpressionPropertyInterface(prop.r)
                },
                points: {
                    get: ExpressionPropertyInterface(prop.pt)
                },
                outerRadius: {
                    get: ExpressionPropertyInterface(prop.or)
                },
                outerRoundness: {
                    get: ExpressionPropertyInterface(prop.os)
                },
                innerRadius: {
                    get: ExpressionPropertyInterface(prop.ir)
                },
                innerRoundness: {
                    get: ExpressionPropertyInterface(prop.is)
                },
                _name: {
                    value: shape.nm
                }
            });
            interfaceFunction.mn = shape.mn;
            return interfaceFunction;
        }
        function rectInterfaceFactory(shape, view, propertyGroup) {
            function interfaceFunction(value) {
                if (shape.p.ix === value) return interfaceFunction.position;
                if (shape.r.ix === value) return interfaceFunction.roundness;
                if (shape.s.ix === value || value === "Size" || value === "ADBE Vector Rect Size") return interfaceFunction.size;
                return null;
            }
            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            var prop = view.sh.ty === "tm" ? view.sh.prop : view.sh;
            interfaceFunction.propertyIndex = shape.ix;
            prop.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
            prop.s.setGroupProperty(PropertyInterface("Size", _propertyGroup));
            prop.r.setGroupProperty(PropertyInterface("Rotation", _propertyGroup));
            Object.defineProperties(interfaceFunction, {
                position: {
                    get: ExpressionPropertyInterface(prop.p)
                },
                roundness: {
                    get: ExpressionPropertyInterface(prop.r)
                },
                size: {
                    get: ExpressionPropertyInterface(prop.s)
                },
                _name: {
                    value: shape.nm
                }
            });
            interfaceFunction.mn = shape.mn;
            return interfaceFunction;
        }
        function roundedInterfaceFactory(shape, view, propertyGroup) {
            function interfaceFunction(value) {
                if (shape.r.ix === value || value === "Round Corners 1") return interfaceFunction.radius;
                return null;
            }
            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            var prop = view;
            interfaceFunction.propertyIndex = shape.ix;
            prop.rd.setGroupProperty(PropertyInterface("Radius", _propertyGroup));
            Object.defineProperties(interfaceFunction, {
                radius: {
                    get: ExpressionPropertyInterface(prop.rd)
                },
                _name: {
                    value: shape.nm
                }
            });
            interfaceFunction.mn = shape.mn;
            return interfaceFunction;
        }
        function repeaterInterfaceFactory(shape, view, propertyGroup) {
            function interfaceFunction(value) {
                if (shape.c.ix === value || value === "Copies") return interfaceFunction.copies;
                if (shape.o.ix === value || value === "Offset") return interfaceFunction.offset;
                return null;
            }
            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            var prop = view;
            interfaceFunction.propertyIndex = shape.ix;
            prop.c.setGroupProperty(PropertyInterface("Copies", _propertyGroup));
            prop.o.setGroupProperty(PropertyInterface("Offset", _propertyGroup));
            Object.defineProperties(interfaceFunction, {
                copies: {
                    get: ExpressionPropertyInterface(prop.c)
                },
                offset: {
                    get: ExpressionPropertyInterface(prop.o)
                },
                _name: {
                    value: shape.nm
                }
            });
            interfaceFunction.mn = shape.mn;
            return interfaceFunction;
        }
        return function(shapes, view, propertyGroup) {
            var interfaces;
            function _interfaceFunction(value) {
                if (typeof value === "number") {
                    value = value === undefined ? 1 : value;
                    if (value === 0) return propertyGroup;
                    return interfaces[value - 1];
                }
                var i = 0;
                var len = interfaces.length;
                while(i < len){
                    if (interfaces[i]._name === value) return interfaces[i];
                    i += 1;
                }
                return null;
            }
            function parentGroupWrapper() {
                return propertyGroup;
            }
            _interfaceFunction.propertyGroup = propertyGroupFactory(_interfaceFunction, parentGroupWrapper);
            interfaces = iterateElements(shapes, view, _interfaceFunction.propertyGroup);
            _interfaceFunction.numProperties = interfaces.length;
            _interfaceFunction._name = "Contents";
            return _interfaceFunction;
        };
    }();
    var TextExpressionInterface = function() {
        return function(elem) {
            var _prevValue;
            var _sourceText;
            function _thisLayerFunction(name) {
                switch(name){
                    case "ADBE Text Document":
                        return _thisLayerFunction.sourceText;
                    default:
                        return null;
                }
            }
            Object.defineProperty(_thisLayerFunction, "sourceText", {
                get: function get() {
                    elem.textProperty.getValue();
                    var stringValue = elem.textProperty.currentData.t;
                    if (stringValue !== _prevValue) {
                        elem.textProperty.currentData.t = _prevValue;
                        _sourceText = new String(stringValue); // eslint-disable-line no-new-wrappers
                        // If stringValue is an empty string, eval returns undefined, so it has to be returned as a String primitive
                        _sourceText.value = stringValue || new String(stringValue); // eslint-disable-line no-new-wrappers
                    }
                    return _sourceText;
                }
            });
            return _thisLayerFunction;
        };
    }();
    var getBlendMode = function() {
        var blendModeEnums = {
            0: "source-over",
            1: "multiply",
            2: "screen",
            3: "overlay",
            4: "darken",
            5: "lighten",
            6: "color-dodge",
            7: "color-burn",
            8: "hard-light",
            9: "soft-light",
            10: "difference",
            11: "exclusion",
            12: "hue",
            13: "saturation",
            14: "color",
            15: "luminosity"
        };
        return function(mode) {
            return blendModeEnums[mode] || "";
        };
    }();
    function SliderEffect(data, elem, container) {
        this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
    }
    function AngleEffect(data, elem, container) {
        this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
    }
    function ColorEffect(data, elem, container) {
        this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);
    }
    function PointEffect(data, elem, container) {
        this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);
    }
    function LayerIndexEffect(data, elem, container) {
        this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
    }
    function MaskIndexEffect(data, elem, container) {
        this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
    }
    function CheckboxEffect(data, elem, container) {
        this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
    }
    function NoValueEffect() {
        this.p = {};
    }
    function EffectsManager(data, element) {
        var effects = data.ef || [];
        this.effectElements = [];
        var i;
        var len = effects.length;
        var effectItem;
        for(i = 0; i < len; i += 1){
            effectItem = new GroupEffect(effects[i], element);
            this.effectElements.push(effectItem);
        }
    }
    function GroupEffect(data, element) {
        this.init(data, element);
    }
    extendPrototype([
        DynamicPropertyContainer
    ], GroupEffect);
    GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties;
    GroupEffect.prototype.init = function(data, element) {
        this.data = data;
        this.effectElements = [];
        this.initDynamicPropertyContainer(element);
        var i;
        var len = this.data.ef.length;
        var eff;
        var effects = this.data.ef;
        for(i = 0; i < len; i += 1){
            eff = null;
            switch(effects[i].ty){
                case 0:
                    eff = new SliderEffect(effects[i], element, this);
                    break;
                case 1:
                    eff = new AngleEffect(effects[i], element, this);
                    break;
                case 2:
                    eff = new ColorEffect(effects[i], element, this);
                    break;
                case 3:
                    eff = new PointEffect(effects[i], element, this);
                    break;
                case 4:
                case 7:
                    eff = new CheckboxEffect(effects[i], element, this);
                    break;
                case 10:
                    eff = new LayerIndexEffect(effects[i], element, this);
                    break;
                case 11:
                    eff = new MaskIndexEffect(effects[i], element, this);
                    break;
                case 5:
                    eff = new EffectsManager(effects[i], element, this);
                    break;
                // case 6:
                default:
                    eff = new NoValueEffect(effects[i], element, this);
                    break;
            }
            if (eff) this.effectElements.push(eff);
        }
    };
    function BaseElement() {}
    BaseElement.prototype = {
        checkMasks: function checkMasks() {
            if (!this.data.hasMask) return false;
            var i = 0;
            var len = this.data.masksProperties.length;
            while(i < len){
                if (this.data.masksProperties[i].mode !== "n" && this.data.masksProperties[i].cl !== false) return true;
                i += 1;
            }
            return false;
        },
        initExpressions: function initExpressions() {
            this.layerInterface = LayerExpressionInterface(this);
            if (this.data.hasMask && this.maskManager) this.layerInterface.registerMaskInterface(this.maskManager);
            var effectsInterface = EffectsExpressionInterface.createEffectsInterface(this, this.layerInterface);
            this.layerInterface.registerEffectsInterface(effectsInterface);
            if (this.data.ty === 0 || this.data.xt) this.compInterface = CompExpressionInterface(this);
            else if (this.data.ty === 4) {
                this.layerInterface.shapeInterface = ShapeExpressionInterface(this.shapesData, this.itemsData, this.layerInterface);
                this.layerInterface.content = this.layerInterface.shapeInterface;
            } else if (this.data.ty === 5) {
                this.layerInterface.textInterface = TextExpressionInterface(this);
                this.layerInterface.text = this.layerInterface.textInterface;
            }
        },
        setBlendMode: function setBlendMode() {
            var blendModeValue = getBlendMode(this.data.bm);
            var elem = this.baseElement || this.layerElement;
            elem.style["mix-blend-mode"] = blendModeValue;
        },
        initBaseData: function initBaseData(data, globalData, comp) {
            this.globalData = globalData;
            this.comp = comp;
            this.data = data;
            this.layerId = createElementID(); // Stretch factor for old animations missing this property.
            if (!this.data.sr) this.data.sr = 1;
             // effects manager
            this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties);
        },
        getType: function getType() {
            return this.type;
        },
        sourceRectAtTime: function sourceRectAtTime() {}
    };
    /**
   * @file
   * Handles element's layer frame update.
   * Checks layer in point and out point
   *
   */ function FrameElement() {}
    FrameElement.prototype = {
        /**
       * @function
       * Initializes frame related properties.
       *
       */ initFrame: function initFrame() {
            // set to true when inpoint is rendered
            this._isFirstFrame = false; // list of animated properties
            this.dynamicProperties = []; // If layer has been modified in current tick this will be true
            this._mdf = false;
        },
        /**
       * @function
       * Calculates all dynamic values
       *
       * @param {number} num
       * current frame number in Layer's time
       * @param {boolean} isVisible
       * if layers is currently in range
       *
       */ prepareProperties: function prepareProperties(num, isVisible) {
            var i;
            var len = this.dynamicProperties.length;
            for(i = 0; i < len; i += 1)if (isVisible || this._isParent && this.dynamicProperties[i].propType === "transform") {
                this.dynamicProperties[i].getValue();
                if (this.dynamicProperties[i]._mdf) {
                    this.globalData._mdf = true;
                    this._mdf = true;
                }
            }
        },
        addDynamicProperty: function addDynamicProperty(prop) {
            if (this.dynamicProperties.indexOf(prop) === -1) this.dynamicProperties.push(prop);
        }
    };
    function _typeof$2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof$2 = function _typeof(obj) {
            return typeof obj;
        };
        else _typeof$2 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
        return _typeof$2(obj);
    }
    var FootageInterface = function() {
        var outlineInterfaceFactory = function outlineInterfaceFactory(elem) {
            var currentPropertyName = "";
            var currentProperty = elem.getFootageData();
            function init() {
                currentPropertyName = "";
                currentProperty = elem.getFootageData();
                return searchProperty;
            }
            function searchProperty(value) {
                if (currentProperty[value]) {
                    currentPropertyName = value;
                    currentProperty = currentProperty[value];
                    if (_typeof$2(currentProperty) === "object") return searchProperty;
                    return currentProperty;
                }
                var propertyNameIndex = value.indexOf(currentPropertyName);
                if (propertyNameIndex !== -1) {
                    var index = parseInt(value.substr(propertyNameIndex + currentPropertyName.length), 10);
                    currentProperty = currentProperty[index];
                    if (_typeof$2(currentProperty) === "object") return searchProperty;
                    return currentProperty;
                }
                return "";
            }
            return init;
        };
        var dataInterfaceFactory = function dataInterfaceFactory(elem) {
            function interfaceFunction(value) {
                if (value === "Outline") return interfaceFunction.outlineInterface();
                return null;
            }
            interfaceFunction._name = "Outline";
            interfaceFunction.outlineInterface = outlineInterfaceFactory(elem);
            return interfaceFunction;
        };
        return function(elem) {
            function _interfaceFunction(value) {
                if (value === "Data") return _interfaceFunction.dataInterface;
                return null;
            }
            _interfaceFunction._name = "Data";
            _interfaceFunction.dataInterface = dataInterfaceFactory(elem);
            return _interfaceFunction;
        };
    }();
    function FootageElement(data, globalData, comp) {
        this.initFrame();
        this.initRenderable();
        this.assetData = globalData.getAssetData(data.refId);
        this.footageData = globalData.imageLoader.getAsset(this.assetData);
        this.initBaseData(data, globalData, comp);
    }
    FootageElement.prototype.prepareFrame = function() {};
    extendPrototype([
        RenderableElement,
        BaseElement,
        FrameElement
    ], FootageElement);
    FootageElement.prototype.getBaseElement = function() {
        return null;
    };
    FootageElement.prototype.renderFrame = function() {};
    FootageElement.prototype.destroy = function() {};
    FootageElement.prototype.initExpressions = function() {
        this.layerInterface = FootageInterface(this);
    };
    FootageElement.prototype.getFootageData = function() {
        return this.footageData;
    };
    function AudioElement(data, globalData, comp) {
        this.initFrame();
        this.initRenderable();
        this.assetData = globalData.getAssetData(data.refId);
        this.initBaseData(data, globalData, comp);
        this._isPlaying = false;
        this._canPlay = false;
        var assetPath = this.globalData.getAssetsPath(this.assetData);
        this.audio = this.globalData.audioController.createAudio(assetPath);
        this._currentTime = 0;
        this.globalData.audioController.addAudio(this);
        this._volumeMultiplier = 1;
        this._volume = 1;
        this._previousVolume = null;
        this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
            _placeholder: true
        };
        this.lv = PropertyFactory.getProp(this, data.au && data.au.lv ? data.au.lv : {
            k: [
                100
            ]
        }, 1, 0.01, this);
    }
    AudioElement.prototype.prepareFrame = function(num) {
        this.prepareRenderableFrame(num, true);
        this.prepareProperties(num, true);
        if (!this.tm._placeholder) {
            var timeRemapped = this.tm.v;
            this._currentTime = timeRemapped;
        } else this._currentTime = num / this.data.sr;
        this._volume = this.lv.v[0];
        var totalVolume = this._volume * this._volumeMultiplier;
        if (this._previousVolume !== totalVolume) {
            this._previousVolume = totalVolume;
            this.audio.volume(totalVolume);
        }
    };
    extendPrototype([
        RenderableElement,
        BaseElement,
        FrameElement
    ], AudioElement);
    AudioElement.prototype.renderFrame = function() {
        if (this.isInRange && this._canPlay) {
            if (!this._isPlaying) {
                this.audio.play();
                this.audio.seek(this._currentTime / this.globalData.frameRate);
                this._isPlaying = true;
            } else if (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > 0.1) this.audio.seek(this._currentTime / this.globalData.frameRate);
        }
    };
    AudioElement.prototype.show = function() {};
    AudioElement.prototype.hide = function() {
        this.audio.pause();
        this._isPlaying = false;
    };
    AudioElement.prototype.pause = function() {
        this.audio.pause();
        this._isPlaying = false;
        this._canPlay = false;
    };
    AudioElement.prototype.resume = function() {
        this._canPlay = true;
    };
    AudioElement.prototype.setRate = function(rateValue) {
        this.audio.rate(rateValue);
    };
    AudioElement.prototype.volume = function(volumeValue) {
        this._volumeMultiplier = volumeValue;
        this._previousVolume = volumeValue * this._volume;
        this.audio.volume(this._previousVolume);
    };
    AudioElement.prototype.getBaseElement = function() {
        return null;
    };
    AudioElement.prototype.destroy = function() {};
    AudioElement.prototype.sourceRectAtTime = function() {};
    AudioElement.prototype.initExpressions = function() {};
    function BaseRenderer() {}
    BaseRenderer.prototype.checkLayers = function(num) {
        var i;
        var len = this.layers.length;
        var data;
        this.completeLayers = true;
        for(i = len - 1; i >= 0; i -= 1){
            if (!this.elements[i]) {
                data = this.layers[i];
                if (data.ip - data.st <= num - this.layers[i].st && data.op - data.st > num - this.layers[i].st) this.buildItem(i);
            }
            this.completeLayers = this.elements[i] ? this.completeLayers : false;
        }
        this.checkPendingElements();
    };
    BaseRenderer.prototype.createItem = function(layer) {
        switch(layer.ty){
            case 2:
                return this.createImage(layer);
            case 0:
                return this.createComp(layer);
            case 1:
                return this.createSolid(layer);
            case 3:
                return this.createNull(layer);
            case 4:
                return this.createShape(layer);
            case 5:
                return this.createText(layer);
            case 6:
                return this.createAudio(layer);
            case 13:
                return this.createCamera(layer);
            case 15:
                return this.createFootage(layer);
            default:
                return this.createNull(layer);
        }
    };
    BaseRenderer.prototype.createCamera = function() {
        throw new Error("You're using a 3d camera. Try the html renderer.");
    };
    BaseRenderer.prototype.createAudio = function(data) {
        return new AudioElement(data, this.globalData, this);
    };
    BaseRenderer.prototype.createFootage = function(data) {
        return new FootageElement(data, this.globalData, this);
    };
    BaseRenderer.prototype.buildAllItems = function() {
        var i;
        var len = this.layers.length;
        for(i = 0; i < len; i += 1)this.buildItem(i);
        this.checkPendingElements();
    };
    BaseRenderer.prototype.includeLayers = function(newLayers) {
        this.completeLayers = false;
        var i;
        var len = newLayers.length;
        var j;
        var jLen = this.layers.length;
        for(i = 0; i < len; i += 1){
            j = 0;
            while(j < jLen){
                if (this.layers[j].id === newLayers[i].id) {
                    this.layers[j] = newLayers[i];
                    break;
                }
                j += 1;
            }
        }
    };
    BaseRenderer.prototype.setProjectInterface = function(pInterface) {
        this.globalData.projectInterface = pInterface;
    };
    BaseRenderer.prototype.initItems = function() {
        if (!this.globalData.progressiveLoad) this.buildAllItems();
    };
    BaseRenderer.prototype.buildElementParenting = function(element, parentName, hierarchy) {
        var elements = this.elements;
        var layers = this.layers;
        var i = 0;
        var len = layers.length;
        while(i < len){
            if (layers[i].ind == parentName) {
                // eslint-disable-line eqeqeq
                if (!elements[i] || elements[i] === true) {
                    this.buildItem(i);
                    this.addPendingElement(element);
                } else {
                    hierarchy.push(elements[i]);
                    elements[i].setAsParent();
                    if (layers[i].parent !== undefined) this.buildElementParenting(element, layers[i].parent, hierarchy);
                    else element.setHierarchy(hierarchy);
                }
            }
            i += 1;
        }
    };
    BaseRenderer.prototype.addPendingElement = function(element) {
        this.pendingElements.push(element);
    };
    BaseRenderer.prototype.searchExtraCompositions = function(assets) {
        var i;
        var len = assets.length;
        for(i = 0; i < len; i += 1)if (assets[i].xt) {
            var comp = this.createComp(assets[i]);
            comp.initExpressions();
            this.globalData.projectInterface.registerComposition(comp);
        }
    };
    BaseRenderer.prototype.getElementByPath = function(path) {
        var pathValue = path.shift();
        var element;
        if (typeof pathValue === "number") element = this.elements[pathValue];
        else {
            var i;
            var len = this.elements.length;
            for(i = 0; i < len; i += 1)if (this.elements[i].data.nm === pathValue) {
                element = this.elements[i];
                break;
            }
        }
        if (path.length === 0) return element;
        return element.getElementByPath(path);
    };
    BaseRenderer.prototype.setupGlobalData = function(animData, fontsContainer) {
        this.globalData.fontManager = new FontManager();
        this.globalData.fontManager.addChars(animData.chars);
        this.globalData.fontManager.addFonts(animData.fonts, fontsContainer);
        this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);
        this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);
        this.globalData.imageLoader = this.animationItem.imagePreloader;
        this.globalData.audioController = this.animationItem.audioController;
        this.globalData.frameId = 0;
        this.globalData.frameRate = animData.fr;
        this.globalData.nm = animData.nm;
        this.globalData.compSize = {
            w: animData.w,
            h: animData.h
        };
    };
    function TransformElement() {}
    TransformElement.prototype = {
        initTransform: function initTransform() {
            this.finalTransform = {
                mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {
                    o: 0
                },
                _matMdf: false,
                _opMdf: false,
                mat: new Matrix()
            };
            if (this.data.ao) this.finalTransform.mProp.autoOriented = true;
             // TODO: check TYPE 11: Guided elements
            this.data.ty;
        },
        renderTransform: function renderTransform() {
            this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame;
            this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame;
            if (this.hierarchy) {
                var mat;
                var finalMat = this.finalTransform.mat;
                var i = 0;
                var len = this.hierarchy.length; // Checking if any of the transformation matrices in the hierarchy chain has changed.
                if (!this.finalTransform._matMdf) while(i < len){
                    if (this.hierarchy[i].finalTransform.mProp._mdf) {
                        this.finalTransform._matMdf = true;
                        break;
                    }
                    i += 1;
                }
                if (this.finalTransform._matMdf) {
                    mat = this.finalTransform.mProp.v.props;
                    finalMat.cloneFromProps(mat);
                    for(i = 0; i < len; i += 1){
                        mat = this.hierarchy[i].finalTransform.mProp.v.props;
                        finalMat.transform(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5], mat[6], mat[7], mat[8], mat[9], mat[10], mat[11], mat[12], mat[13], mat[14], mat[15]);
                    }
                }
            }
        },
        globalToLocal: function globalToLocal(pt) {
            var transforms = [];
            transforms.push(this.finalTransform);
            var flag = true;
            var comp = this.comp;
            while(flag)if (comp.finalTransform) {
                if (comp.data.hasMask) transforms.splice(0, 0, comp.finalTransform);
                comp = comp.comp;
            } else flag = false;
            var i;
            var len = transforms.length;
            var ptNew;
            for(i = 0; i < len; i += 1){
                ptNew = transforms[i].mat.applyToPointArray(0, 0, 0); // ptNew = transforms[i].mat.applyToPointArray(pt[0],pt[1],pt[2]);
                pt = [
                    pt[0] - ptNew[0],
                    pt[1] - ptNew[1],
                    0
                ];
            }
            return pt;
        },
        mHelper: new Matrix()
    };
    function MaskElement(data, element, globalData) {
        this.data = data;
        this.element = element;
        this.globalData = globalData;
        this.storedData = [];
        this.masksProperties = this.data.masksProperties || [];
        this.maskElement = null;
        var defs = this.globalData.defs;
        var i;
        var len = this.masksProperties ? this.masksProperties.length : 0;
        this.viewData = createSizedArray(len);
        this.solidPath = "";
        var path;
        var properties = this.masksProperties;
        var count = 0;
        var currentMasks = [];
        var j;
        var jLen;
        var layerId = createElementID();
        var rect;
        var expansor;
        var feMorph;
        var x;
        var maskType = "clipPath";
        var maskRef = "clip-path";
        for(i = 0; i < len; i += 1){
            if (properties[i].mode !== "a" && properties[i].mode !== "n" || properties[i].inv || properties[i].o.k !== 100 || properties[i].o.x) {
                maskType = "mask";
                maskRef = "mask";
            }
            if ((properties[i].mode === "s" || properties[i].mode === "i") && count === 0) {
                rect = createNS("rect");
                rect.setAttribute("fill", "#ffffff");
                rect.setAttribute("width", this.element.comp.data.w || 0);
                rect.setAttribute("height", this.element.comp.data.h || 0);
                currentMasks.push(rect);
            } else rect = null;
            path = createNS("path");
            if (properties[i].mode === "n") {
                // TODO move this to a factory or to a constructor
                this.viewData[i] = {
                    op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),
                    prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),
                    elem: path,
                    lastPath: ""
                };
                defs.appendChild(path);
            } else {
                count += 1;
                path.setAttribute("fill", properties[i].mode === "s" ? "#000000" : "#ffffff");
                path.setAttribute("clip-rule", "nonzero");
                var filterID;
                if (properties[i].x.k !== 0) {
                    maskType = "mask";
                    maskRef = "mask";
                    x = PropertyFactory.getProp(this.element, properties[i].x, 0, null, this.element);
                    filterID = createElementID();
                    expansor = createNS("filter");
                    expansor.setAttribute("id", filterID);
                    feMorph = createNS("feMorphology");
                    feMorph.setAttribute("operator", "erode");
                    feMorph.setAttribute("in", "SourceGraphic");
                    feMorph.setAttribute("radius", "0");
                    expansor.appendChild(feMorph);
                    defs.appendChild(expansor);
                    path.setAttribute("stroke", properties[i].mode === "s" ? "#000000" : "#ffffff");
                } else {
                    feMorph = null;
                    x = null;
                } // TODO move this to a factory or to a constructor
                this.storedData[i] = {
                    elem: path,
                    x: x,
                    expan: feMorph,
                    lastPath: "",
                    lastOperator: "",
                    filterId: filterID,
                    lastRadius: 0
                };
                if (properties[i].mode === "i") {
                    jLen = currentMasks.length;
                    var g = createNS("g");
                    for(j = 0; j < jLen; j += 1)g.appendChild(currentMasks[j]);
                    var mask = createNS("mask");
                    mask.setAttribute("mask-type", "alpha");
                    mask.setAttribute("id", layerId + "_" + count);
                    mask.appendChild(path);
                    defs.appendChild(mask);
                    g.setAttribute("mask", "url(" + getLocationHref() + "#" + layerId + "_" + count + ")");
                    currentMasks.length = 0;
                    currentMasks.push(g);
                } else currentMasks.push(path);
                if (properties[i].inv && !this.solidPath) this.solidPath = this.createLayerSolidPath();
                 // TODO move this to a factory or to a constructor
                this.viewData[i] = {
                    elem: path,
                    lastPath: "",
                    op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),
                    prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),
                    invRect: rect
                };
                if (!this.viewData[i].prop.k) this.drawPath(properties[i], this.viewData[i].prop.v, this.viewData[i]);
            }
        }
        this.maskElement = createNS(maskType);
        len = currentMasks.length;
        for(i = 0; i < len; i += 1)this.maskElement.appendChild(currentMasks[i]);
        if (count > 0) {
            this.maskElement.setAttribute("id", layerId);
            this.element.maskedElement.setAttribute(maskRef, "url(" + getLocationHref() + "#" + layerId + ")");
            defs.appendChild(this.maskElement);
        }
        if (this.viewData.length) this.element.addRenderableComponent(this);
    }
    MaskElement.prototype.getMaskProperty = function(pos) {
        return this.viewData[pos].prop;
    };
    MaskElement.prototype.renderFrame = function(isFirstFrame) {
        var finalMat = this.element.finalTransform.mat;
        var i;
        var len = this.masksProperties.length;
        for(i = 0; i < len; i += 1){
            if (this.viewData[i].prop._mdf || isFirstFrame) this.drawPath(this.masksProperties[i], this.viewData[i].prop.v, this.viewData[i]);
            if (this.viewData[i].op._mdf || isFirstFrame) this.viewData[i].elem.setAttribute("fill-opacity", this.viewData[i].op.v);
            if (this.masksProperties[i].mode !== "n") {
                if (this.viewData[i].invRect && (this.element.finalTransform.mProp._mdf || isFirstFrame)) this.viewData[i].invRect.setAttribute("transform", finalMat.getInverseMatrix().to2dCSS());
                if (this.storedData[i].x && (this.storedData[i].x._mdf || isFirstFrame)) {
                    var feMorph = this.storedData[i].expan;
                    if (this.storedData[i].x.v < 0) {
                        if (this.storedData[i].lastOperator !== "erode") {
                            this.storedData[i].lastOperator = "erode";
                            this.storedData[i].elem.setAttribute("filter", "url(" + getLocationHref() + "#" + this.storedData[i].filterId + ")");
                        }
                        feMorph.setAttribute("radius", -this.storedData[i].x.v);
                    } else {
                        if (this.storedData[i].lastOperator !== "dilate") {
                            this.storedData[i].lastOperator = "dilate";
                            this.storedData[i].elem.setAttribute("filter", null);
                        }
                        this.storedData[i].elem.setAttribute("stroke-width", this.storedData[i].x.v * 2);
                    }
                }
            }
        }
    };
    MaskElement.prototype.getMaskelement = function() {
        return this.maskElement;
    };
    MaskElement.prototype.createLayerSolidPath = function() {
        var path = "M0,0 ";
        path += " h" + this.globalData.compSize.w;
        path += " v" + this.globalData.compSize.h;
        path += " h-" + this.globalData.compSize.w;
        path += " v-" + this.globalData.compSize.h + " ";
        return path;
    };
    MaskElement.prototype.drawPath = function(pathData, pathNodes, viewData) {
        var pathString = " M" + pathNodes.v[0][0] + "," + pathNodes.v[0][1];
        var i;
        var len;
        len = pathNodes._length;
        for(i = 1; i < len; i += 1)// pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[i][0]+','+pathNodes.i[i][1] + " "+pathNodes.v[i][0]+','+pathNodes.v[i][1];
        pathString += " C" + pathNodes.o[i - 1][0] + "," + pathNodes.o[i - 1][1] + " " + pathNodes.i[i][0] + "," + pathNodes.i[i][1] + " " + pathNodes.v[i][0] + "," + pathNodes.v[i][1];
         // pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[0][0]+','+pathNodes.i[0][1] + " "+pathNodes.v[0][0]+','+pathNodes.v[0][1];
        if (pathNodes.c && len > 1) pathString += " C" + pathNodes.o[i - 1][0] + "," + pathNodes.o[i - 1][1] + " " + pathNodes.i[0][0] + "," + pathNodes.i[0][1] + " " + pathNodes.v[0][0] + "," + pathNodes.v[0][1];
         // pathNodes.__renderedString = pathString;
        if (viewData.lastPath !== pathString) {
            var pathShapeValue = "";
            if (viewData.elem) {
                if (pathNodes.c) pathShapeValue = pathData.inv ? this.solidPath + pathString : pathString;
                viewData.elem.setAttribute("d", pathShapeValue);
            }
            viewData.lastPath = pathString;
        }
    };
    MaskElement.prototype.destroy = function() {
        this.element = null;
        this.globalData = null;
        this.maskElement = null;
        this.data = null;
        this.masksProperties = null;
    };
    var filtersFactory = function() {
        var ob = {};
        ob.createFilter = createFilter;
        ob.createAlphaToLuminanceFilter = createAlphaToLuminanceFilter;
        function createFilter(filId, skipCoordinates) {
            var fil = createNS("filter");
            fil.setAttribute("id", filId);
            if (skipCoordinates !== true) {
                fil.setAttribute("filterUnits", "objectBoundingBox");
                fil.setAttribute("x", "0%");
                fil.setAttribute("y", "0%");
                fil.setAttribute("width", "100%");
                fil.setAttribute("height", "100%");
            }
            return fil;
        }
        function createAlphaToLuminanceFilter() {
            var feColorMatrix = createNS("feColorMatrix");
            feColorMatrix.setAttribute("type", "matrix");
            feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
            feColorMatrix.setAttribute("values", "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1");
            return feColorMatrix;
        }
        return ob;
    }();
    var featureSupport = function() {
        var ob = {
            maskType: true
        };
        if (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) ob.maskType = false;
        return ob;
    }();
    var registeredEffects = {};
    var idPrefix = "filter_result_";
    function SVGEffects(elem) {
        var i;
        var source = "SourceGraphic";
        var len = elem.data.ef ? elem.data.ef.length : 0;
        var filId = createElementID();
        var fil = filtersFactory.createFilter(filId, true);
        var count = 0;
        this.filters = [];
        var filterManager;
        for(i = 0; i < len; i += 1){
            filterManager = null;
            var type = elem.data.ef[i].ty;
            if (registeredEffects[type]) {
                var Effect = registeredEffects[type].effect;
                filterManager = new Effect(fil, elem.effectsManager.effectElements[i], elem, idPrefix + count, source);
                source = idPrefix + count;
                if (registeredEffects[type].countsAsEffect) count += 1;
            }
            if (filterManager) this.filters.push(filterManager);
        }
        if (count) {
            elem.globalData.defs.appendChild(fil);
            elem.layerElement.setAttribute("filter", "url(" + getLocationHref() + "#" + filId + ")");
        }
        if (this.filters.length) elem.addRenderableComponent(this);
    }
    SVGEffects.prototype.renderFrame = function(_isFirstFrame) {
        var i;
        var len = this.filters.length;
        for(i = 0; i < len; i += 1)this.filters[i].renderFrame(_isFirstFrame);
    };
    function registerEffect(id, effect, countsAsEffect) {
        registeredEffects[id] = {
            effect: effect,
            countsAsEffect: countsAsEffect
        };
    }
    function SVGBaseElement() {}
    SVGBaseElement.prototype = {
        initRendererElement: function initRendererElement() {
            this.layerElement = createNS("g");
        },
        createContainerElements: function createContainerElements() {
            this.matteElement = createNS("g");
            this.transformedElement = this.layerElement;
            this.maskedElement = this.layerElement;
            this._sizeChanged = false;
            var layerElementParent = null; // If this layer acts as a mask for the following layer
            var filId;
            var fil;
            var gg;
            if (this.data.td) {
                if (this.data.td == 3 || this.data.td == 1) {
                    // eslint-disable-line eqeqeq
                    var masker = createNS("mask");
                    masker.setAttribute("id", this.layerId);
                    masker.setAttribute("mask-type", this.data.td == 3 ? "luminance" : "alpha"); // eslint-disable-line eqeqeq
                    masker.appendChild(this.layerElement);
                    layerElementParent = masker;
                    this.globalData.defs.appendChild(masker); // This is only for IE and Edge when mask if of type alpha
                    if (!featureSupport.maskType && this.data.td == 1) {
                        // eslint-disable-line eqeqeq
                        masker.setAttribute("mask-type", "luminance");
                        filId = createElementID();
                        fil = filtersFactory.createFilter(filId);
                        this.globalData.defs.appendChild(fil);
                        fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
                        gg = createNS("g");
                        gg.appendChild(this.layerElement);
                        layerElementParent = gg;
                        masker.appendChild(gg);
                        gg.setAttribute("filter", "url(" + getLocationHref() + "#" + filId + ")");
                    }
                } else if (this.data.td == 2) {
                    // eslint-disable-line eqeqeq
                    var maskGroup = createNS("mask");
                    maskGroup.setAttribute("id", this.layerId);
                    maskGroup.setAttribute("mask-type", "alpha");
                    var maskGrouper = createNS("g");
                    maskGroup.appendChild(maskGrouper);
                    filId = createElementID();
                    fil = filtersFactory.createFilter(filId); /// /
                    // This solution doesn't work on Android when meta tag with viewport attribute is set
                    /* var feColorMatrix = createNS('feColorMatrix');
                  feColorMatrix.setAttribute('type', 'matrix');
                  feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
                  feColorMatrix.setAttribute('values','1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 -1 1');
                  fil.appendChild(feColorMatrix); */ /// /
                    var feCTr = createNS("feComponentTransfer");
                    feCTr.setAttribute("in", "SourceGraphic");
                    fil.appendChild(feCTr);
                    var feFunc = createNS("feFuncA");
                    feFunc.setAttribute("type", "table");
                    feFunc.setAttribute("tableValues", "1.0 0.0");
                    feCTr.appendChild(feFunc); /// /
                    this.globalData.defs.appendChild(fil);
                    var alphaRect = createNS("rect");
                    alphaRect.setAttribute("width", this.comp.data.w);
                    alphaRect.setAttribute("height", this.comp.data.h);
                    alphaRect.setAttribute("x", "0");
                    alphaRect.setAttribute("y", "0");
                    alphaRect.setAttribute("fill", "#ffffff");
                    alphaRect.setAttribute("opacity", "0");
                    maskGrouper.setAttribute("filter", "url(" + getLocationHref() + "#" + filId + ")");
                    maskGrouper.appendChild(alphaRect);
                    maskGrouper.appendChild(this.layerElement);
                    layerElementParent = maskGrouper;
                    if (!featureSupport.maskType) {
                        maskGroup.setAttribute("mask-type", "luminance");
                        fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
                        gg = createNS("g");
                        maskGrouper.appendChild(alphaRect);
                        gg.appendChild(this.layerElement);
                        layerElementParent = gg;
                        maskGrouper.appendChild(gg);
                    }
                    this.globalData.defs.appendChild(maskGroup);
                }
            } else if (this.data.tt) {
                this.matteElement.appendChild(this.layerElement);
                layerElementParent = this.matteElement;
                this.baseElement = this.matteElement;
            } else this.baseElement = this.layerElement;
            if (this.data.ln) this.layerElement.setAttribute("id", this.data.ln);
            if (this.data.cl) this.layerElement.setAttribute("class", this.data.cl);
             // Clipping compositions to hide content that exceeds boundaries. If collapsed transformations is on, component should not be clipped
            if (this.data.ty === 0 && !this.data.hd) {
                var cp = createNS("clipPath");
                var pt = createNS("path");
                pt.setAttribute("d", "M0,0 L" + this.data.w + ",0 L" + this.data.w + "," + this.data.h + " L0," + this.data.h + "z");
                var clipId = createElementID();
                cp.setAttribute("id", clipId);
                cp.appendChild(pt);
                this.globalData.defs.appendChild(cp);
                if (this.checkMasks()) {
                    var cpGroup = createNS("g");
                    cpGroup.setAttribute("clip-path", "url(" + getLocationHref() + "#" + clipId + ")");
                    cpGroup.appendChild(this.layerElement);
                    this.transformedElement = cpGroup;
                    if (layerElementParent) layerElementParent.appendChild(this.transformedElement);
                    else this.baseElement = this.transformedElement;
                } else this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + clipId + ")");
            }
            if (this.data.bm !== 0) this.setBlendMode();
        },
        renderElement: function renderElement() {
            if (this.finalTransform._matMdf) this.transformedElement.setAttribute("transform", this.finalTransform.mat.to2dCSS());
            if (this.finalTransform._opMdf) this.transformedElement.setAttribute("opacity", this.finalTransform.mProp.o.v);
        },
        destroyBaseElement: function destroyBaseElement() {
            this.layerElement = null;
            this.matteElement = null;
            this.maskManager.destroy();
        },
        getBaseElement: function getBaseElement() {
            if (this.data.hd) return null;
            return this.baseElement;
        },
        createRenderableComponents: function createRenderableComponents() {
            this.maskManager = new MaskElement(this.data, this, this.globalData);
            this.renderableEffectsManager = new SVGEffects(this);
        },
        setMatte: function setMatte(id) {
            if (!this.matteElement) return;
            this.matteElement.setAttribute("mask", "url(" + getLocationHref() + "#" + id + ")");
        }
    };
    /**
   * @file
   * Handles AE's layer parenting property.
   *
   */ function HierarchyElement() {}
    HierarchyElement.prototype = {
        /**
       * @function
       * Initializes hierarchy properties
       *
       */ initHierarchy: function initHierarchy() {
            // element's parent list
            this.hierarchy = []; // if element is parent of another layer _isParent will be true
            this._isParent = false;
            this.checkParenting();
        },
        /**
       * @function
       * Sets layer's hierarchy.
       * @param {array} hierarch
       * layer's parent list
       *
       */ setHierarchy: function setHierarchy(hierarchy) {
            this.hierarchy = hierarchy;
        },
        /**
       * @function
       * Sets layer as parent.
       *
       */ setAsParent: function setAsParent() {
            this._isParent = true;
        },
        /**
       * @function
       * Searches layer's parenting chain
       *
       */ checkParenting: function checkParenting() {
            if (this.data.parent !== undefined) this.comp.buildElementParenting(this, this.data.parent, []);
        }
    };
    function RenderableDOMElement() {}
    (function() {
        var _prototype = {
            initElement: function initElement(data, globalData, comp) {
                this.initFrame();
                this.initBaseData(data, globalData, comp);
                this.initTransform(data, globalData, comp);
                this.initHierarchy();
                this.initRenderable();
                this.initRendererElement();
                this.createContainerElements();
                this.createRenderableComponents();
                this.createContent();
                this.hide();
            },
            hide: function hide() {
                // console.log('HIDE', this);
                if (!this.hidden && (!this.isInRange || this.isTransparent)) {
                    var elem = this.baseElement || this.layerElement;
                    elem.style.display = "none";
                    this.hidden = true;
                }
            },
            show: function show() {
                // console.log('SHOW', this);
                if (this.isInRange && !this.isTransparent) {
                    if (!this.data.hd) {
                        var elem = this.baseElement || this.layerElement;
                        elem.style.display = "block";
                    }
                    this.hidden = false;
                    this._isFirstFrame = true;
                }
            },
            renderFrame: function renderFrame() {
                // If it is exported as hidden (data.hd === true) no need to render
                // If it is not visible no need to render
                if (this.data.hd || this.hidden) return;
                this.renderTransform();
                this.renderRenderable();
                this.renderElement();
                this.renderInnerContent();
                if (this._isFirstFrame) this._isFirstFrame = false;
            },
            renderInnerContent: function renderInnerContent() {},
            prepareFrame: function prepareFrame(num) {
                this._mdf = false;
                this.prepareRenderableFrame(num);
                this.prepareProperties(num, this.isInRange);
                this.checkTransparency();
            },
            destroy: function destroy() {
                this.innerElem = null;
                this.destroyBaseElement();
            }
        };
        extendPrototype([
            RenderableElement,
            createProxyFunction(_prototype)
        ], RenderableDOMElement);
    })();
    function IImageElement(data, globalData, comp) {
        this.assetData = globalData.getAssetData(data.refId);
        this.initElement(data, globalData, comp);
        this.sourceRect = {
            top: 0,
            left: 0,
            width: this.assetData.w,
            height: this.assetData.h
        };
    }
    extendPrototype([
        BaseElement,
        TransformElement,
        SVGBaseElement,
        HierarchyElement,
        FrameElement,
        RenderableDOMElement
    ], IImageElement);
    IImageElement.prototype.createContent = function() {
        var assetPath = this.globalData.getAssetsPath(this.assetData);
        this.innerElem = createNS("image");
        this.innerElem.setAttribute("width", this.assetData.w + "px");
        this.innerElem.setAttribute("height", this.assetData.h + "px");
        this.innerElem.setAttribute("preserveAspectRatio", this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio);
        this.innerElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", assetPath);
        this.layerElement.appendChild(this.innerElem);
    };
    IImageElement.prototype.sourceRectAtTime = function() {
        return this.sourceRect;
    };
    function ProcessedElement(element, position) {
        this.elem = element;
        this.pos = position;
    }
    function IShapeElement() {}
    IShapeElement.prototype = {
        addShapeToModifiers: function addShapeToModifiers(data) {
            var i;
            var len = this.shapeModifiers.length;
            for(i = 0; i < len; i += 1)this.shapeModifiers[i].addShape(data);
        },
        isShapeInAnimatedModifiers: function isShapeInAnimatedModifiers(data) {
            var i = 0;
            var len = this.shapeModifiers.length;
            while(i < len){
                if (this.shapeModifiers[i].isAnimatedWithShape(data)) return true;
            }
            return false;
        },
        renderModifiers: function renderModifiers() {
            if (!this.shapeModifiers.length) return;
            var i;
            var len = this.shapes.length;
            for(i = 0; i < len; i += 1)this.shapes[i].sh.reset();
            len = this.shapeModifiers.length;
            var shouldBreakProcess;
            for(i = len - 1; i >= 0; i -= 1){
                shouldBreakProcess = this.shapeModifiers[i].processShapes(this._isFirstFrame); // workaround to fix cases where a repeater resets the shape so the following processes get called twice
                // TODO: find a better solution for this
                if (shouldBreakProcess) break;
            }
        },
        searchProcessedElement: function searchProcessedElement(elem) {
            var elements = this.processedElements;
            var i = 0;
            var len = elements.length;
            while(i < len){
                if (elements[i].elem === elem) return elements[i].pos;
                i += 1;
            }
            return 0;
        },
        addProcessedElement: function addProcessedElement(elem, pos) {
            var elements = this.processedElements;
            var i = elements.length;
            while(i){
                i -= 1;
                if (elements[i].elem === elem) {
                    elements[i].pos = pos;
                    return;
                }
            }
            elements.push(new ProcessedElement(elem, pos));
        },
        prepareFrame: function prepareFrame(num) {
            this.prepareRenderableFrame(num);
            this.prepareProperties(num, this.isInRange);
        }
    };
    var lineCapEnum = {
        1: "butt",
        2: "round",
        3: "square"
    };
    var lineJoinEnum = {
        1: "miter",
        2: "round",
        3: "bevel"
    };
    function SVGShapeData(transformers, level, shape) {
        this.caches = [];
        this.styles = [];
        this.transformers = transformers;
        this.lStr = "";
        this.sh = shape;
        this.lvl = level; // TODO find if there are some cases where _isAnimated can be false.
        // For now, since shapes add up with other shapes. They have to be calculated every time.
        // One way of finding out is checking if all styles associated to this shape depend only of this shape
        this._isAnimated = !!shape.k; // TODO: commenting this for now since all shapes are animated
        var i = 0;
        var len = transformers.length;
        while(i < len){
            if (transformers[i].mProps.dynamicProperties.length) {
                this._isAnimated = true;
                break;
            }
            i += 1;
        }
    }
    SVGShapeData.prototype.setAsAnimated = function() {
        this._isAnimated = true;
    };
    function SVGStyleData(data, level) {
        this.data = data;
        this.type = data.ty;
        this.d = "";
        this.lvl = level;
        this._mdf = false;
        this.closed = data.hd === true;
        this.pElem = createNS("path");
        this.msElem = null;
    }
    SVGStyleData.prototype.reset = function() {
        this.d = "";
        this._mdf = false;
    };
    function DashProperty(elem, data, renderer, container) {
        this.elem = elem;
        this.frameId = -1;
        this.dataProps = createSizedArray(data.length);
        this.renderer = renderer;
        this.k = false;
        this.dashStr = "";
        this.dashArray = createTypedArray("float32", data.length ? data.length - 1 : 0);
        this.dashoffset = createTypedArray("float32", 1);
        this.initDynamicPropertyContainer(container);
        var i;
        var len = data.length || 0;
        var prop;
        for(i = 0; i < len; i += 1){
            prop = PropertyFactory.getProp(elem, data[i].v, 0, 0, this);
            this.k = prop.k || this.k;
            this.dataProps[i] = {
                n: data[i].n,
                p: prop
            };
        }
        if (!this.k) this.getValue(true);
        this._isAnimated = this.k;
    }
    DashProperty.prototype.getValue = function(forceRender) {
        if (this.elem.globalData.frameId === this.frameId && !forceRender) return;
        this.frameId = this.elem.globalData.frameId;
        this.iterateDynamicProperties();
        this._mdf = this._mdf || forceRender;
        if (this._mdf) {
            var i = 0;
            var len = this.dataProps.length;
            if (this.renderer === "svg") this.dashStr = "";
            for(i = 0; i < len; i += 1)if (this.dataProps[i].n !== "o") {
                if (this.renderer === "svg") this.dashStr += " " + this.dataProps[i].p.v;
                else this.dashArray[i] = this.dataProps[i].p.v;
            } else this.dashoffset[0] = this.dataProps[i].p.v;
        }
    };
    extendPrototype([
        DynamicPropertyContainer
    ], DashProperty);
    function SVGStrokeStyleData(elem, data, styleOb) {
        this.initDynamicPropertyContainer(elem);
        this.getValue = this.iterateDynamicProperties;
        this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
        this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);
        this.d = new DashProperty(elem, data.d || {}, "svg", this);
        this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);
        this.style = styleOb;
        this._isAnimated = !!this._isAnimated;
    }
    extendPrototype([
        DynamicPropertyContainer
    ], SVGStrokeStyleData);
    function SVGFillStyleData(elem, data, styleOb) {
        this.initDynamicPropertyContainer(elem);
        this.getValue = this.iterateDynamicProperties;
        this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
        this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);
        this.style = styleOb;
    }
    extendPrototype([
        DynamicPropertyContainer
    ], SVGFillStyleData);
    function SVGNoStyleData(elem, data, styleOb) {
        this.initDynamicPropertyContainer(elem);
        this.getValue = this.iterateDynamicProperties;
        this.style = styleOb;
    }
    extendPrototype([
        DynamicPropertyContainer
    ], SVGNoStyleData);
    function GradientProperty(elem, data, container) {
        this.data = data;
        this.c = createTypedArray("uint8c", data.p * 4);
        var cLength = data.k.k[0].s ? data.k.k[0].s.length - data.p * 4 : data.k.k.length - data.p * 4;
        this.o = createTypedArray("float32", cLength);
        this._cmdf = false;
        this._omdf = false;
        this._collapsable = this.checkCollapsable();
        this._hasOpacity = cLength;
        this.initDynamicPropertyContainer(container);
        this.prop = PropertyFactory.getProp(elem, data.k, 1, null, this);
        this.k = this.prop.k;
        this.getValue(true);
    }
    GradientProperty.prototype.comparePoints = function(values, points) {
        var i = 0;
        var len = this.o.length / 2;
        var diff;
        while(i < len){
            diff = Math.abs(values[i * 4] - values[points * 4 + i * 2]);
            if (diff > 0.01) return false;
            i += 1;
        }
        return true;
    };
    GradientProperty.prototype.checkCollapsable = function() {
        if (this.o.length / 2 !== this.c.length / 4) return false;
        if (this.data.k.k[0].s) {
            var i = 0;
            var len = this.data.k.k.length;
            while(i < len){
                if (!this.comparePoints(this.data.k.k[i].s, this.data.p)) return false;
                i += 1;
            }
        } else if (!this.comparePoints(this.data.k.k, this.data.p)) return false;
        return true;
    };
    GradientProperty.prototype.getValue = function(forceRender) {
        this.prop.getValue();
        this._mdf = false;
        this._cmdf = false;
        this._omdf = false;
        if (this.prop._mdf || forceRender) {
            var i;
            var len = this.data.p * 4;
            var mult;
            var val;
            for(i = 0; i < len; i += 1){
                mult = i % 4 === 0 ? 100 : 255;
                val = Math.round(this.prop.v[i] * mult);
                if (this.c[i] !== val) {
                    this.c[i] = val;
                    this._cmdf = !forceRender;
                }
            }
            if (this.o.length) {
                len = this.prop.v.length;
                for(i = this.data.p * 4; i < len; i += 1){
                    mult = i % 2 === 0 ? 100 : 1;
                    val = i % 2 === 0 ? Math.round(this.prop.v[i] * 100) : this.prop.v[i];
                    if (this.o[i - this.data.p * 4] !== val) {
                        this.o[i - this.data.p * 4] = val;
                        this._omdf = !forceRender;
                    }
                }
            }
            this._mdf = !forceRender;
        }
    };
    extendPrototype([
        DynamicPropertyContainer
    ], GradientProperty);
    function SVGGradientFillStyleData(elem, data, styleOb) {
        this.initDynamicPropertyContainer(elem);
        this.getValue = this.iterateDynamicProperties;
        this.initGradientData(elem, data, styleOb);
    }
    SVGGradientFillStyleData.prototype.initGradientData = function(elem, data, styleOb) {
        this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
        this.s = PropertyFactory.getProp(elem, data.s, 1, null, this);
        this.e = PropertyFactory.getProp(elem, data.e, 1, null, this);
        this.h = PropertyFactory.getProp(elem, data.h || {
            k: 0
        }, 0, 0.01, this);
        this.a = PropertyFactory.getProp(elem, data.a || {
            k: 0
        }, 0, degToRads, this);
        this.g = new GradientProperty(elem, data.g, this);
        this.style = styleOb;
        this.stops = [];
        this.setGradientData(styleOb.pElem, data);
        this.setGradientOpacity(data, styleOb);
        this._isAnimated = !!this._isAnimated;
    };
    SVGGradientFillStyleData.prototype.setGradientData = function(pathElement, data) {
        var gradientId = createElementID();
        var gfill = createNS(data.t === 1 ? "linearGradient" : "radialGradient");
        gfill.setAttribute("id", gradientId);
        gfill.setAttribute("spreadMethod", "pad");
        gfill.setAttribute("gradientUnits", "userSpaceOnUse");
        var stops = [];
        var stop;
        var j;
        var jLen;
        jLen = data.g.p * 4;
        for(j = 0; j < jLen; j += 4){
            stop = createNS("stop");
            gfill.appendChild(stop);
            stops.push(stop);
        }
        pathElement.setAttribute(data.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + gradientId + ")");
        this.gf = gfill;
        this.cst = stops;
    };
    SVGGradientFillStyleData.prototype.setGradientOpacity = function(data, styleOb) {
        if (this.g._hasOpacity && !this.g._collapsable) {
            var stop;
            var j;
            var jLen;
            var mask = createNS("mask");
            var maskElement = createNS("path");
            mask.appendChild(maskElement);
            var opacityId = createElementID();
            var maskId = createElementID();
            mask.setAttribute("id", maskId);
            var opFill = createNS(data.t === 1 ? "linearGradient" : "radialGradient");
            opFill.setAttribute("id", opacityId);
            opFill.setAttribute("spreadMethod", "pad");
            opFill.setAttribute("gradientUnits", "userSpaceOnUse");
            jLen = data.g.k.k[0].s ? data.g.k.k[0].s.length : data.g.k.k.length;
            var stops = this.stops;
            for(j = data.g.p * 4; j < jLen; j += 2){
                stop = createNS("stop");
                stop.setAttribute("stop-color", "rgb(255,255,255)");
                opFill.appendChild(stop);
                stops.push(stop);
            }
            maskElement.setAttribute(data.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + opacityId + ")");
            if (data.ty === "gs") {
                maskElement.setAttribute("stroke-linecap", lineCapEnum[data.lc || 2]);
                maskElement.setAttribute("stroke-linejoin", lineJoinEnum[data.lj || 2]);
                if (data.lj === 1) maskElement.setAttribute("stroke-miterlimit", data.ml);
            }
            this.of = opFill;
            this.ms = mask;
            this.ost = stops;
            this.maskId = maskId;
            styleOb.msElem = maskElement;
        }
    };
    extendPrototype([
        DynamicPropertyContainer
    ], SVGGradientFillStyleData);
    function SVGGradientStrokeStyleData(elem, data, styleOb) {
        this.initDynamicPropertyContainer(elem);
        this.getValue = this.iterateDynamicProperties;
        this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);
        this.d = new DashProperty(elem, data.d || {}, "svg", this);
        this.initGradientData(elem, data, styleOb);
        this._isAnimated = !!this._isAnimated;
    }
    extendPrototype([
        SVGGradientFillStyleData,
        DynamicPropertyContainer
    ], SVGGradientStrokeStyleData);
    function ShapeGroupData() {
        this.it = [];
        this.prevViewData = [];
        this.gr = createNS("g");
    }
    function SVGTransformData(mProps, op, container) {
        this.transform = {
            mProps: mProps,
            op: op,
            container: container
        };
        this.elements = [];
        this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length;
    }
    var buildShapeString = function buildShapeString(pathNodes, length, closed, mat) {
        if (length === 0) return "";
        var _o = pathNodes.o;
        var _i = pathNodes.i;
        var _v = pathNodes.v;
        var i;
        var shapeString = " M" + mat.applyToPointStringified(_v[0][0], _v[0][1]);
        for(i = 1; i < length; i += 1)shapeString += " C" + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + " " + mat.applyToPointStringified(_i[i][0], _i[i][1]) + " " + mat.applyToPointStringified(_v[i][0], _v[i][1]);
        if (closed && length) {
            shapeString += " C" + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + " " + mat.applyToPointStringified(_i[0][0], _i[0][1]) + " " + mat.applyToPointStringified(_v[0][0], _v[0][1]);
            shapeString += "z";
        }
        return shapeString;
    };
    var SVGElementsRenderer = function() {
        var _identityMatrix = new Matrix();
        var _matrixHelper = new Matrix();
        var ob = {
            createRenderFunction: createRenderFunction
        };
        function createRenderFunction(data) {
            switch(data.ty){
                case "fl":
                    return renderFill;
                case "gf":
                    return renderGradient;
                case "gs":
                    return renderGradientStroke;
                case "st":
                    return renderStroke;
                case "sh":
                case "el":
                case "rc":
                case "sr":
                    return renderPath;
                case "tr":
                    return renderContentTransform;
                case "no":
                    return renderNoop;
                default:
                    return null;
            }
        }
        function renderContentTransform(styleData, itemData, isFirstFrame) {
            if (isFirstFrame || itemData.transform.op._mdf) itemData.transform.container.setAttribute("opacity", itemData.transform.op.v);
            if (isFirstFrame || itemData.transform.mProps._mdf) itemData.transform.container.setAttribute("transform", itemData.transform.mProps.v.to2dCSS());
        }
        function renderNoop() {}
        function renderPath(styleData, itemData, isFirstFrame) {
            var j;
            var jLen;
            var pathStringTransformed;
            var redraw;
            var pathNodes;
            var l;
            var lLen = itemData.styles.length;
            var lvl = itemData.lvl;
            var paths;
            var mat;
            var props;
            var iterations;
            var k;
            for(l = 0; l < lLen; l += 1){
                redraw = itemData.sh._mdf || isFirstFrame;
                if (itemData.styles[l].lvl < lvl) {
                    mat = _matrixHelper.reset();
                    iterations = lvl - itemData.styles[l].lvl;
                    k = itemData.transformers.length - 1;
                    while(!redraw && iterations > 0){
                        redraw = itemData.transformers[k].mProps._mdf || redraw;
                        iterations -= 1;
                        k -= 1;
                    }
                    if (redraw) {
                        iterations = lvl - itemData.styles[l].lvl;
                        k = itemData.transformers.length - 1;
                        while(iterations > 0){
                            props = itemData.transformers[k].mProps.v.props;
                            mat.transform(props[0], props[1], props[2], props[3], props[4], props[5], props[6], props[7], props[8], props[9], props[10], props[11], props[12], props[13], props[14], props[15]);
                            iterations -= 1;
                            k -= 1;
                        }
                    }
                } else mat = _identityMatrix;
                paths = itemData.sh.paths;
                jLen = paths._length;
                if (redraw) {
                    pathStringTransformed = "";
                    for(j = 0; j < jLen; j += 1){
                        pathNodes = paths.shapes[j];
                        if (pathNodes && pathNodes._length) pathStringTransformed += buildShapeString(pathNodes, pathNodes._length, pathNodes.c, mat);
                    }
                    itemData.caches[l] = pathStringTransformed;
                } else pathStringTransformed = itemData.caches[l];
                itemData.styles[l].d += styleData.hd === true ? "" : pathStringTransformed;
                itemData.styles[l]._mdf = redraw || itemData.styles[l]._mdf;
            }
        }
        function renderFill(styleData, itemData, isFirstFrame) {
            var styleElem = itemData.style;
            if (itemData.c._mdf || isFirstFrame) styleElem.pElem.setAttribute("fill", "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")");
            if (itemData.o._mdf || isFirstFrame) styleElem.pElem.setAttribute("fill-opacity", itemData.o.v);
        }
        function renderGradientStroke(styleData, itemData, isFirstFrame) {
            renderGradient(styleData, itemData, isFirstFrame);
            renderStroke(styleData, itemData, isFirstFrame);
        }
        function renderGradient(styleData, itemData, isFirstFrame) {
            var gfill = itemData.gf;
            var hasOpacity = itemData.g._hasOpacity;
            var pt1 = itemData.s.v;
            var pt2 = itemData.e.v;
            if (itemData.o._mdf || isFirstFrame) {
                var attr = styleData.ty === "gf" ? "fill-opacity" : "stroke-opacity";
                itemData.style.pElem.setAttribute(attr, itemData.o.v);
            }
            if (itemData.s._mdf || isFirstFrame) {
                var attr1 = styleData.t === 1 ? "x1" : "cx";
                var attr2 = attr1 === "x1" ? "y1" : "cy";
                gfill.setAttribute(attr1, pt1[0]);
                gfill.setAttribute(attr2, pt1[1]);
                if (hasOpacity && !itemData.g._collapsable) {
                    itemData.of.setAttribute(attr1, pt1[0]);
                    itemData.of.setAttribute(attr2, pt1[1]);
                }
            }
            var stops;
            var i;
            var len;
            var stop;
            if (itemData.g._cmdf || isFirstFrame) {
                stops = itemData.cst;
                var cValues = itemData.g.c;
                len = stops.length;
                for(i = 0; i < len; i += 1){
                    stop = stops[i];
                    stop.setAttribute("offset", cValues[i * 4] + "%");
                    stop.setAttribute("stop-color", "rgb(" + cValues[i * 4 + 1] + "," + cValues[i * 4 + 2] + "," + cValues[i * 4 + 3] + ")");
                }
            }
            if (hasOpacity && (itemData.g._omdf || isFirstFrame)) {
                var oValues = itemData.g.o;
                if (itemData.g._collapsable) stops = itemData.cst;
                else stops = itemData.ost;
                len = stops.length;
                for(i = 0; i < len; i += 1){
                    stop = stops[i];
                    if (!itemData.g._collapsable) stop.setAttribute("offset", oValues[i * 2] + "%");
                    stop.setAttribute("stop-opacity", oValues[i * 2 + 1]);
                }
            }
            if (styleData.t === 1) {
                if (itemData.e._mdf || isFirstFrame) {
                    gfill.setAttribute("x2", pt2[0]);
                    gfill.setAttribute("y2", pt2[1]);
                    if (hasOpacity && !itemData.g._collapsable) {
                        itemData.of.setAttribute("x2", pt2[0]);
                        itemData.of.setAttribute("y2", pt2[1]);
                    }
                }
            } else {
                var rad;
                if (itemData.s._mdf || itemData.e._mdf || isFirstFrame) {
                    rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
                    gfill.setAttribute("r", rad);
                    if (hasOpacity && !itemData.g._collapsable) itemData.of.setAttribute("r", rad);
                }
                if (itemData.e._mdf || itemData.h._mdf || itemData.a._mdf || isFirstFrame) {
                    if (!rad) rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
                    var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
                    var percent = itemData.h.v;
                    if (percent >= 1) percent = 0.99;
                    else if (percent <= -1) percent = -0.99;
                    var dist = rad * percent;
                    var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
                    var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
                    gfill.setAttribute("fx", x);
                    gfill.setAttribute("fy", y);
                    if (hasOpacity && !itemData.g._collapsable) {
                        itemData.of.setAttribute("fx", x);
                        itemData.of.setAttribute("fy", y);
                    }
                } // gfill.setAttribute('fy','200');
            }
        }
        function renderStroke(styleData, itemData, isFirstFrame) {
            var styleElem = itemData.style;
            var d = itemData.d;
            if (d && (d._mdf || isFirstFrame) && d.dashStr) {
                styleElem.pElem.setAttribute("stroke-dasharray", d.dashStr);
                styleElem.pElem.setAttribute("stroke-dashoffset", d.dashoffset[0]);
            }
            if (itemData.c && (itemData.c._mdf || isFirstFrame)) styleElem.pElem.setAttribute("stroke", "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")");
            if (itemData.o._mdf || isFirstFrame) styleElem.pElem.setAttribute("stroke-opacity", itemData.o.v);
            if (itemData.w._mdf || isFirstFrame) {
                styleElem.pElem.setAttribute("stroke-width", itemData.w.v);
                if (styleElem.msElem) styleElem.msElem.setAttribute("stroke-width", itemData.w.v);
            }
        }
        return ob;
    }();
    function SVGShapeElement(data, globalData, comp) {
        // List of drawable elements
        this.shapes = []; // Full shape data
        this.shapesData = data.shapes; // List of styles that will be applied to shapes
        this.stylesList = []; // List of modifiers that will be applied to shapes
        this.shapeModifiers = []; // List of items in shape tree
        this.itemsData = []; // List of items in previous shape tree
        this.processedElements = []; // List of animated components
        this.animatedContents = [];
        this.initElement(data, globalData, comp); // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
        // List of elements that have been created
        this.prevViewData = []; // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
    }
    extendPrototype([
        BaseElement,
        TransformElement,
        SVGBaseElement,
        IShapeElement,
        HierarchyElement,
        FrameElement,
        RenderableDOMElement
    ], SVGShapeElement);
    SVGShapeElement.prototype.initSecondaryElement = function() {};
    SVGShapeElement.prototype.identityMatrix = new Matrix();
    SVGShapeElement.prototype.buildExpressionInterface = function() {};
    SVGShapeElement.prototype.createContent = function() {
        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
        this.filterUniqueShapes();
    };
    /*
  This method searches for multiple shapes that affect a single element and one of them is animated
  */ SVGShapeElement.prototype.filterUniqueShapes = function() {
        var i;
        var len = this.shapes.length;
        var shape;
        var j;
        var jLen = this.stylesList.length;
        var style;
        var tempShapes = [];
        var areAnimated = false;
        for(j = 0; j < jLen; j += 1){
            style = this.stylesList[j];
            areAnimated = false;
            tempShapes.length = 0;
            for(i = 0; i < len; i += 1){
                shape = this.shapes[i];
                if (shape.styles.indexOf(style) !== -1) {
                    tempShapes.push(shape);
                    areAnimated = shape._isAnimated || areAnimated;
                }
            }
            if (tempShapes.length > 1 && areAnimated) this.setShapesAsAnimated(tempShapes);
        }
    };
    SVGShapeElement.prototype.setShapesAsAnimated = function(shapes) {
        var i;
        var len = shapes.length;
        for(i = 0; i < len; i += 1)shapes[i].setAsAnimated();
    };
    SVGShapeElement.prototype.createStyleElement = function(data, level) {
        // TODO: prevent drawing of hidden styles
        var elementData;
        var styleOb = new SVGStyleData(data, level);
        var pathElement = styleOb.pElem;
        if (data.ty === "st") elementData = new SVGStrokeStyleData(this, data, styleOb);
        else if (data.ty === "fl") elementData = new SVGFillStyleData(this, data, styleOb);
        else if (data.ty === "gf" || data.ty === "gs") {
            var GradientConstructor = data.ty === "gf" ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;
            elementData = new GradientConstructor(this, data, styleOb);
            this.globalData.defs.appendChild(elementData.gf);
            if (elementData.maskId) {
                this.globalData.defs.appendChild(elementData.ms);
                this.globalData.defs.appendChild(elementData.of);
                pathElement.setAttribute("mask", "url(" + getLocationHref() + "#" + elementData.maskId + ")");
            }
        } else if (data.ty === "no") elementData = new SVGNoStyleData(this, data, styleOb);
        if (data.ty === "st" || data.ty === "gs") {
            pathElement.setAttribute("stroke-linecap", lineCapEnum[data.lc || 2]);
            pathElement.setAttribute("stroke-linejoin", lineJoinEnum[data.lj || 2]);
            pathElement.setAttribute("fill-opacity", "0");
            if (data.lj === 1) pathElement.setAttribute("stroke-miterlimit", data.ml);
        }
        if (data.r === 2) pathElement.setAttribute("fill-rule", "evenodd");
        if (data.ln) pathElement.setAttribute("id", data.ln);
        if (data.cl) pathElement.setAttribute("class", data.cl);
        if (data.bm) pathElement.style["mix-blend-mode"] = getBlendMode(data.bm);
        this.stylesList.push(styleOb);
        this.addToAnimatedContents(data, elementData);
        return elementData;
    };
    SVGShapeElement.prototype.createGroupElement = function(data) {
        var elementData = new ShapeGroupData();
        if (data.ln) elementData.gr.setAttribute("id", data.ln);
        if (data.cl) elementData.gr.setAttribute("class", data.cl);
        if (data.bm) elementData.gr.style["mix-blend-mode"] = getBlendMode(data.bm);
        return elementData;
    };
    SVGShapeElement.prototype.createTransformElement = function(data, container) {
        var transformProperty = TransformPropertyFactory.getTransformProperty(this, data, this);
        var elementData = new SVGTransformData(transformProperty, transformProperty.o, container);
        this.addToAnimatedContents(data, elementData);
        return elementData;
    };
    SVGShapeElement.prototype.createShapeElement = function(data, ownTransformers, level) {
        var ty = 4;
        if (data.ty === "rc") ty = 5;
        else if (data.ty === "el") ty = 6;
        else if (data.ty === "sr") ty = 7;
        var shapeProperty = ShapePropertyFactory.getShapeProp(this, data, ty, this);
        var elementData = new SVGShapeData(ownTransformers, level, shapeProperty);
        this.shapes.push(elementData);
        this.addShapeToModifiers(elementData);
        this.addToAnimatedContents(data, elementData);
        return elementData;
    };
    SVGShapeElement.prototype.addToAnimatedContents = function(data, element) {
        var i = 0;
        var len = this.animatedContents.length;
        while(i < len){
            if (this.animatedContents[i].element === element) return;
            i += 1;
        }
        this.animatedContents.push({
            fn: SVGElementsRenderer.createRenderFunction(data),
            element: element,
            data: data
        });
    };
    SVGShapeElement.prototype.setElementStyles = function(elementData) {
        var arr = elementData.styles;
        var j;
        var jLen = this.stylesList.length;
        for(j = 0; j < jLen; j += 1)if (!this.stylesList[j].closed) arr.push(this.stylesList[j]);
    };
    SVGShapeElement.prototype.reloadShapes = function() {
        this._isFirstFrame = true;
        var i;
        var len = this.itemsData.length;
        for(i = 0; i < len; i += 1)this.prevViewData[i] = this.itemsData[i];
        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
        this.filterUniqueShapes();
        len = this.dynamicProperties.length;
        for(i = 0; i < len; i += 1)this.dynamicProperties[i].getValue();
        this.renderModifiers();
    };
    SVGShapeElement.prototype.searchShapes = function(arr, itemsData, prevViewData, container, level, transformers, render) {
        var ownTransformers = [].concat(transformers);
        var i;
        var len = arr.length - 1;
        var j;
        var jLen;
        var ownStyles = [];
        var ownModifiers = [];
        var currentTransform;
        var modifier;
        var processedPos;
        for(i = len; i >= 0; i -= 1){
            processedPos = this.searchProcessedElement(arr[i]);
            if (!processedPos) arr[i]._render = render;
            else itemsData[i] = prevViewData[processedPos - 1];
            if (arr[i].ty === "fl" || arr[i].ty === "st" || arr[i].ty === "gf" || arr[i].ty === "gs" || arr[i].ty === "no") {
                if (!processedPos) itemsData[i] = this.createStyleElement(arr[i], level);
                else itemsData[i].style.closed = false;
                if (arr[i]._render) {
                    if (itemsData[i].style.pElem.parentNode !== container) container.appendChild(itemsData[i].style.pElem);
                }
                ownStyles.push(itemsData[i].style);
            } else if (arr[i].ty === "gr") {
                if (!processedPos) itemsData[i] = this.createGroupElement(arr[i]);
                else {
                    jLen = itemsData[i].it.length;
                    for(j = 0; j < jLen; j += 1)itemsData[i].prevViewData[j] = itemsData[i].it[j];
                }
                this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, itemsData[i].gr, level + 1, ownTransformers, render);
                if (arr[i]._render) {
                    if (itemsData[i].gr.parentNode !== container) container.appendChild(itemsData[i].gr);
                }
            } else if (arr[i].ty === "tr") {
                if (!processedPos) itemsData[i] = this.createTransformElement(arr[i], container);
                currentTransform = itemsData[i].transform;
                ownTransformers.push(currentTransform);
            } else if (arr[i].ty === "sh" || arr[i].ty === "rc" || arr[i].ty === "el" || arr[i].ty === "sr") {
                if (!processedPos) itemsData[i] = this.createShapeElement(arr[i], ownTransformers, level);
                this.setElementStyles(itemsData[i]);
            } else if (arr[i].ty === "tm" || arr[i].ty === "rd" || arr[i].ty === "ms" || arr[i].ty === "pb") {
                if (!processedPos) {
                    modifier = ShapeModifiers.getModifier(arr[i].ty);
                    modifier.init(this, arr[i]);
                    itemsData[i] = modifier;
                    this.shapeModifiers.push(modifier);
                } else {
                    modifier = itemsData[i];
                    modifier.closed = false;
                }
                ownModifiers.push(modifier);
            } else if (arr[i].ty === "rp") {
                if (!processedPos) {
                    modifier = ShapeModifiers.getModifier(arr[i].ty);
                    itemsData[i] = modifier;
                    modifier.init(this, arr, i, itemsData);
                    this.shapeModifiers.push(modifier);
                    render = false;
                } else {
                    modifier = itemsData[i];
                    modifier.closed = true;
                }
                ownModifiers.push(modifier);
            }
            this.addProcessedElement(arr[i], i + 1);
        }
        len = ownStyles.length;
        for(i = 0; i < len; i += 1)ownStyles[i].closed = true;
        len = ownModifiers.length;
        for(i = 0; i < len; i += 1)ownModifiers[i].closed = true;
    };
    SVGShapeElement.prototype.renderInnerContent = function() {
        this.renderModifiers();
        var i;
        var len = this.stylesList.length;
        for(i = 0; i < len; i += 1)this.stylesList[i].reset();
        this.renderShape();
        for(i = 0; i < len; i += 1)if (this.stylesList[i]._mdf || this._isFirstFrame) {
            if (this.stylesList[i].msElem) {
                this.stylesList[i].msElem.setAttribute("d", this.stylesList[i].d); // Adding M0 0 fixes same mask bug on all browsers
                this.stylesList[i].d = "M0 0" + this.stylesList[i].d;
            }
            this.stylesList[i].pElem.setAttribute("d", this.stylesList[i].d || "M0 0");
        }
    };
    SVGShapeElement.prototype.renderShape = function() {
        var i;
        var len = this.animatedContents.length;
        var animatedContent;
        for(i = 0; i < len; i += 1){
            animatedContent = this.animatedContents[i];
            if ((this._isFirstFrame || animatedContent.element._isAnimated) && animatedContent.data !== true) animatedContent.fn(animatedContent.data, animatedContent.element, this._isFirstFrame);
        }
    };
    SVGShapeElement.prototype.destroy = function() {
        this.destroyBaseElement();
        this.shapesData = null;
        this.itemsData = null;
    };
    function LetterProps(o, sw, sc, fc, m, p) {
        this.o = o;
        this.sw = sw;
        this.sc = sc;
        this.fc = fc;
        this.m = m;
        this.p = p;
        this._mdf = {
            o: true,
            sw: !!sw,
            sc: !!sc,
            fc: !!fc,
            m: true,
            p: true
        };
    }
    LetterProps.prototype.update = function(o, sw, sc, fc, m, p) {
        this._mdf.o = false;
        this._mdf.sw = false;
        this._mdf.sc = false;
        this._mdf.fc = false;
        this._mdf.m = false;
        this._mdf.p = false;
        var updated = false;
        if (this.o !== o) {
            this.o = o;
            this._mdf.o = true;
            updated = true;
        }
        if (this.sw !== sw) {
            this.sw = sw;
            this._mdf.sw = true;
            updated = true;
        }
        if (this.sc !== sc) {
            this.sc = sc;
            this._mdf.sc = true;
            updated = true;
        }
        if (this.fc !== fc) {
            this.fc = fc;
            this._mdf.fc = true;
            updated = true;
        }
        if (this.m !== m) {
            this.m = m;
            this._mdf.m = true;
            updated = true;
        }
        if (p.length && (this.p[0] !== p[0] || this.p[1] !== p[1] || this.p[4] !== p[4] || this.p[5] !== p[5] || this.p[12] !== p[12] || this.p[13] !== p[13])) {
            this.p = p;
            this._mdf.p = true;
            updated = true;
        }
        return updated;
    };
    function TextProperty(elem, data) {
        this._frameId = initialDefaultFrame;
        this.pv = "";
        this.v = "";
        this.kf = false;
        this._isFirstFrame = true;
        this._mdf = false;
        this.data = data;
        this.elem = elem;
        this.comp = this.elem.comp;
        this.keysIndex = 0;
        this.canResize = false;
        this.minimumFontSize = 1;
        this.effectsSequence = [];
        this.currentData = {
            ascent: 0,
            boxWidth: this.defaultBoxWidth,
            f: "",
            fStyle: "",
            fWeight: "",
            fc: "",
            j: "",
            justifyOffset: "",
            l: [],
            lh: 0,
            lineWidths: [],
            ls: "",
            of: "",
            s: "",
            sc: "",
            sw: 0,
            t: 0,
            tr: 0,
            sz: 0,
            ps: null,
            fillColorAnim: false,
            strokeColorAnim: false,
            strokeWidthAnim: false,
            yOffset: 0,
            finalSize: 0,
            finalText: [],
            finalLineHeight: 0,
            __complete: false
        };
        this.copyData(this.currentData, this.data.d.k[0].s);
        if (!this.searchProperty()) this.completeTextData(this.currentData);
    }
    TextProperty.prototype.defaultBoxWidth = [
        0,
        0
    ];
    TextProperty.prototype.copyData = function(obj, data) {
        for(var s in data)if (Object.prototype.hasOwnProperty.call(data, s)) obj[s] = data[s];
        return obj;
    };
    TextProperty.prototype.setCurrentData = function(data) {
        if (!data.__complete) this.completeTextData(data);
        this.currentData = data;
        this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth;
        this._mdf = true;
    };
    TextProperty.prototype.searchProperty = function() {
        return this.searchKeyframes();
    };
    TextProperty.prototype.searchKeyframes = function() {
        this.kf = this.data.d.k.length > 1;
        if (this.kf) this.addEffect(this.getKeyframeValue.bind(this));
        return this.kf;
    };
    TextProperty.prototype.addEffect = function(effectFunction) {
        this.effectsSequence.push(effectFunction);
        this.elem.addDynamicProperty(this);
    };
    TextProperty.prototype.getValue = function(_finalValue) {
        if ((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !_finalValue) return;
        this.currentData.t = this.data.d.k[this.keysIndex].s.t;
        var currentValue = this.currentData;
        var currentIndex = this.keysIndex;
        if (this.lock) {
            this.setCurrentData(this.currentData);
            return;
        }
        this.lock = true;
        this._mdf = false;
        var i;
        var len = this.effectsSequence.length;
        var finalValue = _finalValue || this.data.d.k[this.keysIndex].s;
        for(i = 0; i < len; i += 1)// Checking if index changed to prevent creating a new object every time the expression updates.
        if (currentIndex !== this.keysIndex) finalValue = this.effectsSequence[i](finalValue, finalValue.t);
        else finalValue = this.effectsSequence[i](this.currentData, finalValue.t);
        if (currentValue !== finalValue) this.setCurrentData(finalValue);
        this.v = this.currentData;
        this.pv = this.v;
        this.lock = false;
        this.frameId = this.elem.globalData.frameId;
    };
    TextProperty.prototype.getKeyframeValue = function() {
        var textKeys = this.data.d.k;
        var frameNum = this.elem.comp.renderedFrame;
        var i = 0;
        var len = textKeys.length;
        while(i <= len - 1){
            if (i === len - 1 || textKeys[i + 1].t > frameNum) break;
            i += 1;
        }
        if (this.keysIndex !== i) this.keysIndex = i;
        return this.data.d.k[this.keysIndex].s;
    };
    TextProperty.prototype.buildFinalText = function(text) {
        var charactersArray = [];
        var i = 0;
        var len = text.length;
        var charCode;
        var secondCharCode;
        var shouldCombine = false;
        while(i < len){
            charCode = text.charCodeAt(i);
            if (FontManager.isCombinedCharacter(charCode)) charactersArray[charactersArray.length - 1] += text.charAt(i);
            else if (charCode >= 0xD800 && charCode <= 0xDBFF) {
                secondCharCode = text.charCodeAt(i + 1);
                if (secondCharCode >= 0xDC00 && secondCharCode <= 0xDFFF) {
                    if (shouldCombine || FontManager.isModifier(charCode, secondCharCode)) {
                        charactersArray[charactersArray.length - 1] += text.substr(i, 2);
                        shouldCombine = false;
                    } else charactersArray.push(text.substr(i, 2));
                    i += 1;
                } else charactersArray.push(text.charAt(i));
            } else if (charCode > 0xDBFF) {
                secondCharCode = text.charCodeAt(i + 1);
                if (FontManager.isZeroWidthJoiner(charCode, secondCharCode)) {
                    shouldCombine = true;
                    charactersArray[charactersArray.length - 1] += text.substr(i, 2);
                    i += 1;
                } else charactersArray.push(text.charAt(i));
            } else if (FontManager.isZeroWidthJoiner(charCode)) {
                charactersArray[charactersArray.length - 1] += text.charAt(i);
                shouldCombine = true;
            } else charactersArray.push(text.charAt(i));
            i += 1;
        }
        return charactersArray;
    };
    TextProperty.prototype.completeTextData = function(documentData) {
        documentData.__complete = true;
        var fontManager = this.elem.globalData.fontManager;
        var data = this.data;
        var letters = [];
        var i;
        var len;
        var newLineFlag;
        var index = 0;
        var val;
        var anchorGrouping = data.m.g;
        var currentSize = 0;
        var currentPos = 0;
        var currentLine = 0;
        var lineWidths = [];
        var lineWidth = 0;
        var maxLineWidth = 0;
        var j;
        var jLen;
        var fontData = fontManager.getFontByName(documentData.f);
        var charData;
        var cLength = 0;
        var fontProps = getFontProperties(fontData);
        documentData.fWeight = fontProps.weight;
        documentData.fStyle = fontProps.style;
        documentData.finalSize = documentData.s;
        documentData.finalText = this.buildFinalText(documentData.t);
        len = documentData.finalText.length;
        documentData.finalLineHeight = documentData.lh;
        var trackingOffset = documentData.tr / 1000 * documentData.finalSize;
        var charCode;
        if (documentData.sz) {
            var flag = true;
            var boxWidth = documentData.sz[0];
            var boxHeight = documentData.sz[1];
            var currentHeight;
            var finalText;
            while(flag){
                finalText = this.buildFinalText(documentData.t);
                currentHeight = 0;
                lineWidth = 0;
                len = finalText.length;
                trackingOffset = documentData.tr / 1000 * documentData.finalSize;
                var lastSpaceIndex = -1;
                for(i = 0; i < len; i += 1){
                    charCode = finalText[i].charCodeAt(0);
                    newLineFlag = false;
                    if (finalText[i] === " ") lastSpaceIndex = i;
                    else if (charCode === 13 || charCode === 3) {
                        lineWidth = 0;
                        newLineFlag = true;
                        currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
                    }
                    if (fontManager.chars) {
                        charData = fontManager.getCharData(finalText[i], fontData.fStyle, fontData.fFamily);
                        cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;
                    } else // tCanvasHelper.font = documentData.s + 'px '+ fontData.fFamily;
                    cLength = fontManager.measureText(finalText[i], documentData.f, documentData.finalSize);
                    if (lineWidth + cLength > boxWidth && finalText[i] !== " ") {
                        if (lastSpaceIndex === -1) len += 1;
                        else i = lastSpaceIndex;
                        currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
                        finalText.splice(i, lastSpaceIndex === i ? 1 : 0, "\r"); // finalText = finalText.substr(0,i) + "\r" + finalText.substr(i === lastSpaceIndex ? i + 1 : i);
                        lastSpaceIndex = -1;
                        lineWidth = 0;
                    } else {
                        lineWidth += cLength;
                        lineWidth += trackingOffset;
                    }
                }
                currentHeight += fontData.ascent * documentData.finalSize / 100;
                if (this.canResize && documentData.finalSize > this.minimumFontSize && boxHeight < currentHeight) {
                    documentData.finalSize -= 1;
                    documentData.finalLineHeight = documentData.finalSize * documentData.lh / documentData.s;
                } else {
                    documentData.finalText = finalText;
                    len = documentData.finalText.length;
                    flag = false;
                }
            }
        }
        lineWidth = -trackingOffset;
        cLength = 0;
        var uncollapsedSpaces = 0;
        var currentChar;
        for(i = 0; i < len; i += 1){
            newLineFlag = false;
            currentChar = documentData.finalText[i];
            charCode = currentChar.charCodeAt(0);
            if (charCode === 13 || charCode === 3) {
                uncollapsedSpaces = 0;
                lineWidths.push(lineWidth);
                maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
                lineWidth = -2 * trackingOffset;
                val = "";
                newLineFlag = true;
                currentLine += 1;
            } else val = currentChar;
            if (fontManager.chars) {
                charData = fontManager.getCharData(currentChar, fontData.fStyle, fontManager.getFontByName(documentData.f).fFamily);
                cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;
            } else // var charWidth = fontManager.measureText(val, documentData.f, documentData.finalSize);
            // tCanvasHelper.font = documentData.finalSize + 'px '+ fontManager.getFontByName(documentData.f).fFamily;
            cLength = fontManager.measureText(val, documentData.f, documentData.finalSize);
             //
            if (currentChar === " ") uncollapsedSpaces += cLength + trackingOffset;
            else {
                lineWidth += cLength + trackingOffset + uncollapsedSpaces;
                uncollapsedSpaces = 0;
            }
            letters.push({
                l: cLength,
                an: cLength,
                add: currentSize,
                n: newLineFlag,
                anIndexes: [],
                val: val,
                line: currentLine,
                animatorJustifyOffset: 0
            });
            if (anchorGrouping == 2) {
                // eslint-disable-line eqeqeq
                currentSize += cLength;
                if (val === "" || val === " " || i === len - 1) {
                    if (val === "" || val === " ") currentSize -= cLength;
                    while(currentPos <= i){
                        letters[currentPos].an = currentSize;
                        letters[currentPos].ind = index;
                        letters[currentPos].extra = cLength;
                        currentPos += 1;
                    }
                    index += 1;
                    currentSize = 0;
                }
            } else if (anchorGrouping == 3) {
                // eslint-disable-line eqeqeq
                currentSize += cLength;
                if (val === "" || i === len - 1) {
                    if (val === "") currentSize -= cLength;
                    while(currentPos <= i){
                        letters[currentPos].an = currentSize;
                        letters[currentPos].ind = index;
                        letters[currentPos].extra = cLength;
                        currentPos += 1;
                    }
                    currentSize = 0;
                    index += 1;
                }
            } else {
                letters[index].ind = index;
                letters[index].extra = 0;
                index += 1;
            }
        }
        documentData.l = letters;
        maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
        lineWidths.push(lineWidth);
        if (documentData.sz) {
            documentData.boxWidth = documentData.sz[0];
            documentData.justifyOffset = 0;
        } else {
            documentData.boxWidth = maxLineWidth;
            switch(documentData.j){
                case 1:
                    documentData.justifyOffset = -documentData.boxWidth;
                    break;
                case 2:
                    documentData.justifyOffset = -documentData.boxWidth / 2;
                    break;
                default:
                    documentData.justifyOffset = 0;
            }
        }
        documentData.lineWidths = lineWidths;
        var animators = data.a;
        var animatorData;
        var letterData;
        jLen = animators.length;
        var based;
        var ind;
        var indexes = [];
        for(j = 0; j < jLen; j += 1){
            animatorData = animators[j];
            if (animatorData.a.sc) documentData.strokeColorAnim = true;
            if (animatorData.a.sw) documentData.strokeWidthAnim = true;
            if (animatorData.a.fc || animatorData.a.fh || animatorData.a.fs || animatorData.a.fb) documentData.fillColorAnim = true;
            ind = 0;
            based = animatorData.s.b;
            for(i = 0; i < len; i += 1){
                letterData = letters[i];
                letterData.anIndexes[j] = ind;
                if (based == 1 && letterData.val !== "" || based == 2 && letterData.val !== "" && letterData.val !== " " || based == 3 && (letterData.n || letterData.val == " " || i == len - 1) || based == 4 && (letterData.n || i == len - 1)) {
                    // eslint-disable-line eqeqeq
                    if (animatorData.s.rn === 1) indexes.push(ind);
                    ind += 1;
                }
            }
            data.a[j].s.totalChars = ind;
            var currentInd = -1;
            var newInd;
            if (animatorData.s.rn === 1) for(i = 0; i < len; i += 1){
                letterData = letters[i];
                if (currentInd != letterData.anIndexes[j]) {
                    // eslint-disable-line eqeqeq
                    currentInd = letterData.anIndexes[j];
                    newInd = indexes.splice(Math.floor(Math.random() * indexes.length), 1)[0];
                }
                letterData.anIndexes[j] = newInd;
            }
        }
        documentData.yOffset = documentData.finalLineHeight || documentData.finalSize * 1.2;
        documentData.ls = documentData.ls || 0;
        documentData.ascent = fontData.ascent * documentData.finalSize / 100;
    };
    TextProperty.prototype.updateDocumentData = function(newData, index) {
        index = index === undefined ? this.keysIndex : index;
        var dData = this.copyData({}, this.data.d.k[index].s);
        dData = this.copyData(dData, newData);
        this.data.d.k[index].s = dData;
        this.recalculate(index);
        this.elem.addDynamicProperty(this);
    };
    TextProperty.prototype.recalculate = function(index) {
        var dData = this.data.d.k[index].s;
        dData.__complete = false;
        this.keysIndex = 0;
        this._isFirstFrame = true;
        this.getValue(dData);
    };
    TextProperty.prototype.canResizeFont = function(_canResize) {
        this.canResize = _canResize;
        this.recalculate(this.keysIndex);
        this.elem.addDynamicProperty(this);
    };
    TextProperty.prototype.setMinimumFontSize = function(_fontValue) {
        this.minimumFontSize = Math.floor(_fontValue) || 1;
        this.recalculate(this.keysIndex);
        this.elem.addDynamicProperty(this);
    };
    var TextSelectorProp = function() {
        var max = Math.max;
        var min = Math.min;
        var floor = Math.floor;
        function TextSelectorPropFactory(elem, data) {
            this._currentTextLength = -1;
            this.k = false;
            this.data = data;
            this.elem = elem;
            this.comp = elem.comp;
            this.finalS = 0;
            this.finalE = 0;
            this.initDynamicPropertyContainer(elem);
            this.s = PropertyFactory.getProp(elem, data.s || {
                k: 0
            }, 0, 0, this);
            if ("e" in data) this.e = PropertyFactory.getProp(elem, data.e, 0, 0, this);
            else this.e = {
                v: 100
            };
            this.o = PropertyFactory.getProp(elem, data.o || {
                k: 0
            }, 0, 0, this);
            this.xe = PropertyFactory.getProp(elem, data.xe || {
                k: 0
            }, 0, 0, this);
            this.ne = PropertyFactory.getProp(elem, data.ne || {
                k: 0
            }, 0, 0, this);
            this.sm = PropertyFactory.getProp(elem, data.sm || {
                k: 100
            }, 0, 0, this);
            this.a = PropertyFactory.getProp(elem, data.a, 0, 0.01, this);
            if (!this.dynamicProperties.length) this.getValue();
        }
        TextSelectorPropFactory.prototype = {
            getMult: function getMult(ind) {
                if (this._currentTextLength !== this.elem.textProperty.currentData.l.length) this.getValue();
                var x1 = 0;
                var y1 = 0;
                var x2 = 1;
                var y2 = 1;
                if (this.ne.v > 0) x1 = this.ne.v / 100.0;
                else y1 = -this.ne.v / 100.0;
                if (this.xe.v > 0) x2 = 1.0 - this.xe.v / 100.0;
                else y2 = 1.0 + this.xe.v / 100.0;
                var easer = BezierFactory.getBezierEasing(x1, y1, x2, y2).get;
                var mult = 0;
                var s = this.finalS;
                var e = this.finalE;
                var type = this.data.sh;
                if (type === 2) {
                    if (e === s) mult = ind >= e ? 1 : 0;
                    else mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
                    mult = easer(mult);
                } else if (type === 3) {
                    if (e === s) mult = ind >= e ? 0 : 1;
                    else mult = 1 - max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
                    mult = easer(mult);
                } else if (type === 4) {
                    if (e === s) mult = 0;
                    else {
                        mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
                        if (mult < 0.5) mult *= 2;
                        else mult = 1 - 2 * (mult - 0.5);
                    }
                    mult = easer(mult);
                } else if (type === 5) {
                    if (e === s) mult = 0;
                    else {
                        var tot = e - s;
                        /* ind += 0.5;
                      mult = -4/(tot*tot)*(ind*ind)+(4/tot)*ind; */ ind = min(max(0, ind + 0.5 - s), e - s);
                        var x = -tot / 2 + ind;
                        var a = tot / 2;
                        mult = Math.sqrt(1 - x * x / (a * a));
                    }
                    mult = easer(mult);
                } else if (type === 6) {
                    if (e === s) mult = 0;
                    else {
                        ind = min(max(0, ind + 0.5 - s), e - s);
                        mult = (1 + Math.cos(Math.PI + Math.PI * 2 * ind / (e - s))) / 2; // eslint-disable-line
                    }
                    mult = easer(mult);
                } else {
                    if (ind >= floor(s)) {
                        if (ind - s < 0) mult = max(0, min(min(e, 1) - (s - ind), 1));
                        else mult = max(0, min(e - ind, 1));
                    }
                    mult = easer(mult);
                } // Smoothness implementation.
                // The smoothness represents a reduced range of the original [0; 1] range.
                // if smoothness is 25%, the new range will be [0.375; 0.625]
                // Steps are:
                // - find the lower value of the new range (threshold)
                // - if multiplier is smaller than that value, floor it to 0
                // - if it is larger,
                //     - subtract the threshold
                //     - divide it by the smoothness (this will return the range to [0; 1])
                // Note: If it doesn't work on some scenarios, consider applying it before the easer.
                if (this.sm.v !== 100) {
                    var smoothness = this.sm.v * 0.01;
                    if (smoothness === 0) smoothness = 0.00000001;
                    var threshold = 0.5 - smoothness * 0.5;
                    if (mult < threshold) mult = 0;
                    else {
                        mult = (mult - threshold) / smoothness;
                        if (mult > 1) mult = 1;
                    }
                }
                return mult * this.a.v;
            },
            getValue: function getValue(newCharsFlag) {
                this.iterateDynamicProperties();
                this._mdf = newCharsFlag || this._mdf;
                this._currentTextLength = this.elem.textProperty.currentData.l.length || 0;
                if (newCharsFlag && this.data.r === 2) this.e.v = this._currentTextLength;
                var divisor = this.data.r === 2 ? 1 : 100 / this.data.totalChars;
                var o = this.o.v / divisor;
                var s = this.s.v / divisor + o;
                var e = this.e.v / divisor + o;
                if (s > e) {
                    var _s = s;
                    s = e;
                    e = _s;
                }
                this.finalS = s;
                this.finalE = e;
            }
        };
        extendPrototype([
            DynamicPropertyContainer
        ], TextSelectorPropFactory);
        function getTextSelectorProp(elem, data, arr) {
            return new TextSelectorPropFactory(elem, data, arr);
        }
        return {
            getTextSelectorProp: getTextSelectorProp
        };
    }();
    function TextAnimatorDataProperty(elem, animatorProps, container) {
        var defaultData = {
            propType: false
        };
        var getProp = PropertyFactory.getProp;
        var textAnimatorAnimatables = animatorProps.a;
        this.a = {
            r: textAnimatorAnimatables.r ? getProp(elem, textAnimatorAnimatables.r, 0, degToRads, container) : defaultData,
            rx: textAnimatorAnimatables.rx ? getProp(elem, textAnimatorAnimatables.rx, 0, degToRads, container) : defaultData,
            ry: textAnimatorAnimatables.ry ? getProp(elem, textAnimatorAnimatables.ry, 0, degToRads, container) : defaultData,
            sk: textAnimatorAnimatables.sk ? getProp(elem, textAnimatorAnimatables.sk, 0, degToRads, container) : defaultData,
            sa: textAnimatorAnimatables.sa ? getProp(elem, textAnimatorAnimatables.sa, 0, degToRads, container) : defaultData,
            s: textAnimatorAnimatables.s ? getProp(elem, textAnimatorAnimatables.s, 1, 0.01, container) : defaultData,
            a: textAnimatorAnimatables.a ? getProp(elem, textAnimatorAnimatables.a, 1, 0, container) : defaultData,
            o: textAnimatorAnimatables.o ? getProp(elem, textAnimatorAnimatables.o, 0, 0.01, container) : defaultData,
            p: textAnimatorAnimatables.p ? getProp(elem, textAnimatorAnimatables.p, 1, 0, container) : defaultData,
            sw: textAnimatorAnimatables.sw ? getProp(elem, textAnimatorAnimatables.sw, 0, 0, container) : defaultData,
            sc: textAnimatorAnimatables.sc ? getProp(elem, textAnimatorAnimatables.sc, 1, 0, container) : defaultData,
            fc: textAnimatorAnimatables.fc ? getProp(elem, textAnimatorAnimatables.fc, 1, 0, container) : defaultData,
            fh: textAnimatorAnimatables.fh ? getProp(elem, textAnimatorAnimatables.fh, 0, 0, container) : defaultData,
            fs: textAnimatorAnimatables.fs ? getProp(elem, textAnimatorAnimatables.fs, 0, 0.01, container) : defaultData,
            fb: textAnimatorAnimatables.fb ? getProp(elem, textAnimatorAnimatables.fb, 0, 0.01, container) : defaultData,
            t: textAnimatorAnimatables.t ? getProp(elem, textAnimatorAnimatables.t, 0, 0, container) : defaultData
        };
        this.s = TextSelectorProp.getTextSelectorProp(elem, animatorProps.s, container);
        this.s.t = animatorProps.s.t;
    }
    function TextAnimatorProperty(textData, renderType, elem) {
        this._isFirstFrame = true;
        this._hasMaskedPath = false;
        this._frameId = -1;
        this._textData = textData;
        this._renderType = renderType;
        this._elem = elem;
        this._animatorsData = createSizedArray(this._textData.a.length);
        this._pathData = {};
        this._moreOptions = {
            alignment: {}
        };
        this.renderedLetters = [];
        this.lettersChangedFlag = false;
        this.initDynamicPropertyContainer(elem);
    }
    TextAnimatorProperty.prototype.searchProperties = function() {
        var i;
        var len = this._textData.a.length;
        var animatorProps;
        var getProp = PropertyFactory.getProp;
        for(i = 0; i < len; i += 1){
            animatorProps = this._textData.a[i];
            this._animatorsData[i] = new TextAnimatorDataProperty(this._elem, animatorProps, this);
        }
        if (this._textData.p && "m" in this._textData.p) {
            this._pathData = {
                a: getProp(this._elem, this._textData.p.a, 0, 0, this),
                f: getProp(this._elem, this._textData.p.f, 0, 0, this),
                l: getProp(this._elem, this._textData.p.l, 0, 0, this),
                r: getProp(this._elem, this._textData.p.r, 0, 0, this),
                p: getProp(this._elem, this._textData.p.p, 0, 0, this),
                m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
            };
            this._hasMaskedPath = true;
        } else this._hasMaskedPath = false;
        this._moreOptions.alignment = getProp(this._elem, this._textData.m.a, 1, 0, this);
    };
    TextAnimatorProperty.prototype.getMeasures = function(documentData, lettersChangedFlag) {
        this.lettersChangedFlag = lettersChangedFlag;
        if (!this._mdf && !this._isFirstFrame && !lettersChangedFlag && (!this._hasMaskedPath || !this._pathData.m._mdf)) return;
        this._isFirstFrame = false;
        var alignment = this._moreOptions.alignment.v;
        var animators = this._animatorsData;
        var textData = this._textData;
        var matrixHelper = this.mHelper;
        var renderType = this._renderType;
        var renderedLettersCount = this.renderedLetters.length;
        var xPos;
        var yPos;
        var i;
        var len;
        var letters = documentData.l;
        var pathInfo;
        var currentLength;
        var currentPoint;
        var segmentLength;
        var flag;
        var pointInd;
        var segmentInd;
        var prevPoint;
        var points;
        var segments;
        var partialLength;
        var totalLength;
        var perc;
        var tanAngle;
        var mask;
        if (this._hasMaskedPath) {
            mask = this._pathData.m;
            if (!this._pathData.n || this._pathData._mdf) {
                var paths = mask.v;
                if (this._pathData.r.v) paths = paths.reverse();
                 // TODO: release bezier data cached from previous pathInfo: this._pathData.pi
                pathInfo = {
                    tLength: 0,
                    segments: []
                };
                len = paths._length - 1;
                var bezierData;
                totalLength = 0;
                for(i = 0; i < len; i += 1){
                    bezierData = bez.buildBezierData(paths.v[i], paths.v[i + 1], [
                        paths.o[i][0] - paths.v[i][0],
                        paths.o[i][1] - paths.v[i][1]
                    ], [
                        paths.i[i + 1][0] - paths.v[i + 1][0],
                        paths.i[i + 1][1] - paths.v[i + 1][1]
                    ]);
                    pathInfo.tLength += bezierData.segmentLength;
                    pathInfo.segments.push(bezierData);
                    totalLength += bezierData.segmentLength;
                }
                i = len;
                if (mask.v.c) {
                    bezierData = bez.buildBezierData(paths.v[i], paths.v[0], [
                        paths.o[i][0] - paths.v[i][0],
                        paths.o[i][1] - paths.v[i][1]
                    ], [
                        paths.i[0][0] - paths.v[0][0],
                        paths.i[0][1] - paths.v[0][1]
                    ]);
                    pathInfo.tLength += bezierData.segmentLength;
                    pathInfo.segments.push(bezierData);
                    totalLength += bezierData.segmentLength;
                }
                this._pathData.pi = pathInfo;
            }
            pathInfo = this._pathData.pi;
            currentLength = this._pathData.f.v;
            segmentInd = 0;
            pointInd = 1;
            segmentLength = 0;
            flag = true;
            segments = pathInfo.segments;
            if (currentLength < 0 && mask.v.c) {
                if (pathInfo.tLength < Math.abs(currentLength)) currentLength = -Math.abs(currentLength) % pathInfo.tLength;
                segmentInd = segments.length - 1;
                points = segments[segmentInd].points;
                pointInd = points.length - 1;
                while(currentLength < 0){
                    currentLength += points[pointInd].partialLength;
                    pointInd -= 1;
                    if (pointInd < 0) {
                        segmentInd -= 1;
                        points = segments[segmentInd].points;
                        pointInd = points.length - 1;
                    }
                }
            }
            points = segments[segmentInd].points;
            prevPoint = points[pointInd - 1];
            currentPoint = points[pointInd];
            partialLength = currentPoint.partialLength;
        }
        len = letters.length;
        xPos = 0;
        yPos = 0;
        var yOff = documentData.finalSize * 1.2 * 0.714;
        var firstLine = true;
        var animatorProps;
        var animatorSelector;
        var j;
        var jLen;
        var letterValue;
        jLen = animators.length;
        var mult;
        var ind = -1;
        var offf;
        var xPathPos;
        var yPathPos;
        var initPathPos = currentLength;
        var initSegmentInd = segmentInd;
        var initPointInd = pointInd;
        var currentLine = -1;
        var elemOpacity;
        var sc;
        var sw;
        var fc;
        var k;
        var letterSw;
        var letterSc;
        var letterFc;
        var letterM = "";
        var letterP = this.defaultPropsArray;
        var letterO; //
        if (documentData.j === 2 || documentData.j === 1) {
            var animatorJustifyOffset = 0;
            var animatorFirstCharOffset = 0;
            var justifyOffsetMult = documentData.j === 2 ? -0.5 : -1;
            var lastIndex = 0;
            var isNewLine = true;
            for(i = 0; i < len; i += 1)if (letters[i].n) {
                if (animatorJustifyOffset) animatorJustifyOffset += animatorFirstCharOffset;
                while(lastIndex < i){
                    letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
                    lastIndex += 1;
                }
                animatorJustifyOffset = 0;
                isNewLine = true;
            } else {
                for(j = 0; j < jLen; j += 1){
                    animatorProps = animators[j].a;
                    if (animatorProps.t.propType) {
                        if (isNewLine && documentData.j === 2) animatorFirstCharOffset += animatorProps.t.v * justifyOffsetMult;
                        animatorSelector = animators[j].s;
                        mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                        if (mult.length) animatorJustifyOffset += animatorProps.t.v * mult[0] * justifyOffsetMult;
                        else animatorJustifyOffset += animatorProps.t.v * mult * justifyOffsetMult;
                    }
                }
                isNewLine = false;
            }
            if (animatorJustifyOffset) animatorJustifyOffset += animatorFirstCharOffset;
            while(lastIndex < i){
                letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
                lastIndex += 1;
            }
        } //
        for(i = 0; i < len; i += 1){
            matrixHelper.reset();
            elemOpacity = 1;
            if (letters[i].n) {
                xPos = 0;
                yPos += documentData.yOffset;
                yPos += firstLine ? 1 : 0;
                currentLength = initPathPos;
                firstLine = false;
                if (this._hasMaskedPath) {
                    segmentInd = initSegmentInd;
                    pointInd = initPointInd;
                    points = segments[segmentInd].points;
                    prevPoint = points[pointInd - 1];
                    currentPoint = points[pointInd];
                    partialLength = currentPoint.partialLength;
                    segmentLength = 0;
                }
                letterM = "";
                letterFc = "";
                letterSw = "";
                letterO = "";
                letterP = this.defaultPropsArray;
            } else {
                if (this._hasMaskedPath) {
                    if (currentLine !== letters[i].line) {
                        switch(documentData.j){
                            case 1:
                                currentLength += totalLength - documentData.lineWidths[letters[i].line];
                                break;
                            case 2:
                                currentLength += (totalLength - documentData.lineWidths[letters[i].line]) / 2;
                                break;
                            default:
                                break;
                        }
                        currentLine = letters[i].line;
                    }
                    if (ind !== letters[i].ind) {
                        if (letters[ind]) currentLength += letters[ind].extra;
                        currentLength += letters[i].an / 2;
                        ind = letters[i].ind;
                    }
                    currentLength += alignment[0] * letters[i].an * 0.005;
                    var animatorOffset = 0;
                    for(j = 0; j < jLen; j += 1){
                        animatorProps = animators[j].a;
                        if (animatorProps.p.propType) {
                            animatorSelector = animators[j].s;
                            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                            if (mult.length) animatorOffset += animatorProps.p.v[0] * mult[0];
                            else animatorOffset += animatorProps.p.v[0] * mult;
                        }
                        if (animatorProps.a.propType) {
                            animatorSelector = animators[j].s;
                            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                            if (mult.length) animatorOffset += animatorProps.a.v[0] * mult[0];
                            else animatorOffset += animatorProps.a.v[0] * mult;
                        }
                    }
                    flag = true; // Force alignment only works with a single line for now
                    if (this._pathData.a.v) {
                        currentLength = letters[0].an * 0.5 + (totalLength - this._pathData.f.v - letters[0].an * 0.5 - letters[letters.length - 1].an * 0.5) * ind / (len - 1);
                        currentLength += this._pathData.f.v;
                    }
                    while(flag){
                        if (segmentLength + partialLength >= currentLength + animatorOffset || !points) {
                            perc = (currentLength + animatorOffset - segmentLength) / currentPoint.partialLength;
                            xPathPos = prevPoint.point[0] + (currentPoint.point[0] - prevPoint.point[0]) * perc;
                            yPathPos = prevPoint.point[1] + (currentPoint.point[1] - prevPoint.point[1]) * perc;
                            matrixHelper.translate(-alignment[0] * letters[i].an * 0.005, -(alignment[1] * yOff) * 0.01);
                            flag = false;
                        } else if (points) {
                            segmentLength += currentPoint.partialLength;
                            pointInd += 1;
                            if (pointInd >= points.length) {
                                pointInd = 0;
                                segmentInd += 1;
                                if (!segments[segmentInd]) {
                                    if (mask.v.c) {
                                        pointInd = 0;
                                        segmentInd = 0;
                                        points = segments[segmentInd].points;
                                    } else {
                                        segmentLength -= currentPoint.partialLength;
                                        points = null;
                                    }
                                } else points = segments[segmentInd].points;
                            }
                            if (points) {
                                prevPoint = currentPoint;
                                currentPoint = points[pointInd];
                                partialLength = currentPoint.partialLength;
                            }
                        }
                    }
                    offf = letters[i].an / 2 - letters[i].add;
                    matrixHelper.translate(-offf, 0, 0);
                } else {
                    offf = letters[i].an / 2 - letters[i].add;
                    matrixHelper.translate(-offf, 0, 0); // Grouping alignment
                    matrixHelper.translate(-alignment[0] * letters[i].an * 0.005, -alignment[1] * yOff * 0.01, 0);
                }
                for(j = 0; j < jLen; j += 1){
                    animatorProps = animators[j].a;
                    if (animatorProps.t.propType) {
                        animatorSelector = animators[j].s;
                        mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars); // This condition is to prevent applying tracking to first character in each line. Might be better to use a boolean "isNewLine"
                        if (xPos !== 0 || documentData.j !== 0) {
                            if (this._hasMaskedPath) {
                                if (mult.length) currentLength += animatorProps.t.v * mult[0];
                                else currentLength += animatorProps.t.v * mult;
                            } else if (mult.length) xPos += animatorProps.t.v * mult[0];
                            else xPos += animatorProps.t.v * mult;
                        }
                    }
                }
                if (documentData.strokeWidthAnim) sw = documentData.sw || 0;
                if (documentData.strokeColorAnim) {
                    if (documentData.sc) sc = [
                        documentData.sc[0],
                        documentData.sc[1],
                        documentData.sc[2]
                    ];
                    else sc = [
                        0,
                        0,
                        0
                    ];
                }
                if (documentData.fillColorAnim && documentData.fc) fc = [
                    documentData.fc[0],
                    documentData.fc[1],
                    documentData.fc[2]
                ];
                for(j = 0; j < jLen; j += 1){
                    animatorProps = animators[j].a;
                    if (animatorProps.a.propType) {
                        animatorSelector = animators[j].s;
                        mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                        if (mult.length) matrixHelper.translate(-animatorProps.a.v[0] * mult[0], -animatorProps.a.v[1] * mult[1], animatorProps.a.v[2] * mult[2]);
                        else matrixHelper.translate(-animatorProps.a.v[0] * mult, -animatorProps.a.v[1] * mult, animatorProps.a.v[2] * mult);
                    }
                }
                for(j = 0; j < jLen; j += 1){
                    animatorProps = animators[j].a;
                    if (animatorProps.s.propType) {
                        animatorSelector = animators[j].s;
                        mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                        if (mult.length) matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult[0], 1 + (animatorProps.s.v[1] - 1) * mult[1], 1);
                        else matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult, 1 + (animatorProps.s.v[1] - 1) * mult, 1);
                    }
                }
                for(j = 0; j < jLen; j += 1){
                    animatorProps = animators[j].a;
                    animatorSelector = animators[j].s;
                    mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                    if (animatorProps.sk.propType) {
                        if (mult.length) matrixHelper.skewFromAxis(-animatorProps.sk.v * mult[0], animatorProps.sa.v * mult[1]);
                        else matrixHelper.skewFromAxis(-animatorProps.sk.v * mult, animatorProps.sa.v * mult);
                    }
                    if (animatorProps.r.propType) {
                        if (mult.length) matrixHelper.rotateZ(-animatorProps.r.v * mult[2]);
                        else matrixHelper.rotateZ(-animatorProps.r.v * mult);
                    }
                    if (animatorProps.ry.propType) {
                        if (mult.length) matrixHelper.rotateY(animatorProps.ry.v * mult[1]);
                        else matrixHelper.rotateY(animatorProps.ry.v * mult);
                    }
                    if (animatorProps.rx.propType) {
                        if (mult.length) matrixHelper.rotateX(animatorProps.rx.v * mult[0]);
                        else matrixHelper.rotateX(animatorProps.rx.v * mult);
                    }
                    if (animatorProps.o.propType) {
                        if (mult.length) elemOpacity += (animatorProps.o.v * mult[0] - elemOpacity) * mult[0];
                        else elemOpacity += (animatorProps.o.v * mult - elemOpacity) * mult;
                    }
                    if (documentData.strokeWidthAnim && animatorProps.sw.propType) {
                        if (mult.length) sw += animatorProps.sw.v * mult[0];
                        else sw += animatorProps.sw.v * mult;
                    }
                    if (documentData.strokeColorAnim && animatorProps.sc.propType) {
                        for(k = 0; k < 3; k += 1)if (mult.length) sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult[0];
                        else sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult;
                    }
                    if (documentData.fillColorAnim && documentData.fc) {
                        if (animatorProps.fc.propType) {
                            for(k = 0; k < 3; k += 1)if (mult.length) fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult[0];
                            else fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult;
                        }
                        if (animatorProps.fh.propType) {
                            if (mult.length) fc = addHueToRGB(fc, animatorProps.fh.v * mult[0]);
                            else fc = addHueToRGB(fc, animatorProps.fh.v * mult);
                        }
                        if (animatorProps.fs.propType) {
                            if (mult.length) fc = addSaturationToRGB(fc, animatorProps.fs.v * mult[0]);
                            else fc = addSaturationToRGB(fc, animatorProps.fs.v * mult);
                        }
                        if (animatorProps.fb.propType) {
                            if (mult.length) fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult[0]);
                            else fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult);
                        }
                    }
                }
                for(j = 0; j < jLen; j += 1){
                    animatorProps = animators[j].a;
                    if (animatorProps.p.propType) {
                        animatorSelector = animators[j].s;
                        mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                        if (this._hasMaskedPath) {
                            if (mult.length) matrixHelper.translate(0, animatorProps.p.v[1] * mult[0], -animatorProps.p.v[2] * mult[1]);
                            else matrixHelper.translate(0, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
                        } else if (mult.length) matrixHelper.translate(animatorProps.p.v[0] * mult[0], animatorProps.p.v[1] * mult[1], -animatorProps.p.v[2] * mult[2]);
                        else matrixHelper.translate(animatorProps.p.v[0] * mult, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
                    }
                }
                if (documentData.strokeWidthAnim) letterSw = sw < 0 ? 0 : sw;
                if (documentData.strokeColorAnim) letterSc = "rgb(" + Math.round(sc[0] * 255) + "," + Math.round(sc[1] * 255) + "," + Math.round(sc[2] * 255) + ")";
                if (documentData.fillColorAnim && documentData.fc) letterFc = "rgb(" + Math.round(fc[0] * 255) + "," + Math.round(fc[1] * 255) + "," + Math.round(fc[2] * 255) + ")";
                if (this._hasMaskedPath) {
                    matrixHelper.translate(0, -documentData.ls);
                    matrixHelper.translate(0, alignment[1] * yOff * 0.01 + yPos, 0);
                    if (this._pathData.p.v) {
                        tanAngle = (currentPoint.point[1] - prevPoint.point[1]) / (currentPoint.point[0] - prevPoint.point[0]);
                        var rot = Math.atan(tanAngle) * 180 / Math.PI;
                        if (currentPoint.point[0] < prevPoint.point[0]) rot += 180;
                        matrixHelper.rotate(-rot * Math.PI / 180);
                    }
                    matrixHelper.translate(xPathPos, yPathPos, 0);
                    currentLength -= alignment[0] * letters[i].an * 0.005;
                    if (letters[i + 1] && ind !== letters[i + 1].ind) {
                        currentLength += letters[i].an / 2;
                        currentLength += documentData.tr * 0.001 * documentData.finalSize;
                    }
                } else {
                    matrixHelper.translate(xPos, yPos, 0);
                    if (documentData.ps) // matrixHelper.translate(documentData.ps[0],documentData.ps[1],0);
                    matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
                    switch(documentData.j){
                        case 1:
                            matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]), 0, 0);
                            break;
                        case 2:
                            matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]) / 2, 0, 0);
                            break;
                        default:
                            break;
                    }
                    matrixHelper.translate(0, -documentData.ls);
                    matrixHelper.translate(offf, 0, 0);
                    matrixHelper.translate(alignment[0] * letters[i].an * 0.005, alignment[1] * yOff * 0.01, 0);
                    xPos += letters[i].l + documentData.tr * 0.001 * documentData.finalSize;
                }
                if (renderType === "html") letterM = matrixHelper.toCSS();
                else if (renderType === "svg") letterM = matrixHelper.to2dCSS();
                else letterP = [
                    matrixHelper.props[0],
                    matrixHelper.props[1],
                    matrixHelper.props[2],
                    matrixHelper.props[3],
                    matrixHelper.props[4],
                    matrixHelper.props[5],
                    matrixHelper.props[6],
                    matrixHelper.props[7],
                    matrixHelper.props[8],
                    matrixHelper.props[9],
                    matrixHelper.props[10],
                    matrixHelper.props[11],
                    matrixHelper.props[12],
                    matrixHelper.props[13],
                    matrixHelper.props[14],
                    matrixHelper.props[15]
                ];
                letterO = elemOpacity;
            }
            if (renderedLettersCount <= i) {
                letterValue = new LetterProps(letterO, letterSw, letterSc, letterFc, letterM, letterP);
                this.renderedLetters.push(letterValue);
                renderedLettersCount += 1;
                this.lettersChangedFlag = true;
            } else {
                letterValue = this.renderedLetters[i];
                this.lettersChangedFlag = letterValue.update(letterO, letterSw, letterSc, letterFc, letterM, letterP) || this.lettersChangedFlag;
            }
        }
    };
    TextAnimatorProperty.prototype.getValue = function() {
        if (this._elem.globalData.frameId === this._frameId) return;
        this._frameId = this._elem.globalData.frameId;
        this.iterateDynamicProperties();
    };
    TextAnimatorProperty.prototype.mHelper = new Matrix();
    TextAnimatorProperty.prototype.defaultPropsArray = [];
    extendPrototype([
        DynamicPropertyContainer
    ], TextAnimatorProperty);
    function ITextElement() {}
    ITextElement.prototype.initElement = function(data, globalData, comp) {
        this.lettersChangedFlag = true;
        this.initFrame();
        this.initBaseData(data, globalData, comp);
        this.textProperty = new TextProperty(this, data.t, this.dynamicProperties);
        this.textAnimator = new TextAnimatorProperty(data.t, this.renderType, this);
        this.initTransform(data, globalData, comp);
        this.initHierarchy();
        this.initRenderable();
        this.initRendererElement();
        this.createContainerElements();
        this.createRenderableComponents();
        this.createContent();
        this.hide();
        this.textAnimator.searchProperties(this.dynamicProperties);
    };
    ITextElement.prototype.prepareFrame = function(num) {
        this._mdf = false;
        this.prepareRenderableFrame(num);
        this.prepareProperties(num, this.isInRange);
        if (this.textProperty._mdf || this.textProperty._isFirstFrame) {
            this.buildNewText();
            this.textProperty._isFirstFrame = false;
            this.textProperty._mdf = false;
        }
    };
    ITextElement.prototype.createPathShape = function(matrixHelper, shapes) {
        var j;
        var jLen = shapes.length;
        var pathNodes;
        var shapeStr = "";
        for(j = 0; j < jLen; j += 1)if (shapes[j].ty === "sh") {
            pathNodes = shapes[j].ks.k;
            shapeStr += buildShapeString(pathNodes, pathNodes.i.length, true, matrixHelper);
        }
        return shapeStr;
    };
    ITextElement.prototype.updateDocumentData = function(newData, index) {
        this.textProperty.updateDocumentData(newData, index);
    };
    ITextElement.prototype.canResizeFont = function(_canResize) {
        this.textProperty.canResizeFont(_canResize);
    };
    ITextElement.prototype.setMinimumFontSize = function(_fontSize) {
        this.textProperty.setMinimumFontSize(_fontSize);
    };
    ITextElement.prototype.applyTextPropertiesToMatrix = function(documentData, matrixHelper, lineNumber, xPos, yPos) {
        if (documentData.ps) matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
        matrixHelper.translate(0, -documentData.ls, 0);
        switch(documentData.j){
            case 1:
                matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]), 0, 0);
                break;
            case 2:
                matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]) / 2, 0, 0);
                break;
            default:
                break;
        }
        matrixHelper.translate(xPos, yPos, 0);
    };
    ITextElement.prototype.buildColor = function(colorData) {
        return "rgb(" + Math.round(colorData[0] * 255) + "," + Math.round(colorData[1] * 255) + "," + Math.round(colorData[2] * 255) + ")";
    };
    ITextElement.prototype.emptyProp = new LetterProps();
    ITextElement.prototype.destroy = function() {};
    var emptyShapeData = {
        shapes: []
    };
    function SVGTextLottieElement(data, globalData, comp) {
        this.textSpans = [];
        this.renderType = "svg";
        this.initElement(data, globalData, comp);
    }
    extendPrototype([
        BaseElement,
        TransformElement,
        SVGBaseElement,
        HierarchyElement,
        FrameElement,
        RenderableDOMElement,
        ITextElement
    ], SVGTextLottieElement);
    SVGTextLottieElement.prototype.createContent = function() {
        if (this.data.singleShape && !this.globalData.fontManager.chars) this.textContainer = createNS("text");
    };
    SVGTextLottieElement.prototype.buildTextContents = function(textArray) {
        var i = 0;
        var len = textArray.length;
        var textContents = [];
        var currentTextContent = "";
        while(i < len){
            if (textArray[i] === String.fromCharCode(13) || textArray[i] === String.fromCharCode(3)) {
                textContents.push(currentTextContent);
                currentTextContent = "";
            } else currentTextContent += textArray[i];
            i += 1;
        }
        textContents.push(currentTextContent);
        return textContents;
    };
    SVGTextLottieElement.prototype.buildShapeData = function(data, scale) {
        // data should probably be cloned to apply scale separately to each instance of a text on different layers
        // but since text internal content gets only rendered once and then it's never rerendered,
        // it's probably safe not to clone data and reuse always the same instance even if the object is mutated.
        // Avoiding cloning is preferred since cloning each character shape data is expensive
        if (data.shapes && data.shapes.length) {
            var shape = data.shapes[0];
            if (shape.it) {
                var shapeItem = shape.it[shape.it.length - 1];
                if (shapeItem.s) {
                    shapeItem.s.k[0] = scale;
                    shapeItem.s.k[1] = scale;
                }
            }
        }
        return data;
    };
    SVGTextLottieElement.prototype.buildNewText = function() {
        this.addDynamicProperty(this);
        var i;
        var len;
        var documentData = this.textProperty.currentData;
        this.renderedLetters = createSizedArray(documentData ? documentData.l.length : 0);
        if (documentData.fc) this.layerElement.setAttribute("fill", this.buildColor(documentData.fc));
        else this.layerElement.setAttribute("fill", "rgba(0,0,0,0)");
        if (documentData.sc) {
            this.layerElement.setAttribute("stroke", this.buildColor(documentData.sc));
            this.layerElement.setAttribute("stroke-width", documentData.sw);
        }
        this.layerElement.setAttribute("font-size", documentData.finalSize);
        var fontData = this.globalData.fontManager.getFontByName(documentData.f);
        if (fontData.fClass) this.layerElement.setAttribute("class", fontData.fClass);
        else {
            this.layerElement.setAttribute("font-family", fontData.fFamily);
            var fWeight = documentData.fWeight;
            var fStyle = documentData.fStyle;
            this.layerElement.setAttribute("font-style", fStyle);
            this.layerElement.setAttribute("font-weight", fWeight);
        }
        this.layerElement.setAttribute("aria-label", documentData.t);
        var letters = documentData.l || [];
        var usesGlyphs = !!this.globalData.fontManager.chars;
        len = letters.length;
        var tSpan;
        var matrixHelper = this.mHelper;
        var shapeStr = "";
        var singleShape = this.data.singleShape;
        var xPos = 0;
        var yPos = 0;
        var firstLine = true;
        var trackingOffset = documentData.tr * 0.001 * documentData.finalSize;
        if (singleShape && !usesGlyphs && !documentData.sz) {
            var tElement = this.textContainer;
            var justify = "start";
            switch(documentData.j){
                case 1:
                    justify = "end";
                    break;
                case 2:
                    justify = "middle";
                    break;
                default:
                    justify = "start";
                    break;
            }
            tElement.setAttribute("text-anchor", justify);
            tElement.setAttribute("letter-spacing", trackingOffset);
            var textContent = this.buildTextContents(documentData.finalText);
            len = textContent.length;
            yPos = documentData.ps ? documentData.ps[1] + documentData.ascent : 0;
            for(i = 0; i < len; i += 1){
                tSpan = this.textSpans[i].span || createNS("tspan");
                tSpan.textContent = textContent[i];
                tSpan.setAttribute("x", 0);
                tSpan.setAttribute("y", yPos);
                tSpan.style.display = "inherit";
                tElement.appendChild(tSpan);
                if (!this.textSpans[i]) this.textSpans[i] = {
                    span: null,
                    glyph: null
                };
                this.textSpans[i].span = tSpan;
                yPos += documentData.finalLineHeight;
            }
            this.layerElement.appendChild(tElement);
        } else {
            var cachedSpansLength = this.textSpans.length;
            var charData;
            for(i = 0; i < len; i += 1){
                if (!this.textSpans[i]) this.textSpans[i] = {
                    span: null,
                    childSpan: null,
                    glyph: null
                };
                if (!usesGlyphs || !singleShape || i === 0) {
                    tSpan = cachedSpansLength > i ? this.textSpans[i].span : createNS(usesGlyphs ? "g" : "text");
                    if (cachedSpansLength <= i) {
                        tSpan.setAttribute("stroke-linecap", "butt");
                        tSpan.setAttribute("stroke-linejoin", "round");
                        tSpan.setAttribute("stroke-miterlimit", "4");
                        this.textSpans[i].span = tSpan;
                        if (usesGlyphs) {
                            var childSpan = createNS("g");
                            tSpan.appendChild(childSpan);
                            this.textSpans[i].childSpan = childSpan;
                        }
                        this.textSpans[i].span = tSpan;
                        this.layerElement.appendChild(tSpan);
                    }
                    tSpan.style.display = "inherit";
                }
                matrixHelper.reset();
                if (singleShape) {
                    if (letters[i].n) {
                        xPos = -trackingOffset;
                        yPos += documentData.yOffset;
                        yPos += firstLine ? 1 : 0;
                        firstLine = false;
                    }
                    this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);
                    xPos += letters[i].l || 0; // xPos += letters[i].val === ' ' ? 0 : trackingOffset;
                    xPos += trackingOffset;
                }
                if (usesGlyphs) {
                    charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
                    var glyphElement; // t === 1 means the character has been replaced with an animated shaped
                    if (charData.t === 1) glyphElement = new SVGCompElement(charData.data, this.globalData, this);
                    else {
                        var data = emptyShapeData;
                        if (charData.data && charData.data.shapes) data = this.buildShapeData(charData.data, documentData.finalSize);
                        glyphElement = new SVGShapeElement(data, this.globalData, this);
                    }
                    if (this.textSpans[i].glyph) {
                        var glyph = this.textSpans[i].glyph;
                        this.textSpans[i].childSpan.removeChild(glyph.layerElement);
                        glyph.destroy();
                    }
                    this.textSpans[i].glyph = glyphElement;
                    glyphElement._debug = true;
                    glyphElement.prepareFrame(0);
                    glyphElement.renderFrame();
                    this.textSpans[i].childSpan.appendChild(glyphElement.layerElement); // when using animated shapes, the layer will be scaled instead of replacing the internal scale
                    // this might have issues with strokes and might need a different solution
                    if (charData.t === 1) this.textSpans[i].childSpan.setAttribute("transform", "scale(" + documentData.finalSize / 100 + "," + documentData.finalSize / 100 + ")");
                } else {
                    if (singleShape) tSpan.setAttribute("transform", "translate(" + matrixHelper.props[12] + "," + matrixHelper.props[13] + ")");
                    tSpan.textContent = letters[i].val;
                    tSpan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
                } //
            }
            if (singleShape && tSpan) tSpan.setAttribute("d", shapeStr);
        }
        while(i < this.textSpans.length){
            this.textSpans[i].span.style.display = "none";
            i += 1;
        }
        this._sizeChanged = true;
    };
    SVGTextLottieElement.prototype.sourceRectAtTime = function() {
        this.prepareFrame(this.comp.renderedFrame - this.data.st);
        this.renderInnerContent();
        if (this._sizeChanged) {
            this._sizeChanged = false;
            var textBox = this.layerElement.getBBox();
            this.bbox = {
                top: textBox.y,
                left: textBox.x,
                width: textBox.width,
                height: textBox.height
            };
        }
        return this.bbox;
    };
    SVGTextLottieElement.prototype.getValue = function() {
        var i;
        var len = this.textSpans.length;
        var glyphElement;
        this.renderedFrame = this.comp.renderedFrame;
        for(i = 0; i < len; i += 1){
            glyphElement = this.textSpans[i].glyph;
            if (glyphElement) {
                glyphElement.prepareFrame(this.comp.renderedFrame - this.data.st);
                if (glyphElement._mdf) this._mdf = true;
            }
        }
    };
    SVGTextLottieElement.prototype.renderInnerContent = function() {
        if (!this.data.singleShape || this._mdf) {
            this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
            if (this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {
                this._sizeChanged = true;
                var i;
                var len;
                var renderedLetters = this.textAnimator.renderedLetters;
                var letters = this.textProperty.currentData.l;
                len = letters.length;
                var renderedLetter;
                var textSpan;
                var glyphElement;
                for(i = 0; i < len; i += 1)if (!letters[i].n) {
                    renderedLetter = renderedLetters[i];
                    textSpan = this.textSpans[i].span;
                    glyphElement = this.textSpans[i].glyph;
                    if (glyphElement) glyphElement.renderFrame();
                    if (renderedLetter._mdf.m) textSpan.setAttribute("transform", renderedLetter.m);
                    if (renderedLetter._mdf.o) textSpan.setAttribute("opacity", renderedLetter.o);
                    if (renderedLetter._mdf.sw) textSpan.setAttribute("stroke-width", renderedLetter.sw);
                    if (renderedLetter._mdf.sc) textSpan.setAttribute("stroke", renderedLetter.sc);
                    if (renderedLetter._mdf.fc) textSpan.setAttribute("fill", renderedLetter.fc);
                }
            }
        }
    };
    function ISolidElement(data, globalData, comp) {
        this.initElement(data, globalData, comp);
    }
    extendPrototype([
        IImageElement
    ], ISolidElement);
    ISolidElement.prototype.createContent = function() {
        var rect = createNS("rect"); /// /rect.style.width = this.data.sw;
        /// /rect.style.height = this.data.sh;
        /// /rect.style.fill = this.data.sc;
        rect.setAttribute("width", this.data.sw);
        rect.setAttribute("height", this.data.sh);
        rect.setAttribute("fill", this.data.sc);
        this.layerElement.appendChild(rect);
    };
    function NullElement(data, globalData, comp) {
        this.initFrame();
        this.initBaseData(data, globalData, comp);
        this.initFrame();
        this.initTransform(data, globalData, comp);
        this.initHierarchy();
    }
    NullElement.prototype.prepareFrame = function(num) {
        this.prepareProperties(num, true);
    };
    NullElement.prototype.renderFrame = function() {};
    NullElement.prototype.getBaseElement = function() {
        return null;
    };
    NullElement.prototype.destroy = function() {};
    NullElement.prototype.sourceRectAtTime = function() {};
    NullElement.prototype.hide = function() {};
    extendPrototype([
        BaseElement,
        TransformElement,
        HierarchyElement,
        FrameElement
    ], NullElement);
    function SVGRendererBase() {}
    extendPrototype([
        BaseRenderer
    ], SVGRendererBase);
    SVGRendererBase.prototype.createNull = function(data) {
        return new NullElement(data, this.globalData, this);
    };
    SVGRendererBase.prototype.createShape = function(data) {
        return new SVGShapeElement(data, this.globalData, this);
    };
    SVGRendererBase.prototype.createText = function(data) {
        return new SVGTextLottieElement(data, this.globalData, this);
    };
    SVGRendererBase.prototype.createImage = function(data) {
        return new IImageElement(data, this.globalData, this);
    };
    SVGRendererBase.prototype.createSolid = function(data) {
        return new ISolidElement(data, this.globalData, this);
    };
    SVGRendererBase.prototype.configAnimation = function(animData) {
        this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg");
        if (this.renderConfig.viewBoxSize) this.svgElement.setAttribute("viewBox", this.renderConfig.viewBoxSize);
        else this.svgElement.setAttribute("viewBox", "0 0 " + animData.w + " " + animData.h);
        if (!this.renderConfig.viewBoxOnly) {
            this.svgElement.setAttribute("width", animData.w);
            this.svgElement.setAttribute("height", animData.h);
            this.svgElement.style.width = "100%";
            this.svgElement.style.height = "100%";
            this.svgElement.style.transform = "translate3d(0,0,0)";
            this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility;
        }
        if (this.renderConfig.width) this.svgElement.setAttribute("width", this.renderConfig.width);
        if (this.renderConfig.height) this.svgElement.setAttribute("height", this.renderConfig.height);
        if (this.renderConfig.className) this.svgElement.setAttribute("class", this.renderConfig.className);
        if (this.renderConfig.id) this.svgElement.setAttribute("id", this.renderConfig.id);
        if (this.renderConfig.focusable !== undefined) this.svgElement.setAttribute("focusable", this.renderConfig.focusable);
        this.svgElement.setAttribute("preserveAspectRatio", this.renderConfig.preserveAspectRatio); // this.layerElement.style.transform = 'translate3d(0,0,0)';
        // this.layerElement.style.transformOrigin = this.layerElement.style.mozTransformOrigin = this.layerElement.style.webkitTransformOrigin = this.layerElement.style['-webkit-transform'] = "0px 0px 0px";
        this.animationItem.wrapper.appendChild(this.svgElement); // Mask animation
        var defs = this.globalData.defs;
        this.setupGlobalData(animData, defs);
        this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
        this.data = animData;
        var maskElement = createNS("clipPath");
        var rect = createNS("rect");
        rect.setAttribute("width", animData.w);
        rect.setAttribute("height", animData.h);
        rect.setAttribute("x", 0);
        rect.setAttribute("y", 0);
        var maskId = createElementID();
        maskElement.setAttribute("id", maskId);
        maskElement.appendChild(rect);
        this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + maskId + ")");
        defs.appendChild(maskElement);
        this.layers = animData.layers;
        this.elements = createSizedArray(animData.layers.length);
    };
    SVGRendererBase.prototype.destroy = function() {
        if (this.animationItem.wrapper) this.animationItem.wrapper.innerText = "";
        this.layerElement = null;
        this.globalData.defs = null;
        var i;
        var len = this.layers ? this.layers.length : 0;
        for(i = 0; i < len; i += 1)if (this.elements[i]) this.elements[i].destroy();
        this.elements.length = 0;
        this.destroyed = true;
        this.animationItem = null;
    };
    SVGRendererBase.prototype.updateContainerSize = function() {};
    SVGRendererBase.prototype.buildItem = function(pos) {
        var elements = this.elements;
        if (elements[pos] || this.layers[pos].ty === 99) return;
        elements[pos] = true;
        var element = this.createItem(this.layers[pos]);
        elements[pos] = element;
        if (getExpressionsPlugin()) {
            if (this.layers[pos].ty === 0) this.globalData.projectInterface.registerComposition(element);
            element.initExpressions();
        }
        this.appendElementInPos(element, pos);
        if (this.layers[pos].tt) {
            if (!this.elements[pos - 1] || this.elements[pos - 1] === true) {
                this.buildItem(pos - 1);
                this.addPendingElement(element);
            } else element.setMatte(elements[pos - 1].layerId);
        }
    };
    SVGRendererBase.prototype.checkPendingElements = function() {
        while(this.pendingElements.length){
            var element = this.pendingElements.pop();
            element.checkParenting();
            if (element.data.tt) {
                var i = 0;
                var len = this.elements.length;
                while(i < len){
                    if (this.elements[i] === element) {
                        element.setMatte(this.elements[i - 1].layerId);
                        break;
                    }
                    i += 1;
                }
            }
        }
    };
    SVGRendererBase.prototype.renderFrame = function(num) {
        if (this.renderedFrame === num || this.destroyed) return;
        if (num === null) num = this.renderedFrame;
        else this.renderedFrame = num;
         // console.log('-------');
        // console.log('FRAME ',num);
        this.globalData.frameNum = num;
        this.globalData.frameId += 1;
        this.globalData.projectInterface.currentFrame = num;
        this.globalData._mdf = false;
        var i;
        var len = this.layers.length;
        if (!this.completeLayers) this.checkLayers(num);
        for(i = len - 1; i >= 0; i -= 1)if (this.completeLayers || this.elements[i]) this.elements[i].prepareFrame(num - this.layers[i].st);
        if (this.globalData._mdf) {
            for(i = 0; i < len; i += 1)if (this.completeLayers || this.elements[i]) this.elements[i].renderFrame();
        }
    };
    SVGRendererBase.prototype.appendElementInPos = function(element, pos) {
        var newElement = element.getBaseElement();
        if (!newElement) return;
        var i = 0;
        var nextElement;
        while(i < pos){
            if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement()) nextElement = this.elements[i].getBaseElement();
            i += 1;
        }
        if (nextElement) this.layerElement.insertBefore(newElement, nextElement);
        else this.layerElement.appendChild(newElement);
    };
    SVGRendererBase.prototype.hide = function() {
        this.layerElement.style.display = "none";
    };
    SVGRendererBase.prototype.show = function() {
        this.layerElement.style.display = "block";
    };
    function ICompElement() {}
    extendPrototype([
        BaseElement,
        TransformElement,
        HierarchyElement,
        FrameElement,
        RenderableDOMElement
    ], ICompElement);
    ICompElement.prototype.initElement = function(data, globalData, comp) {
        this.initFrame();
        this.initBaseData(data, globalData, comp);
        this.initTransform(data, globalData, comp);
        this.initRenderable();
        this.initHierarchy();
        this.initRendererElement();
        this.createContainerElements();
        this.createRenderableComponents();
        if (this.data.xt || !globalData.progressiveLoad) this.buildAllItems();
        this.hide();
    };
    /* ICompElement.prototype.hide = function(){
      if(!this.hidden){
          this.hideElement();
          var i,len = this.elements.length;
          for( i = 0; i < len; i+=1 ){
              if(this.elements[i]){
                  this.elements[i].hide();
              }
          }
      }
  }; */ ICompElement.prototype.prepareFrame = function(num) {
        this._mdf = false;
        this.prepareRenderableFrame(num);
        this.prepareProperties(num, this.isInRange);
        if (!this.isInRange && !this.data.xt) return;
        if (!this.tm._placeholder) {
            var timeRemapped = this.tm.v;
            if (timeRemapped === this.data.op) timeRemapped = this.data.op - 1;
            this.renderedFrame = timeRemapped;
        } else this.renderedFrame = num / this.data.sr;
        var i;
        var len = this.elements.length;
        if (!this.completeLayers) this.checkLayers(this.renderedFrame);
         // This iteration needs to be backwards because of how expressions connect between each other
        for(i = len - 1; i >= 0; i -= 1)if (this.completeLayers || this.elements[i]) {
            this.elements[i].prepareFrame(this.renderedFrame - this.layers[i].st);
            if (this.elements[i]._mdf) this._mdf = true;
        }
    };
    ICompElement.prototype.renderInnerContent = function() {
        var i;
        var len = this.layers.length;
        for(i = 0; i < len; i += 1)if (this.completeLayers || this.elements[i]) this.elements[i].renderFrame();
    };
    ICompElement.prototype.setElements = function(elems) {
        this.elements = elems;
    };
    ICompElement.prototype.getElements = function() {
        return this.elements;
    };
    ICompElement.prototype.destroyElements = function() {
        var i;
        var len = this.layers.length;
        for(i = 0; i < len; i += 1)if (this.elements[i]) this.elements[i].destroy();
    };
    ICompElement.prototype.destroy = function() {
        this.destroyElements();
        this.destroyBaseElement();
    };
    function SVGCompElement(data, globalData, comp) {
        this.layers = data.layers;
        this.supports3d = true;
        this.completeLayers = false;
        this.pendingElements = [];
        this.elements = this.layers ? createSizedArray(this.layers.length) : [];
        this.initElement(data, globalData, comp);
        this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
            _placeholder: true
        };
    }
    extendPrototype([
        SVGRendererBase,
        ICompElement,
        SVGBaseElement
    ], SVGCompElement);
    SVGCompElement.prototype.createComp = function(data) {
        return new SVGCompElement(data, this.globalData, this);
    };
    function SVGRenderer(animationItem, config) {
        this.animationItem = animationItem;
        this.layers = null;
        this.renderedFrame = -1;
        this.svgElement = createNS("svg");
        var ariaLabel = "";
        if (config && config.title) {
            var titleElement = createNS("title");
            var titleId = createElementID();
            titleElement.setAttribute("id", titleId);
            titleElement.textContent = config.title;
            this.svgElement.appendChild(titleElement);
            ariaLabel += titleId;
        }
        if (config && config.description) {
            var descElement = createNS("desc");
            var descId = createElementID();
            descElement.setAttribute("id", descId);
            descElement.textContent = config.description;
            this.svgElement.appendChild(descElement);
            ariaLabel += " " + descId;
        }
        if (ariaLabel) this.svgElement.setAttribute("aria-labelledby", ariaLabel);
        var defs = createNS("defs");
        this.svgElement.appendChild(defs);
        var maskElement = createNS("g");
        this.svgElement.appendChild(maskElement);
        this.layerElement = maskElement;
        this.renderConfig = {
            preserveAspectRatio: config && config.preserveAspectRatio || "xMidYMid meet",
            imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || "xMidYMid slice",
            contentVisibility: config && config.contentVisibility || "visible",
            progressiveLoad: config && config.progressiveLoad || false,
            hideOnTransparent: !(config && config.hideOnTransparent === false),
            viewBoxOnly: config && config.viewBoxOnly || false,
            viewBoxSize: config && config.viewBoxSize || false,
            className: config && config.className || "",
            id: config && config.id || "",
            focusable: config && config.focusable,
            filterSize: {
                width: config && config.filterSize && config.filterSize.width || "100%",
                height: config && config.filterSize && config.filterSize.height || "100%",
                x: config && config.filterSize && config.filterSize.x || "0%",
                y: config && config.filterSize && config.filterSize.y || "0%"
            },
            width: config && config.width,
            height: config && config.height
        };
        this.globalData = {
            _mdf: false,
            frameNum: -1,
            defs: defs,
            renderConfig: this.renderConfig
        };
        this.elements = [];
        this.pendingElements = [];
        this.destroyed = false;
        this.rendererType = "svg";
    }
    extendPrototype([
        SVGRendererBase
    ], SVGRenderer);
    SVGRenderer.prototype.createComp = function(data) {
        return new SVGCompElement(data, this.globalData, this);
    };
    function CVContextData() {
        this.saved = [];
        this.cArrPos = 0;
        this.cTr = new Matrix();
        this.cO = 1;
        var i;
        var len = 15;
        this.savedOp = createTypedArray("float32", len);
        for(i = 0; i < len; i += 1)this.saved[i] = createTypedArray("float32", 16);
        this._length = len;
    }
    CVContextData.prototype.duplicate = function() {
        var newLength = this._length * 2;
        var currentSavedOp = this.savedOp;
        this.savedOp = createTypedArray("float32", newLength);
        this.savedOp.set(currentSavedOp);
        var i = 0;
        for(i = this._length; i < newLength; i += 1)this.saved[i] = createTypedArray("float32", 16);
        this._length = newLength;
    };
    CVContextData.prototype.reset = function() {
        this.cArrPos = 0;
        this.cTr.reset();
        this.cO = 1;
    };
    function ShapeTransformManager() {
        this.sequences = {};
        this.sequenceList = [];
        this.transform_key_count = 0;
    }
    ShapeTransformManager.prototype = {
        addTransformSequence: function addTransformSequence(transforms) {
            var i;
            var len = transforms.length;
            var key = "_";
            for(i = 0; i < len; i += 1)key += transforms[i].transform.key + "_";
            var sequence = this.sequences[key];
            if (!sequence) {
                sequence = {
                    transforms: [].concat(transforms),
                    finalTransform: new Matrix(),
                    _mdf: false
                };
                this.sequences[key] = sequence;
                this.sequenceList.push(sequence);
            }
            return sequence;
        },
        processSequence: function processSequence(sequence, isFirstFrame) {
            var i = 0;
            var len = sequence.transforms.length;
            var _mdf = isFirstFrame;
            while(i < len && !isFirstFrame){
                if (sequence.transforms[i].transform.mProps._mdf) {
                    _mdf = true;
                    break;
                }
                i += 1;
            }
            if (_mdf) {
                var props;
                sequence.finalTransform.reset();
                for(i = len - 1; i >= 0; i -= 1){
                    props = sequence.transforms[i].transform.mProps.v.props;
                    sequence.finalTransform.transform(props[0], props[1], props[2], props[3], props[4], props[5], props[6], props[7], props[8], props[9], props[10], props[11], props[12], props[13], props[14], props[15]);
                }
            }
            sequence._mdf = _mdf;
        },
        processSequences: function processSequences(isFirstFrame) {
            var i;
            var len = this.sequenceList.length;
            for(i = 0; i < len; i += 1)this.processSequence(this.sequenceList[i], isFirstFrame);
        },
        getNewKey: function getNewKey() {
            this.transform_key_count += 1;
            return "_" + this.transform_key_count;
        }
    };
    function CVEffects() {}
    CVEffects.prototype.renderFrame = function() {};
    function CVMaskElement(data, element) {
        this.data = data;
        this.element = element;
        this.masksProperties = this.data.masksProperties || [];
        this.viewData = createSizedArray(this.masksProperties.length);
        var i;
        var len = this.masksProperties.length;
        var hasMasks = false;
        for(i = 0; i < len; i += 1){
            if (this.masksProperties[i].mode !== "n") hasMasks = true;
            this.viewData[i] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[i], 3);
        }
        this.hasMasks = hasMasks;
        if (hasMasks) this.element.addRenderableComponent(this);
    }
    CVMaskElement.prototype.renderFrame = function() {
        if (!this.hasMasks) return;
        var transform = this.element.finalTransform.mat;
        var ctx = this.element.canvasContext;
        var i;
        var len = this.masksProperties.length;
        var pt;
        var pts;
        var data;
        ctx.beginPath();
        for(i = 0; i < len; i += 1)if (this.masksProperties[i].mode !== "n") {
            if (this.masksProperties[i].inv) {
                ctx.moveTo(0, 0);
                ctx.lineTo(this.element.globalData.compSize.w, 0);
                ctx.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h);
                ctx.lineTo(0, this.element.globalData.compSize.h);
                ctx.lineTo(0, 0);
            }
            data = this.viewData[i].v;
            pt = transform.applyToPointArray(data.v[0][0], data.v[0][1], 0);
            ctx.moveTo(pt[0], pt[1]);
            var j;
            var jLen = data._length;
            for(j = 1; j < jLen; j += 1){
                pts = transform.applyToTriplePoints(data.o[j - 1], data.i[j], data.v[j]);
                ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
            }
            pts = transform.applyToTriplePoints(data.o[j - 1], data.i[0], data.v[0]);
            ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
        }
        this.element.globalData.renderer.save(true);
        ctx.clip();
    };
    CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty;
    CVMaskElement.prototype.destroy = function() {
        this.element = null;
    };
    function CVBaseElement() {}
    CVBaseElement.prototype = {
        createElements: function createElements() {},
        initRendererElement: function initRendererElement() {},
        createContainerElements: function createContainerElements() {
            this.canvasContext = this.globalData.canvasContext;
            this.renderableEffectsManager = new CVEffects(this);
        },
        createContent: function createContent() {},
        setBlendMode: function setBlendMode() {
            var globalData = this.globalData;
            if (globalData.blendMode !== this.data.bm) {
                globalData.blendMode = this.data.bm;
                var blendModeValue = getBlendMode(this.data.bm);
                globalData.canvasContext.globalCompositeOperation = blendModeValue;
            }
        },
        createRenderableComponents: function createRenderableComponents() {
            this.maskManager = new CVMaskElement(this.data, this);
        },
        hideElement: function hideElement() {
            if (!this.hidden && (!this.isInRange || this.isTransparent)) this.hidden = true;
        },
        showElement: function showElement() {
            if (this.isInRange && !this.isTransparent) {
                this.hidden = false;
                this._isFirstFrame = true;
                this.maskManager._isFirstFrame = true;
            }
        },
        renderFrame: function renderFrame() {
            if (this.hidden || this.data.hd) return;
            this.renderTransform();
            this.renderRenderable();
            this.setBlendMode();
            var forceRealStack = this.data.ty === 0;
            this.globalData.renderer.save(forceRealStack);
            this.globalData.renderer.ctxTransform(this.finalTransform.mat.props);
            this.globalData.renderer.ctxOpacity(this.finalTransform.mProp.o.v);
            this.renderInnerContent();
            this.globalData.renderer.restore(forceRealStack);
            if (this.maskManager.hasMasks) this.globalData.renderer.restore(true);
            if (this._isFirstFrame) this._isFirstFrame = false;
        },
        destroy: function destroy() {
            this.canvasContext = null;
            this.data = null;
            this.globalData = null;
            this.maskManager.destroy();
        },
        mHelper: new Matrix()
    };
    CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement;
    CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;
    function CVShapeData(element, data, styles, transformsManager) {
        this.styledShapes = [];
        this.tr = [
            0,
            0,
            0,
            0,
            0,
            0
        ];
        var ty = 4;
        if (data.ty === "rc") ty = 5;
        else if (data.ty === "el") ty = 6;
        else if (data.ty === "sr") ty = 7;
        this.sh = ShapePropertyFactory.getShapeProp(element, data, ty, element);
        var i;
        var len = styles.length;
        var styledShape;
        for(i = 0; i < len; i += 1)if (!styles[i].closed) {
            styledShape = {
                transforms: transformsManager.addTransformSequence(styles[i].transforms),
                trNodes: []
            };
            this.styledShapes.push(styledShape);
            styles[i].elements.push(styledShape);
        }
    }
    CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;
    function CVShapeElement(data, globalData, comp) {
        this.shapes = [];
        this.shapesData = data.shapes;
        this.stylesList = [];
        this.itemsData = [];
        this.prevViewData = [];
        this.shapeModifiers = [];
        this.processedElements = [];
        this.transformsManager = new ShapeTransformManager();
        this.initElement(data, globalData, comp);
    }
    extendPrototype([
        BaseElement,
        TransformElement,
        CVBaseElement,
        IShapeElement,
        HierarchyElement,
        FrameElement,
        RenderableElement
    ], CVShapeElement);
    CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement;
    CVShapeElement.prototype.transformHelper = {
        opacity: 1,
        _opMdf: false
    };
    CVShapeElement.prototype.dashResetter = [];
    CVShapeElement.prototype.createContent = function() {
        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
    };
    CVShapeElement.prototype.createStyleElement = function(data, transforms) {
        var styleElem = {
            data: data,
            type: data.ty,
            preTransforms: this.transformsManager.addTransformSequence(transforms),
            transforms: [],
            elements: [],
            closed: data.hd === true
        };
        var elementData = {};
        if (data.ty === "fl" || data.ty === "st") {
            elementData.c = PropertyFactory.getProp(this, data.c, 1, 255, this);
            if (!elementData.c.k) styleElem.co = "rgb(" + bmFloor(elementData.c.v[0]) + "," + bmFloor(elementData.c.v[1]) + "," + bmFloor(elementData.c.v[2]) + ")";
        } else if (data.ty === "gf" || data.ty === "gs") {
            elementData.s = PropertyFactory.getProp(this, data.s, 1, null, this);
            elementData.e = PropertyFactory.getProp(this, data.e, 1, null, this);
            elementData.h = PropertyFactory.getProp(this, data.h || {
                k: 0
            }, 0, 0.01, this);
            elementData.a = PropertyFactory.getProp(this, data.a || {
                k: 0
            }, 0, degToRads, this);
            elementData.g = new GradientProperty(this, data.g, this);
        }
        elementData.o = PropertyFactory.getProp(this, data.o, 0, 0.01, this);
        if (data.ty === "st" || data.ty === "gs") {
            styleElem.lc = lineCapEnum[data.lc || 2];
            styleElem.lj = lineJoinEnum[data.lj || 2];
            if (data.lj == 1) // eslint-disable-line eqeqeq
            styleElem.ml = data.ml;
            elementData.w = PropertyFactory.getProp(this, data.w, 0, null, this);
            if (!elementData.w.k) styleElem.wi = elementData.w.v;
            if (data.d) {
                var d = new DashProperty(this, data.d, "canvas", this);
                elementData.d = d;
                if (!elementData.d.k) {
                    styleElem.da = elementData.d.dashArray;
                    styleElem["do"] = elementData.d.dashoffset[0];
                }
            }
        } else styleElem.r = data.r === 2 ? "evenodd" : "nonzero";
        this.stylesList.push(styleElem);
        elementData.style = styleElem;
        return elementData;
    };
    CVShapeElement.prototype.createGroupElement = function() {
        var elementData = {
            it: [],
            prevViewData: []
        };
        return elementData;
    };
    CVShapeElement.prototype.createTransformElement = function(data) {
        var elementData = {
            transform: {
                opacity: 1,
                _opMdf: false,
                key: this.transformsManager.getNewKey(),
                op: PropertyFactory.getProp(this, data.o, 0, 0.01, this),
                mProps: TransformPropertyFactory.getTransformProperty(this, data, this)
            }
        };
        return elementData;
    };
    CVShapeElement.prototype.createShapeElement = function(data) {
        var elementData = new CVShapeData(this, data, this.stylesList, this.transformsManager);
        this.shapes.push(elementData);
        this.addShapeToModifiers(elementData);
        return elementData;
    };
    CVShapeElement.prototype.reloadShapes = function() {
        this._isFirstFrame = true;
        var i;
        var len = this.itemsData.length;
        for(i = 0; i < len; i += 1)this.prevViewData[i] = this.itemsData[i];
        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
        len = this.dynamicProperties.length;
        for(i = 0; i < len; i += 1)this.dynamicProperties[i].getValue();
        this.renderModifiers();
        this.transformsManager.processSequences(this._isFirstFrame);
    };
    CVShapeElement.prototype.addTransformToStyleList = function(transform) {
        var i;
        var len = this.stylesList.length;
        for(i = 0; i < len; i += 1)if (!this.stylesList[i].closed) this.stylesList[i].transforms.push(transform);
    };
    CVShapeElement.prototype.removeTransformFromStyleList = function() {
        var i;
        var len = this.stylesList.length;
        for(i = 0; i < len; i += 1)if (!this.stylesList[i].closed) this.stylesList[i].transforms.pop();
    };
    CVShapeElement.prototype.closeStyles = function(styles) {
        var i;
        var len = styles.length;
        for(i = 0; i < len; i += 1)styles[i].closed = true;
    };
    CVShapeElement.prototype.searchShapes = function(arr, itemsData, prevViewData, shouldRender, transforms) {
        var i;
        var len = arr.length - 1;
        var j;
        var jLen;
        var ownStyles = [];
        var ownModifiers = [];
        var processedPos;
        var modifier;
        var currentTransform;
        var ownTransforms = [].concat(transforms);
        for(i = len; i >= 0; i -= 1){
            processedPos = this.searchProcessedElement(arr[i]);
            if (!processedPos) arr[i]._shouldRender = shouldRender;
            else itemsData[i] = prevViewData[processedPos - 1];
            if (arr[i].ty === "fl" || arr[i].ty === "st" || arr[i].ty === "gf" || arr[i].ty === "gs") {
                if (!processedPos) itemsData[i] = this.createStyleElement(arr[i], ownTransforms);
                else itemsData[i].style.closed = false;
                ownStyles.push(itemsData[i].style);
            } else if (arr[i].ty === "gr") {
                if (!processedPos) itemsData[i] = this.createGroupElement(arr[i]);
                else {
                    jLen = itemsData[i].it.length;
                    for(j = 0; j < jLen; j += 1)itemsData[i].prevViewData[j] = itemsData[i].it[j];
                }
                this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, shouldRender, ownTransforms);
            } else if (arr[i].ty === "tr") {
                if (!processedPos) {
                    currentTransform = this.createTransformElement(arr[i]);
                    itemsData[i] = currentTransform;
                }
                ownTransforms.push(itemsData[i]);
                this.addTransformToStyleList(itemsData[i]);
            } else if (arr[i].ty === "sh" || arr[i].ty === "rc" || arr[i].ty === "el" || arr[i].ty === "sr") {
                if (!processedPos) itemsData[i] = this.createShapeElement(arr[i]);
            } else if (arr[i].ty === "tm" || arr[i].ty === "rd" || arr[i].ty === "pb") {
                if (!processedPos) {
                    modifier = ShapeModifiers.getModifier(arr[i].ty);
                    modifier.init(this, arr[i]);
                    itemsData[i] = modifier;
                    this.shapeModifiers.push(modifier);
                } else {
                    modifier = itemsData[i];
                    modifier.closed = false;
                }
                ownModifiers.push(modifier);
            } else if (arr[i].ty === "rp") {
                if (!processedPos) {
                    modifier = ShapeModifiers.getModifier(arr[i].ty);
                    itemsData[i] = modifier;
                    modifier.init(this, arr, i, itemsData);
                    this.shapeModifiers.push(modifier);
                    shouldRender = false;
                } else {
                    modifier = itemsData[i];
                    modifier.closed = true;
                }
                ownModifiers.push(modifier);
            }
            this.addProcessedElement(arr[i], i + 1);
        }
        this.removeTransformFromStyleList();
        this.closeStyles(ownStyles);
        len = ownModifiers.length;
        for(i = 0; i < len; i += 1)ownModifiers[i].closed = true;
    };
    CVShapeElement.prototype.renderInnerContent = function() {
        this.transformHelper.opacity = 1;
        this.transformHelper._opMdf = false;
        this.renderModifiers();
        this.transformsManager.processSequences(this._isFirstFrame);
        this.renderShape(this.transformHelper, this.shapesData, this.itemsData, true);
    };
    CVShapeElement.prototype.renderShapeTransform = function(parentTransform, groupTransform) {
        if (parentTransform._opMdf || groupTransform.op._mdf || this._isFirstFrame) {
            groupTransform.opacity = parentTransform.opacity;
            groupTransform.opacity *= groupTransform.op.v;
            groupTransform._opMdf = true;
        }
    };
    CVShapeElement.prototype.drawLayer = function() {
        var i;
        var len = this.stylesList.length;
        var j;
        var jLen;
        var k;
        var kLen;
        var elems;
        var nodes;
        var renderer = this.globalData.renderer;
        var ctx = this.globalData.canvasContext;
        var type;
        var currentStyle;
        for(i = 0; i < len; i += 1){
            currentStyle = this.stylesList[i];
            type = currentStyle.type; // Skipping style when
            // Stroke width equals 0
            // style should not be rendered (extra unused repeaters)
            // current opacity equals 0
            // global opacity equals 0
            if (!((type === "st" || type === "gs") && currentStyle.wi === 0 || !currentStyle.data._shouldRender || currentStyle.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) {
                renderer.save();
                elems = currentStyle.elements;
                if (type === "st" || type === "gs") {
                    ctx.strokeStyle = type === "st" ? currentStyle.co : currentStyle.grd;
                    ctx.lineWidth = currentStyle.wi;
                    ctx.lineCap = currentStyle.lc;
                    ctx.lineJoin = currentStyle.lj;
                    ctx.miterLimit = currentStyle.ml || 0;
                } else ctx.fillStyle = type === "fl" ? currentStyle.co : currentStyle.grd;
                renderer.ctxOpacity(currentStyle.coOp);
                if (type !== "st" && type !== "gs") ctx.beginPath();
                renderer.ctxTransform(currentStyle.preTransforms.finalTransform.props);
                jLen = elems.length;
                for(j = 0; j < jLen; j += 1){
                    if (type === "st" || type === "gs") {
                        ctx.beginPath();
                        if (currentStyle.da) {
                            ctx.setLineDash(currentStyle.da);
                            ctx.lineDashOffset = currentStyle["do"];
                        }
                    }
                    nodes = elems[j].trNodes;
                    kLen = nodes.length;
                    for(k = 0; k < kLen; k += 1){
                        if (nodes[k].t === "m") ctx.moveTo(nodes[k].p[0], nodes[k].p[1]);
                        else if (nodes[k].t === "c") ctx.bezierCurveTo(nodes[k].pts[0], nodes[k].pts[1], nodes[k].pts[2], nodes[k].pts[3], nodes[k].pts[4], nodes[k].pts[5]);
                        else ctx.closePath();
                    }
                    if (type === "st" || type === "gs") {
                        ctx.stroke();
                        if (currentStyle.da) ctx.setLineDash(this.dashResetter);
                    }
                }
                if (type !== "st" && type !== "gs") ctx.fill(currentStyle.r);
                renderer.restore();
            }
        }
    };
    CVShapeElement.prototype.renderShape = function(parentTransform, items, data, isMain) {
        var i;
        var len = items.length - 1;
        var groupTransform;
        groupTransform = parentTransform;
        for(i = len; i >= 0; i -= 1){
            if (items[i].ty === "tr") {
                groupTransform = data[i].transform;
                this.renderShapeTransform(parentTransform, groupTransform);
            } else if (items[i].ty === "sh" || items[i].ty === "el" || items[i].ty === "rc" || items[i].ty === "sr") this.renderPath(items[i], data[i]);
            else if (items[i].ty === "fl") this.renderFill(items[i], data[i], groupTransform);
            else if (items[i].ty === "st") this.renderStroke(items[i], data[i], groupTransform);
            else if (items[i].ty === "gf" || items[i].ty === "gs") this.renderGradientFill(items[i], data[i], groupTransform);
            else if (items[i].ty === "gr") this.renderShape(groupTransform, items[i].it, data[i].it);
            else items[i].ty;
        }
        if (isMain) this.drawLayer();
    };
    CVShapeElement.prototype.renderStyledShape = function(styledShape, shape) {
        if (this._isFirstFrame || shape._mdf || styledShape.transforms._mdf) {
            var shapeNodes = styledShape.trNodes;
            var paths = shape.paths;
            var i;
            var len;
            var j;
            var jLen = paths._length;
            shapeNodes.length = 0;
            var groupTransformMat = styledShape.transforms.finalTransform;
            for(j = 0; j < jLen; j += 1){
                var pathNodes = paths.shapes[j];
                if (pathNodes && pathNodes.v) {
                    len = pathNodes._length;
                    for(i = 1; i < len; i += 1){
                        if (i === 1) shapeNodes.push({
                            t: "m",
                            p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
                        });
                        shapeNodes.push({
                            t: "c",
                            pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[i], pathNodes.v[i])
                        });
                    }
                    if (len === 1) shapeNodes.push({
                        t: "m",
                        p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
                    });
                    if (pathNodes.c && len) {
                        shapeNodes.push({
                            t: "c",
                            pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[0], pathNodes.v[0])
                        });
                        shapeNodes.push({
                            t: "z"
                        });
                    }
                }
            }
            styledShape.trNodes = shapeNodes;
        }
    };
    CVShapeElement.prototype.renderPath = function(pathData, itemData) {
        if (pathData.hd !== true && pathData._shouldRender) {
            var i;
            var len = itemData.styledShapes.length;
            for(i = 0; i < len; i += 1)this.renderStyledShape(itemData.styledShapes[i], itemData.sh);
        }
    };
    CVShapeElement.prototype.renderFill = function(styleData, itemData, groupTransform) {
        var styleElem = itemData.style;
        if (itemData.c._mdf || this._isFirstFrame) styleElem.co = "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")";
        if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) styleElem.coOp = itemData.o.v * groupTransform.opacity;
    };
    CVShapeElement.prototype.renderGradientFill = function(styleData, itemData, groupTransform) {
        var styleElem = itemData.style;
        var grd;
        if (!styleElem.grd || itemData.g._mdf || itemData.s._mdf || itemData.e._mdf || styleData.t !== 1 && (itemData.h._mdf || itemData.a._mdf)) {
            var ctx = this.globalData.canvasContext;
            var pt1 = itemData.s.v;
            var pt2 = itemData.e.v;
            if (styleData.t === 1) grd = ctx.createLinearGradient(pt1[0], pt1[1], pt2[0], pt2[1]);
            else {
                var rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
                var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
                var percent = itemData.h.v;
                if (percent >= 1) percent = 0.99;
                else if (percent <= -1) percent = -0.99;
                var dist = rad * percent;
                var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
                var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
                grd = ctx.createRadialGradient(x, y, 0, pt1[0], pt1[1], rad);
            }
            var i;
            var len = styleData.g.p;
            var cValues = itemData.g.c;
            var opacity = 1;
            for(i = 0; i < len; i += 1){
                if (itemData.g._hasOpacity && itemData.g._collapsable) opacity = itemData.g.o[i * 2 + 1];
                grd.addColorStop(cValues[i * 4] / 100, "rgba(" + cValues[i * 4 + 1] + "," + cValues[i * 4 + 2] + "," + cValues[i * 4 + 3] + "," + opacity + ")");
            }
            styleElem.grd = grd;
        }
        styleElem.coOp = itemData.o.v * groupTransform.opacity;
    };
    CVShapeElement.prototype.renderStroke = function(styleData, itemData, groupTransform) {
        var styleElem = itemData.style;
        var d = itemData.d;
        if (d && (d._mdf || this._isFirstFrame)) {
            styleElem.da = d.dashArray;
            styleElem["do"] = d.dashoffset[0];
        }
        if (itemData.c._mdf || this._isFirstFrame) styleElem.co = "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")";
        if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) styleElem.coOp = itemData.o.v * groupTransform.opacity;
        if (itemData.w._mdf || this._isFirstFrame) styleElem.wi = itemData.w.v;
    };
    CVShapeElement.prototype.destroy = function() {
        this.shapesData = null;
        this.globalData = null;
        this.canvasContext = null;
        this.stylesList.length = 0;
        this.itemsData.length = 0;
    };
    function CVTextElement(data, globalData, comp) {
        this.textSpans = [];
        this.yOffset = 0;
        this.fillColorAnim = false;
        this.strokeColorAnim = false;
        this.strokeWidthAnim = false;
        this.stroke = false;
        this.fill = false;
        this.justifyOffset = 0;
        this.currentRender = null;
        this.renderType = "canvas";
        this.values = {
            fill: "rgba(0,0,0,0)",
            stroke: "rgba(0,0,0,0)",
            sWidth: 0,
            fValue: ""
        };
        this.initElement(data, globalData, comp);
    }
    extendPrototype([
        BaseElement,
        TransformElement,
        CVBaseElement,
        HierarchyElement,
        FrameElement,
        RenderableElement,
        ITextElement
    ], CVTextElement);
    CVTextElement.prototype.tHelper = createTag("canvas").getContext("2d");
    CVTextElement.prototype.buildNewText = function() {
        var documentData = this.textProperty.currentData;
        this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
        var hasFill = false;
        if (documentData.fc) {
            hasFill = true;
            this.values.fill = this.buildColor(documentData.fc);
        } else this.values.fill = "rgba(0,0,0,0)";
        this.fill = hasFill;
        var hasStroke = false;
        if (documentData.sc) {
            hasStroke = true;
            this.values.stroke = this.buildColor(documentData.sc);
            this.values.sWidth = documentData.sw;
        }
        var fontData = this.globalData.fontManager.getFontByName(documentData.f);
        var i;
        var len;
        var letters = documentData.l;
        var matrixHelper = this.mHelper;
        this.stroke = hasStroke;
        this.values.fValue = documentData.finalSize + "px " + this.globalData.fontManager.getFontByName(documentData.f).fFamily;
        len = documentData.finalText.length; // this.tHelper.font = this.values.fValue;
        var charData;
        var shapeData;
        var k;
        var kLen;
        var shapes;
        var j;
        var jLen;
        var pathNodes;
        var commands;
        var pathArr;
        var singleShape = this.data.singleShape;
        var trackingOffset = documentData.tr * 0.001 * documentData.finalSize;
        var xPos = 0;
        var yPos = 0;
        var firstLine = true;
        var cnt = 0;
        for(i = 0; i < len; i += 1){
            charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
            shapeData = charData && charData.data || {};
            matrixHelper.reset();
            if (singleShape && letters[i].n) {
                xPos = -trackingOffset;
                yPos += documentData.yOffset;
                yPos += firstLine ? 1 : 0;
                firstLine = false;
            }
            shapes = shapeData.shapes ? shapeData.shapes[0].it : [];
            jLen = shapes.length;
            matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
            if (singleShape) this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);
            commands = createSizedArray(jLen - 1);
            var commandsCounter = 0;
            for(j = 0; j < jLen; j += 1)if (shapes[j].ty === "sh") {
                kLen = shapes[j].ks.k.i.length;
                pathNodes = shapes[j].ks.k;
                pathArr = [];
                for(k = 1; k < kLen; k += 1){
                    if (k === 1) pathArr.push(matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
                    pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToY(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToX(pathNodes.v[k][0], pathNodes.v[k][1], 0), matrixHelper.applyToY(pathNodes.v[k][0], pathNodes.v[k][1], 0));
                }
                pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToY(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
                commands[commandsCounter] = pathArr;
                commandsCounter += 1;
            }
            if (singleShape) {
                xPos += letters[i].l;
                xPos += trackingOffset;
            }
            if (this.textSpans[cnt]) this.textSpans[cnt].elem = commands;
            else this.textSpans[cnt] = {
                elem: commands
            };
            cnt += 1;
        }
    };
    CVTextElement.prototype.renderInnerContent = function() {
        var ctx = this.canvasContext;
        ctx.font = this.values.fValue;
        ctx.lineCap = "butt";
        ctx.lineJoin = "miter";
        ctx.miterLimit = 4;
        if (!this.data.singleShape) this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
        var i;
        var len;
        var j;
        var jLen;
        var k;
        var kLen;
        var renderedLetters = this.textAnimator.renderedLetters;
        var letters = this.textProperty.currentData.l;
        len = letters.length;
        var renderedLetter;
        var lastFill = null;
        var lastStroke = null;
        var lastStrokeW = null;
        var commands;
        var pathArr;
        for(i = 0; i < len; i += 1)if (!letters[i].n) {
            renderedLetter = renderedLetters[i];
            if (renderedLetter) {
                this.globalData.renderer.save();
                this.globalData.renderer.ctxTransform(renderedLetter.p);
                this.globalData.renderer.ctxOpacity(renderedLetter.o);
            }
            if (this.fill) {
                if (renderedLetter && renderedLetter.fc) {
                    if (lastFill !== renderedLetter.fc) {
                        lastFill = renderedLetter.fc;
                        ctx.fillStyle = renderedLetter.fc;
                    }
                } else if (lastFill !== this.values.fill) {
                    lastFill = this.values.fill;
                    ctx.fillStyle = this.values.fill;
                }
                commands = this.textSpans[i].elem;
                jLen = commands.length;
                this.globalData.canvasContext.beginPath();
                for(j = 0; j < jLen; j += 1){
                    pathArr = commands[j];
                    kLen = pathArr.length;
                    this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
                    for(k = 2; k < kLen; k += 6)this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
                }
                this.globalData.canvasContext.closePath();
                this.globalData.canvasContext.fill(); /// ctx.fillText(this.textSpans[i].val,0,0);
            }
            if (this.stroke) {
                if (renderedLetter && renderedLetter.sw) {
                    if (lastStrokeW !== renderedLetter.sw) {
                        lastStrokeW = renderedLetter.sw;
                        ctx.lineWidth = renderedLetter.sw;
                    }
                } else if (lastStrokeW !== this.values.sWidth) {
                    lastStrokeW = this.values.sWidth;
                    ctx.lineWidth = this.values.sWidth;
                }
                if (renderedLetter && renderedLetter.sc) {
                    if (lastStroke !== renderedLetter.sc) {
                        lastStroke = renderedLetter.sc;
                        ctx.strokeStyle = renderedLetter.sc;
                    }
                } else if (lastStroke !== this.values.stroke) {
                    lastStroke = this.values.stroke;
                    ctx.strokeStyle = this.values.stroke;
                }
                commands = this.textSpans[i].elem;
                jLen = commands.length;
                this.globalData.canvasContext.beginPath();
                for(j = 0; j < jLen; j += 1){
                    pathArr = commands[j];
                    kLen = pathArr.length;
                    this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
                    for(k = 2; k < kLen; k += 6)this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
                }
                this.globalData.canvasContext.closePath();
                this.globalData.canvasContext.stroke(); /// ctx.strokeText(letters[i].val,0,0);
            }
            if (renderedLetter) this.globalData.renderer.restore();
        }
    };
    function CVImageElement(data, globalData, comp) {
        this.assetData = globalData.getAssetData(data.refId);
        this.img = globalData.imageLoader.getAsset(this.assetData);
        this.initElement(data, globalData, comp);
    }
    extendPrototype([
        BaseElement,
        TransformElement,
        CVBaseElement,
        HierarchyElement,
        FrameElement,
        RenderableElement
    ], CVImageElement);
    CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement;
    CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;
    CVImageElement.prototype.createContent = function() {
        if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
            var canvas = createTag("canvas");
            canvas.width = this.assetData.w;
            canvas.height = this.assetData.h;
            var ctx = canvas.getContext("2d");
            var imgW = this.img.width;
            var imgH = this.img.height;
            var imgRel = imgW / imgH;
            var canvasRel = this.assetData.w / this.assetData.h;
            var widthCrop;
            var heightCrop;
            var par = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
            if (imgRel > canvasRel && par === "xMidYMid slice" || imgRel < canvasRel && par !== "xMidYMid slice") {
                heightCrop = imgH;
                widthCrop = heightCrop * canvasRel;
            } else {
                widthCrop = imgW;
                heightCrop = widthCrop / canvasRel;
            }
            ctx.drawImage(this.img, (imgW - widthCrop) / 2, (imgH - heightCrop) / 2, widthCrop, heightCrop, 0, 0, this.assetData.w, this.assetData.h);
            this.img = canvas;
        }
    };
    CVImageElement.prototype.renderInnerContent = function() {
        this.canvasContext.drawImage(this.img, 0, 0);
    };
    CVImageElement.prototype.destroy = function() {
        this.img = null;
    };
    function CVSolidElement(data, globalData, comp) {
        this.initElement(data, globalData, comp);
    }
    extendPrototype([
        BaseElement,
        TransformElement,
        CVBaseElement,
        HierarchyElement,
        FrameElement,
        RenderableElement
    ], CVSolidElement);
    CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement;
    CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;
    CVSolidElement.prototype.renderInnerContent = function() {
        var ctx = this.canvasContext;
        ctx.fillStyle = this.data.sc;
        ctx.fillRect(0, 0, this.data.sw, this.data.sh); //
    };
    function CanvasRendererBase(animationItem, config) {
        this.animationItem = animationItem;
        this.renderConfig = {
            clearCanvas: config && config.clearCanvas !== undefined ? config.clearCanvas : true,
            context: config && config.context || null,
            progressiveLoad: config && config.progressiveLoad || false,
            preserveAspectRatio: config && config.preserveAspectRatio || "xMidYMid meet",
            imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || "xMidYMid slice",
            contentVisibility: config && config.contentVisibility || "visible",
            className: config && config.className || "",
            id: config && config.id || ""
        };
        this.renderConfig.dpr = config && config.dpr || 1;
        if (this.animationItem.wrapper) this.renderConfig.dpr = config && config.dpr || window.devicePixelRatio || 1;
        this.renderedFrame = -1;
        this.globalData = {
            frameNum: -1,
            _mdf: false,
            renderConfig: this.renderConfig,
            currentGlobalAlpha: -1
        };
        this.contextData = new CVContextData();
        this.elements = [];
        this.pendingElements = [];
        this.transformMat = new Matrix();
        this.completeLayers = false;
        this.rendererType = "canvas";
    }
    extendPrototype([
        BaseRenderer
    ], CanvasRendererBase);
    CanvasRendererBase.prototype.createShape = function(data) {
        return new CVShapeElement(data, this.globalData, this);
    };
    CanvasRendererBase.prototype.createText = function(data) {
        return new CVTextElement(data, this.globalData, this);
    };
    CanvasRendererBase.prototype.createImage = function(data) {
        return new CVImageElement(data, this.globalData, this);
    };
    CanvasRendererBase.prototype.createSolid = function(data) {
        return new CVSolidElement(data, this.globalData, this);
    };
    CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;
    CanvasRendererBase.prototype.ctxTransform = function(props) {
        if (props[0] === 1 && props[1] === 0 && props[4] === 0 && props[5] === 1 && props[12] === 0 && props[13] === 0) return;
        if (!this.renderConfig.clearCanvas) {
            this.canvasContext.transform(props[0], props[1], props[4], props[5], props[12], props[13]);
            return;
        }
        this.transformMat.cloneFromProps(props);
        var cProps = this.contextData.cTr.props;
        this.transformMat.transform(cProps[0], cProps[1], cProps[2], cProps[3], cProps[4], cProps[5], cProps[6], cProps[7], cProps[8], cProps[9], cProps[10], cProps[11], cProps[12], cProps[13], cProps[14], cProps[15]); // this.contextData.cTr.transform(props[0],props[1],props[2],props[3],props[4],props[5],props[6],props[7],props[8],props[9],props[10],props[11],props[12],props[13],props[14],props[15]);
        this.contextData.cTr.cloneFromProps(this.transformMat.props);
        var trProps = this.contextData.cTr.props;
        this.canvasContext.setTransform(trProps[0], trProps[1], trProps[4], trProps[5], trProps[12], trProps[13]);
    };
    CanvasRendererBase.prototype.ctxOpacity = function(op) {
        /* if(op === 1){
          return;
      } */ if (!this.renderConfig.clearCanvas) {
            this.canvasContext.globalAlpha *= op < 0 ? 0 : op;
            this.globalData.currentGlobalAlpha = this.contextData.cO;
            return;
        }
        this.contextData.cO *= op < 0 ? 0 : op;
        if (this.globalData.currentGlobalAlpha !== this.contextData.cO) {
            this.canvasContext.globalAlpha = this.contextData.cO;
            this.globalData.currentGlobalAlpha = this.contextData.cO;
        }
    };
    CanvasRendererBase.prototype.reset = function() {
        if (!this.renderConfig.clearCanvas) {
            this.canvasContext.restore();
            return;
        }
        this.contextData.reset();
    };
    CanvasRendererBase.prototype.save = function(actionFlag) {
        if (!this.renderConfig.clearCanvas) {
            this.canvasContext.save();
            return;
        }
        if (actionFlag) this.canvasContext.save();
        var props = this.contextData.cTr.props;
        if (this.contextData._length <= this.contextData.cArrPos) this.contextData.duplicate();
        var i;
        var arr = this.contextData.saved[this.contextData.cArrPos];
        for(i = 0; i < 16; i += 1)arr[i] = props[i];
        this.contextData.savedOp[this.contextData.cArrPos] = this.contextData.cO;
        this.contextData.cArrPos += 1;
    };
    CanvasRendererBase.prototype.restore = function(actionFlag) {
        if (!this.renderConfig.clearCanvas) {
            this.canvasContext.restore();
            return;
        }
        if (actionFlag) {
            this.canvasContext.restore();
            this.globalData.blendMode = "source-over";
        }
        this.contextData.cArrPos -= 1;
        var popped = this.contextData.saved[this.contextData.cArrPos];
        var i;
        var arr = this.contextData.cTr.props;
        for(i = 0; i < 16; i += 1)arr[i] = popped[i];
        this.canvasContext.setTransform(popped[0], popped[1], popped[4], popped[5], popped[12], popped[13]);
        popped = this.contextData.savedOp[this.contextData.cArrPos];
        this.contextData.cO = popped;
        if (this.globalData.currentGlobalAlpha !== popped) {
            this.canvasContext.globalAlpha = popped;
            this.globalData.currentGlobalAlpha = popped;
        }
    };
    CanvasRendererBase.prototype.configAnimation = function(animData) {
        if (this.animationItem.wrapper) {
            this.animationItem.container = createTag("canvas");
            var containerStyle = this.animationItem.container.style;
            containerStyle.width = "100%";
            containerStyle.height = "100%";
            var origin = "0px 0px 0px";
            containerStyle.transformOrigin = origin;
            containerStyle.mozTransformOrigin = origin;
            containerStyle.webkitTransformOrigin = origin;
            containerStyle["-webkit-transform"] = origin;
            containerStyle.contentVisibility = this.renderConfig.contentVisibility;
            this.animationItem.wrapper.appendChild(this.animationItem.container);
            this.canvasContext = this.animationItem.container.getContext("2d");
            if (this.renderConfig.className) this.animationItem.container.setAttribute("class", this.renderConfig.className);
            if (this.renderConfig.id) this.animationItem.container.setAttribute("id", this.renderConfig.id);
        } else this.canvasContext = this.renderConfig.context;
        this.data = animData;
        this.layers = animData.layers;
        this.transformCanvas = {
            w: animData.w,
            h: animData.h,
            sx: 0,
            sy: 0,
            tx: 0,
            ty: 0
        };
        this.setupGlobalData(animData, document.body);
        this.globalData.canvasContext = this.canvasContext;
        this.globalData.renderer = this;
        this.globalData.isDashed = false;
        this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
        this.globalData.transformCanvas = this.transformCanvas;
        this.elements = createSizedArray(animData.layers.length);
        this.updateContainerSize();
    };
    CanvasRendererBase.prototype.updateContainerSize = function() {
        this.reset();
        var elementWidth;
        var elementHeight;
        if (this.animationItem.wrapper && this.animationItem.container) {
            elementWidth = this.animationItem.wrapper.offsetWidth;
            elementHeight = this.animationItem.wrapper.offsetHeight;
            this.animationItem.container.setAttribute("width", elementWidth * this.renderConfig.dpr);
            this.animationItem.container.setAttribute("height", elementHeight * this.renderConfig.dpr);
        } else {
            elementWidth = this.canvasContext.canvas.width * this.renderConfig.dpr;
            elementHeight = this.canvasContext.canvas.height * this.renderConfig.dpr;
        }
        var elementRel;
        var animationRel;
        if (this.renderConfig.preserveAspectRatio.indexOf("meet") !== -1 || this.renderConfig.preserveAspectRatio.indexOf("slice") !== -1) {
            var par = this.renderConfig.preserveAspectRatio.split(" ");
            var fillType = par[1] || "meet";
            var pos = par[0] || "xMidYMid";
            var xPos = pos.substr(0, 4);
            var yPos = pos.substr(4);
            elementRel = elementWidth / elementHeight;
            animationRel = this.transformCanvas.w / this.transformCanvas.h;
            if (animationRel > elementRel && fillType === "meet" || animationRel < elementRel && fillType === "slice") {
                this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
                this.transformCanvas.sy = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
            } else {
                this.transformCanvas.sx = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
                this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
            }
            if (xPos === "xMid" && (animationRel < elementRel && fillType === "meet" || animationRel > elementRel && fillType === "slice")) this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) / 2 * this.renderConfig.dpr;
            else if (xPos === "xMax" && (animationRel < elementRel && fillType === "meet" || animationRel > elementRel && fillType === "slice")) this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) * this.renderConfig.dpr;
            else this.transformCanvas.tx = 0;
            if (yPos === "YMid" && (animationRel > elementRel && fillType === "meet" || animationRel < elementRel && fillType === "slice")) this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) / 2 * this.renderConfig.dpr;
            else if (yPos === "YMax" && (animationRel > elementRel && fillType === "meet" || animationRel < elementRel && fillType === "slice")) this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) * this.renderConfig.dpr;
            else this.transformCanvas.ty = 0;
        } else if (this.renderConfig.preserveAspectRatio === "none") {
            this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
            this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
            this.transformCanvas.tx = 0;
            this.transformCanvas.ty = 0;
        } else {
            this.transformCanvas.sx = this.renderConfig.dpr;
            this.transformCanvas.sy = this.renderConfig.dpr;
            this.transformCanvas.tx = 0;
            this.transformCanvas.ty = 0;
        }
        this.transformCanvas.props = [
            this.transformCanvas.sx,
            0,
            0,
            0,
            0,
            this.transformCanvas.sy,
            0,
            0,
            0,
            0,
            1,
            0,
            this.transformCanvas.tx,
            this.transformCanvas.ty,
            0,
            1
        ];
        /* var i, len = this.elements.length;
      for(i=0;i<len;i+=1){
          if(this.elements[i] && this.elements[i].data.ty === 0){
              this.elements[i].resize(this.globalData.transformCanvas);
          }
      } */ this.ctxTransform(this.transformCanvas.props);
        this.canvasContext.beginPath();
        this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
        this.canvasContext.closePath();
        this.canvasContext.clip();
        this.renderFrame(this.renderedFrame, true);
    };
    CanvasRendererBase.prototype.destroy = function() {
        if (this.renderConfig.clearCanvas && this.animationItem.wrapper) this.animationItem.wrapper.innerText = "";
        var i;
        var len = this.layers ? this.layers.length : 0;
        for(i = len - 1; i >= 0; i -= 1)if (this.elements[i]) this.elements[i].destroy();
        this.elements.length = 0;
        this.globalData.canvasContext = null;
        this.animationItem.container = null;
        this.destroyed = true;
    };
    CanvasRendererBase.prototype.renderFrame = function(num, forceRender) {
        if (this.renderedFrame === num && this.renderConfig.clearCanvas === true && !forceRender || this.destroyed || num === -1) return;
        this.renderedFrame = num;
        this.globalData.frameNum = num - this.animationItem._isFirstFrame;
        this.globalData.frameId += 1;
        this.globalData._mdf = !this.renderConfig.clearCanvas || forceRender;
        this.globalData.projectInterface.currentFrame = num; // console.log('--------');
        // console.log('NEW: ',num);
        var i;
        var len = this.layers.length;
        if (!this.completeLayers) this.checkLayers(num);
        for(i = 0; i < len; i += 1)if (this.completeLayers || this.elements[i]) this.elements[i].prepareFrame(num - this.layers[i].st);
        if (this.globalData._mdf) {
            if (this.renderConfig.clearCanvas === true) this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
            else this.save();
            for(i = len - 1; i >= 0; i -= 1)if (this.completeLayers || this.elements[i]) this.elements[i].renderFrame();
            if (this.renderConfig.clearCanvas !== true) this.restore();
        }
    };
    CanvasRendererBase.prototype.buildItem = function(pos) {
        var elements = this.elements;
        if (elements[pos] || this.layers[pos].ty === 99) return;
        var element = this.createItem(this.layers[pos], this, this.globalData);
        elements[pos] = element;
        element.initExpressions();
    /* if(this.layers[pos].ty === 0){
          element.resize(this.globalData.transformCanvas);
      } */ };
    CanvasRendererBase.prototype.checkPendingElements = function() {
        while(this.pendingElements.length){
            var element = this.pendingElements.pop();
            element.checkParenting();
        }
    };
    CanvasRendererBase.prototype.hide = function() {
        this.animationItem.container.style.display = "none";
    };
    CanvasRendererBase.prototype.show = function() {
        this.animationItem.container.style.display = "block";
    };
    function CVCompElement(data, globalData, comp) {
        this.completeLayers = false;
        this.layers = data.layers;
        this.pendingElements = [];
        this.elements = createSizedArray(this.layers.length);
        this.initElement(data, globalData, comp);
        this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
            _placeholder: true
        };
    }
    extendPrototype([
        CanvasRendererBase,
        ICompElement,
        CVBaseElement
    ], CVCompElement);
    CVCompElement.prototype.renderInnerContent = function() {
        var ctx = this.canvasContext;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(this.data.w, 0);
        ctx.lineTo(this.data.w, this.data.h);
        ctx.lineTo(0, this.data.h);
        ctx.lineTo(0, 0);
        ctx.clip();
        var i;
        var len = this.layers.length;
        for(i = len - 1; i >= 0; i -= 1)if (this.completeLayers || this.elements[i]) this.elements[i].renderFrame();
    };
    CVCompElement.prototype.destroy = function() {
        var i;
        var len = this.layers.length;
        for(i = len - 1; i >= 0; i -= 1)if (this.elements[i]) this.elements[i].destroy();
        this.layers = null;
        this.elements = null;
    };
    CVCompElement.prototype.createComp = function(data) {
        return new CVCompElement(data, this.globalData, this);
    };
    function CanvasRenderer(animationItem, config) {
        this.animationItem = animationItem;
        this.renderConfig = {
            clearCanvas: config && config.clearCanvas !== undefined ? config.clearCanvas : true,
            context: config && config.context || null,
            progressiveLoad: config && config.progressiveLoad || false,
            preserveAspectRatio: config && config.preserveAspectRatio || "xMidYMid meet",
            imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || "xMidYMid slice",
            contentVisibility: config && config.contentVisibility || "visible",
            className: config && config.className || "",
            id: config && config.id || ""
        };
        this.renderConfig.dpr = config && config.dpr || 1;
        if (this.animationItem.wrapper) this.renderConfig.dpr = config && config.dpr || window.devicePixelRatio || 1;
        this.renderedFrame = -1;
        this.globalData = {
            frameNum: -1,
            _mdf: false,
            renderConfig: this.renderConfig,
            currentGlobalAlpha: -1
        };
        this.contextData = new CVContextData();
        this.elements = [];
        this.pendingElements = [];
        this.transformMat = new Matrix();
        this.completeLayers = false;
        this.rendererType = "canvas";
    }
    extendPrototype([
        CanvasRendererBase
    ], CanvasRenderer);
    CanvasRenderer.prototype.createComp = function(data) {
        return new CVCompElement(data, this.globalData, this);
    };
    function HBaseElement() {}
    HBaseElement.prototype = {
        checkBlendMode: function checkBlendMode() {},
        initRendererElement: function initRendererElement() {
            this.baseElement = createTag(this.data.tg || "div");
            if (this.data.hasMask) {
                this.svgElement = createNS("svg");
                this.layerElement = createNS("g");
                this.maskedElement = this.layerElement;
                this.svgElement.appendChild(this.layerElement);
                this.baseElement.appendChild(this.svgElement);
            } else this.layerElement = this.baseElement;
            styleDiv(this.baseElement);
        },
        createContainerElements: function createContainerElements() {
            this.renderableEffectsManager = new CVEffects(this);
            this.transformedElement = this.baseElement;
            this.maskedElement = this.layerElement;
            if (this.data.ln) this.layerElement.setAttribute("id", this.data.ln);
            if (this.data.cl) this.layerElement.setAttribute("class", this.data.cl);
            if (this.data.bm !== 0) this.setBlendMode();
        },
        renderElement: function renderElement() {
            var transformedElementStyle = this.transformedElement ? this.transformedElement.style : {};
            if (this.finalTransform._matMdf) {
                var matrixValue = this.finalTransform.mat.toCSS();
                transformedElementStyle.transform = matrixValue;
                transformedElementStyle.webkitTransform = matrixValue;
            }
            if (this.finalTransform._opMdf) transformedElementStyle.opacity = this.finalTransform.mProp.o.v;
        },
        renderFrame: function renderFrame() {
            // If it is exported as hidden (data.hd === true) no need to render
            // If it is not visible no need to render
            if (this.data.hd || this.hidden) return;
            this.renderTransform();
            this.renderRenderable();
            this.renderElement();
            this.renderInnerContent();
            if (this._isFirstFrame) this._isFirstFrame = false;
        },
        destroy: function destroy() {
            this.layerElement = null;
            this.transformedElement = null;
            if (this.matteElement) this.matteElement = null;
            if (this.maskManager) {
                this.maskManager.destroy();
                this.maskManager = null;
            }
        },
        createRenderableComponents: function createRenderableComponents() {
            this.maskManager = new MaskElement(this.data, this, this.globalData);
        },
        addEffects: function addEffects() {},
        setMatte: function setMatte() {}
    };
    HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement;
    HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy;
    HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting;
    function HSolidElement(data, globalData, comp) {
        this.initElement(data, globalData, comp);
    }
    extendPrototype([
        BaseElement,
        TransformElement,
        HBaseElement,
        HierarchyElement,
        FrameElement,
        RenderableDOMElement
    ], HSolidElement);
    HSolidElement.prototype.createContent = function() {
        var rect;
        if (this.data.hasMask) {
            rect = createNS("rect");
            rect.setAttribute("width", this.data.sw);
            rect.setAttribute("height", this.data.sh);
            rect.setAttribute("fill", this.data.sc);
            this.svgElement.setAttribute("width", this.data.sw);
            this.svgElement.setAttribute("height", this.data.sh);
        } else {
            rect = createTag("div");
            rect.style.width = this.data.sw + "px";
            rect.style.height = this.data.sh + "px";
            rect.style.backgroundColor = this.data.sc;
        }
        this.layerElement.appendChild(rect);
    };
    function HShapeElement(data, globalData, comp) {
        // List of drawable elements
        this.shapes = []; // Full shape data
        this.shapesData = data.shapes; // List of styles that will be applied to shapes
        this.stylesList = []; // List of modifiers that will be applied to shapes
        this.shapeModifiers = []; // List of items in shape tree
        this.itemsData = []; // List of items in previous shape tree
        this.processedElements = []; // List of animated components
        this.animatedContents = [];
        this.shapesContainer = createNS("g");
        this.initElement(data, globalData, comp); // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
        // List of elements that have been created
        this.prevViewData = [];
        this.currentBBox = {
            x: 999999,
            y: -999999,
            h: 0,
            w: 0
        };
    }
    extendPrototype([
        BaseElement,
        TransformElement,
        HSolidElement,
        SVGShapeElement,
        HBaseElement,
        HierarchyElement,
        FrameElement,
        RenderableElement
    ], HShapeElement);
    HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent;
    HShapeElement.prototype.createContent = function() {
        var cont;
        this.baseElement.style.fontSize = 0;
        if (this.data.hasMask) {
            this.layerElement.appendChild(this.shapesContainer);
            cont = this.svgElement;
        } else {
            cont = createNS("svg");
            var size = this.comp.data ? this.comp.data : this.globalData.compSize;
            cont.setAttribute("width", size.w);
            cont.setAttribute("height", size.h);
            cont.appendChild(this.shapesContainer);
            this.layerElement.appendChild(cont);
        }
        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], true);
        this.filterUniqueShapes();
        this.shapeCont = cont;
    };
    HShapeElement.prototype.getTransformedPoint = function(transformers, point) {
        var i;
        var len = transformers.length;
        for(i = 0; i < len; i += 1)point = transformers[i].mProps.v.applyToPointArray(point[0], point[1], 0);
        return point;
    };
    HShapeElement.prototype.calculateShapeBoundingBox = function(item, boundingBox) {
        var shape = item.sh.v;
        var transformers = item.transformers;
        var i;
        var len = shape._length;
        var vPoint;
        var oPoint;
        var nextIPoint;
        var nextVPoint;
        if (len <= 1) return;
        for(i = 0; i < len - 1; i += 1){
            vPoint = this.getTransformedPoint(transformers, shape.v[i]);
            oPoint = this.getTransformedPoint(transformers, shape.o[i]);
            nextIPoint = this.getTransformedPoint(transformers, shape.i[i + 1]);
            nextVPoint = this.getTransformedPoint(transformers, shape.v[i + 1]);
            this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
        }
        if (shape.c) {
            vPoint = this.getTransformedPoint(transformers, shape.v[i]);
            oPoint = this.getTransformedPoint(transformers, shape.o[i]);
            nextIPoint = this.getTransformedPoint(transformers, shape.i[0]);
            nextVPoint = this.getTransformedPoint(transformers, shape.v[0]);
            this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
        }
    };
    HShapeElement.prototype.checkBounds = function(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox) {
        this.getBoundsOfCurve(vPoint, oPoint, nextIPoint, nextVPoint);
        var bounds = this.shapeBoundingBox;
        boundingBox.x = bmMin(bounds.left, boundingBox.x);
        boundingBox.xMax = bmMax(bounds.right, boundingBox.xMax);
        boundingBox.y = bmMin(bounds.top, boundingBox.y);
        boundingBox.yMax = bmMax(bounds.bottom, boundingBox.yMax);
    };
    HShapeElement.prototype.shapeBoundingBox = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
    };
    HShapeElement.prototype.tempBoundingBox = {
        x: 0,
        xMax: 0,
        y: 0,
        yMax: 0,
        width: 0,
        height: 0
    };
    HShapeElement.prototype.getBoundsOfCurve = function(p0, p1, p2, p3) {
        var bounds = [
            [
                p0[0],
                p3[0]
            ],
            [
                p0[1],
                p3[1]
            ]
        ];
        for(var a, b, c, t, b2ac, t1, t2, i = 0; i < 2; ++i){
            // eslint-disable-line no-plusplus
            b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
            a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
            c = 3 * p1[i] - 3 * p0[i];
            b |= 0; // eslint-disable-line no-bitwise
            a |= 0; // eslint-disable-line no-bitwise
            c |= 0; // eslint-disable-line no-bitwise
            if (a === 0 && b === 0) ;
            else if (a === 0) {
                t = -c / b;
                if (t > 0 && t < 1) bounds[i].push(this.calculateF(t, p0, p1, p2, p3, i));
            } else {
                b2ac = b * b - 4 * c * a;
                if (b2ac >= 0) {
                    t1 = (-b + bmSqrt(b2ac)) / (2 * a);
                    if (t1 > 0 && t1 < 1) bounds[i].push(this.calculateF(t1, p0, p1, p2, p3, i));
                    t2 = (-b - bmSqrt(b2ac)) / (2 * a);
                    if (t2 > 0 && t2 < 1) bounds[i].push(this.calculateF(t2, p0, p1, p2, p3, i));
                }
            }
        }
        this.shapeBoundingBox.left = bmMin.apply(null, bounds[0]);
        this.shapeBoundingBox.top = bmMin.apply(null, bounds[1]);
        this.shapeBoundingBox.right = bmMax.apply(null, bounds[0]);
        this.shapeBoundingBox.bottom = bmMax.apply(null, bounds[1]);
    };
    HShapeElement.prototype.calculateF = function(t, p0, p1, p2, p3, i) {
        return bmPow(1 - t, 3) * p0[i] + 3 * bmPow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * bmPow(t, 2) * p2[i] + bmPow(t, 3) * p3[i];
    };
    HShapeElement.prototype.calculateBoundingBox = function(itemsData, boundingBox) {
        var i;
        var len = itemsData.length;
        for(i = 0; i < len; i += 1){
            if (itemsData[i] && itemsData[i].sh) this.calculateShapeBoundingBox(itemsData[i], boundingBox);
            else if (itemsData[i] && itemsData[i].it) this.calculateBoundingBox(itemsData[i].it, boundingBox);
            else if (itemsData[i] && itemsData[i].style && itemsData[i].w) this.expandStrokeBoundingBox(itemsData[i].w, boundingBox);
        }
    };
    HShapeElement.prototype.expandStrokeBoundingBox = function(widthProperty, boundingBox) {
        var width = 0;
        if (widthProperty.keyframes) {
            for(var i = 0; i < widthProperty.keyframes.length; i += 1){
                var kfw = widthProperty.keyframes[i].s;
                if (kfw > width) width = kfw;
            }
            width *= widthProperty.mult;
        } else width = widthProperty.v * widthProperty.mult;
        boundingBox.x -= width;
        boundingBox.xMax += width;
        boundingBox.y -= width;
        boundingBox.yMax += width;
    };
    HShapeElement.prototype.currentBoxContains = function(box) {
        return this.currentBBox.x <= box.x && this.currentBBox.y <= box.y && this.currentBBox.width + this.currentBBox.x >= box.x + box.width && this.currentBBox.height + this.currentBBox.y >= box.y + box.height;
    };
    HShapeElement.prototype.renderInnerContent = function() {
        this._renderShapeFrame();
        if (!this.hidden && (this._isFirstFrame || this._mdf)) {
            var tempBoundingBox = this.tempBoundingBox;
            var max = 999999;
            tempBoundingBox.x = max;
            tempBoundingBox.xMax = -max;
            tempBoundingBox.y = max;
            tempBoundingBox.yMax = -max;
            this.calculateBoundingBox(this.itemsData, tempBoundingBox);
            tempBoundingBox.width = tempBoundingBox.xMax < tempBoundingBox.x ? 0 : tempBoundingBox.xMax - tempBoundingBox.x;
            tempBoundingBox.height = tempBoundingBox.yMax < tempBoundingBox.y ? 0 : tempBoundingBox.yMax - tempBoundingBox.y; // var tempBoundingBox = this.shapeCont.getBBox();
            if (this.currentBoxContains(tempBoundingBox)) return;
            var changed = false;
            if (this.currentBBox.w !== tempBoundingBox.width) {
                this.currentBBox.w = tempBoundingBox.width;
                this.shapeCont.setAttribute("width", tempBoundingBox.width);
                changed = true;
            }
            if (this.currentBBox.h !== tempBoundingBox.height) {
                this.currentBBox.h = tempBoundingBox.height;
                this.shapeCont.setAttribute("height", tempBoundingBox.height);
                changed = true;
            }
            if (changed || this.currentBBox.x !== tempBoundingBox.x || this.currentBBox.y !== tempBoundingBox.y) {
                this.currentBBox.w = tempBoundingBox.width;
                this.currentBBox.h = tempBoundingBox.height;
                this.currentBBox.x = tempBoundingBox.x;
                this.currentBBox.y = tempBoundingBox.y;
                this.shapeCont.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h);
                var shapeStyle = this.shapeCont.style;
                var shapeTransform = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
                shapeStyle.transform = shapeTransform;
                shapeStyle.webkitTransform = shapeTransform;
            }
        }
    };
    function HTextElement(data, globalData, comp) {
        this.textSpans = [];
        this.textPaths = [];
        this.currentBBox = {
            x: 999999,
            y: -999999,
            h: 0,
            w: 0
        };
        this.renderType = "svg";
        this.isMasked = false;
        this.initElement(data, globalData, comp);
    }
    extendPrototype([
        BaseElement,
        TransformElement,
        HBaseElement,
        HierarchyElement,
        FrameElement,
        RenderableDOMElement,
        ITextElement
    ], HTextElement);
    HTextElement.prototype.createContent = function() {
        this.isMasked = this.checkMasks();
        if (this.isMasked) {
            this.renderType = "svg";
            this.compW = this.comp.data.w;
            this.compH = this.comp.data.h;
            this.svgElement.setAttribute("width", this.compW);
            this.svgElement.setAttribute("height", this.compH);
            var g = createNS("g");
            this.maskedElement.appendChild(g);
            this.innerElem = g;
        } else {
            this.renderType = "html";
            this.innerElem = this.layerElement;
        }
        this.checkParenting();
    };
    HTextElement.prototype.buildNewText = function() {
        var documentData = this.textProperty.currentData;
        this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
        var innerElemStyle = this.innerElem.style;
        var textColor = documentData.fc ? this.buildColor(documentData.fc) : "rgba(0,0,0,0)";
        innerElemStyle.fill = textColor;
        innerElemStyle.color = textColor;
        if (documentData.sc) {
            innerElemStyle.stroke = this.buildColor(documentData.sc);
            innerElemStyle.strokeWidth = documentData.sw + "px";
        }
        var fontData = this.globalData.fontManager.getFontByName(documentData.f);
        if (!this.globalData.fontManager.chars) {
            innerElemStyle.fontSize = documentData.finalSize + "px";
            innerElemStyle.lineHeight = documentData.finalSize + "px";
            if (fontData.fClass) this.innerElem.className = fontData.fClass;
            else {
                innerElemStyle.fontFamily = fontData.fFamily;
                var fWeight = documentData.fWeight;
                var fStyle = documentData.fStyle;
                innerElemStyle.fontStyle = fStyle;
                innerElemStyle.fontWeight = fWeight;
            }
        }
        var i;
        var len;
        var letters = documentData.l;
        len = letters.length;
        var tSpan;
        var tParent;
        var tCont;
        var matrixHelper = this.mHelper;
        var shapes;
        var shapeStr = "";
        var cnt = 0;
        for(i = 0; i < len; i += 1){
            if (this.globalData.fontManager.chars) {
                if (!this.textPaths[cnt]) {
                    tSpan = createNS("path");
                    tSpan.setAttribute("stroke-linecap", lineCapEnum[1]);
                    tSpan.setAttribute("stroke-linejoin", lineJoinEnum[2]);
                    tSpan.setAttribute("stroke-miterlimit", "4");
                } else tSpan = this.textPaths[cnt];
                if (!this.isMasked) {
                    if (this.textSpans[cnt]) {
                        tParent = this.textSpans[cnt];
                        tCont = tParent.children[0];
                    } else {
                        tParent = createTag("div");
                        tParent.style.lineHeight = 0;
                        tCont = createNS("svg");
                        tCont.appendChild(tSpan);
                        styleDiv(tParent);
                    }
                }
            } else if (!this.isMasked) {
                if (this.textSpans[cnt]) {
                    tParent = this.textSpans[cnt];
                    tSpan = this.textPaths[cnt];
                } else {
                    tParent = createTag("span");
                    styleDiv(tParent);
                    tSpan = createTag("span");
                    styleDiv(tSpan);
                    tParent.appendChild(tSpan);
                }
            } else tSpan = this.textPaths[cnt] ? this.textPaths[cnt] : createNS("text");
             // tSpan.setAttribute('visibility', 'hidden');
            if (this.globalData.fontManager.chars) {
                var charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
                var shapeData;
                if (charData) shapeData = charData.data;
                else shapeData = null;
                matrixHelper.reset();
                if (shapeData && shapeData.shapes && shapeData.shapes.length) {
                    shapes = shapeData.shapes[0].it;
                    matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
                    shapeStr = this.createPathShape(matrixHelper, shapes);
                    tSpan.setAttribute("d", shapeStr);
                }
                if (!this.isMasked) {
                    this.innerElem.appendChild(tParent);
                    if (shapeData && shapeData.shapes) {
                        // document.body.appendChild is needed to get exact measure of shape
                        document.body.appendChild(tCont);
                        var boundingBox = tCont.getBBox();
                        tCont.setAttribute("width", boundingBox.width + 2);
                        tCont.setAttribute("height", boundingBox.height + 2);
                        tCont.setAttribute("viewBox", boundingBox.x - 1 + " " + (boundingBox.y - 1) + " " + (boundingBox.width + 2) + " " + (boundingBox.height + 2));
                        var tContStyle = tCont.style;
                        var tContTranslation = "translate(" + (boundingBox.x - 1) + "px," + (boundingBox.y - 1) + "px)";
                        tContStyle.transform = tContTranslation;
                        tContStyle.webkitTransform = tContTranslation;
                        letters[i].yOffset = boundingBox.y - 1;
                    } else {
                        tCont.setAttribute("width", 1);
                        tCont.setAttribute("height", 1);
                    }
                    tParent.appendChild(tCont);
                } else this.innerElem.appendChild(tSpan);
            } else {
                tSpan.textContent = letters[i].val;
                tSpan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
                if (!this.isMasked) {
                    this.innerElem.appendChild(tParent); //
                    var tStyle = tSpan.style;
                    var tSpanTranslation = "translate3d(0," + -documentData.finalSize / 1.2 + "px,0)";
                    tStyle.transform = tSpanTranslation;
                    tStyle.webkitTransform = tSpanTranslation;
                } else this.innerElem.appendChild(tSpan);
            } //
            if (!this.isMasked) this.textSpans[cnt] = tParent;
            else this.textSpans[cnt] = tSpan;
            this.textSpans[cnt].style.display = "block";
            this.textPaths[cnt] = tSpan;
            cnt += 1;
        }
        while(cnt < this.textSpans.length){
            this.textSpans[cnt].style.display = "none";
            cnt += 1;
        }
    };
    HTextElement.prototype.renderInnerContent = function() {
        var svgStyle;
        if (this.data.singleShape) {
            if (!this._isFirstFrame && !this.lettersChangedFlag) return;
            if (this.isMasked && this.finalTransform._matMdf) {
                // Todo Benchmark if using this is better than getBBox
                this.svgElement.setAttribute("viewBox", -this.finalTransform.mProp.p.v[0] + " " + -this.finalTransform.mProp.p.v[1] + " " + this.compW + " " + this.compH);
                svgStyle = this.svgElement.style;
                var translation = "translate(" + -this.finalTransform.mProp.p.v[0] + "px," + -this.finalTransform.mProp.p.v[1] + "px)";
                svgStyle.transform = translation;
                svgStyle.webkitTransform = translation;
            }
        }
        this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
        if (!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag) return;
        var i;
        var len;
        var count = 0;
        var renderedLetters = this.textAnimator.renderedLetters;
        var letters = this.textProperty.currentData.l;
        len = letters.length;
        var renderedLetter;
        var textSpan;
        var textPath;
        for(i = 0; i < len; i += 1)if (letters[i].n) count += 1;
        else {
            textSpan = this.textSpans[i];
            textPath = this.textPaths[i];
            renderedLetter = renderedLetters[count];
            count += 1;
            if (renderedLetter._mdf.m) {
                if (!this.isMasked) {
                    textSpan.style.webkitTransform = renderedLetter.m;
                    textSpan.style.transform = renderedLetter.m;
                } else textSpan.setAttribute("transform", renderedLetter.m);
            } /// /textSpan.setAttribute('opacity',renderedLetter.o);
            textSpan.style.opacity = renderedLetter.o;
            if (renderedLetter.sw && renderedLetter._mdf.sw) textPath.setAttribute("stroke-width", renderedLetter.sw);
            if (renderedLetter.sc && renderedLetter._mdf.sc) textPath.setAttribute("stroke", renderedLetter.sc);
            if (renderedLetter.fc && renderedLetter._mdf.fc) {
                textPath.setAttribute("fill", renderedLetter.fc);
                textPath.style.color = renderedLetter.fc;
            }
        }
        if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
            var boundingBox = this.innerElem.getBBox();
            if (this.currentBBox.w !== boundingBox.width) {
                this.currentBBox.w = boundingBox.width;
                this.svgElement.setAttribute("width", boundingBox.width);
            }
            if (this.currentBBox.h !== boundingBox.height) {
                this.currentBBox.h = boundingBox.height;
                this.svgElement.setAttribute("height", boundingBox.height);
            }
            var margin = 1;
            if (this.currentBBox.w !== boundingBox.width + margin * 2 || this.currentBBox.h !== boundingBox.height + margin * 2 || this.currentBBox.x !== boundingBox.x - margin || this.currentBBox.y !== boundingBox.y - margin) {
                this.currentBBox.w = boundingBox.width + margin * 2;
                this.currentBBox.h = boundingBox.height + margin * 2;
                this.currentBBox.x = boundingBox.x - margin;
                this.currentBBox.y = boundingBox.y - margin;
                this.svgElement.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h);
                svgStyle = this.svgElement.style;
                var svgTransform = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
                svgStyle.transform = svgTransform;
                svgStyle.webkitTransform = svgTransform;
            }
        }
    };
    function HCameraElement(data, globalData, comp) {
        this.initFrame();
        this.initBaseData(data, globalData, comp);
        this.initHierarchy();
        var getProp = PropertyFactory.getProp;
        this.pe = getProp(this, data.pe, 0, 0, this);
        if (data.ks.p.s) {
            this.px = getProp(this, data.ks.p.x, 1, 0, this);
            this.py = getProp(this, data.ks.p.y, 1, 0, this);
            this.pz = getProp(this, data.ks.p.z, 1, 0, this);
        } else this.p = getProp(this, data.ks.p, 1, 0, this);
        if (data.ks.a) this.a = getProp(this, data.ks.a, 1, 0, this);
        if (data.ks.or.k.length && data.ks.or.k[0].to) {
            var i;
            var len = data.ks.or.k.length;
            for(i = 0; i < len; i += 1){
                data.ks.or.k[i].to = null;
                data.ks.or.k[i].ti = null;
            }
        }
        this.or = getProp(this, data.ks.or, 1, degToRads, this);
        this.or.sh = true;
        this.rx = getProp(this, data.ks.rx, 0, degToRads, this);
        this.ry = getProp(this, data.ks.ry, 0, degToRads, this);
        this.rz = getProp(this, data.ks.rz, 0, degToRads, this);
        this.mat = new Matrix();
        this._prevMat = new Matrix();
        this._isFirstFrame = true; // TODO: find a better way to make the HCamera element to be compatible with the LayerInterface and TransformInterface.
        this.finalTransform = {
            mProp: this
        };
    }
    extendPrototype([
        BaseElement,
        FrameElement,
        HierarchyElement
    ], HCameraElement);
    HCameraElement.prototype.setup = function() {
        var i;
        var len = this.comp.threeDElements.length;
        var comp;
        var perspectiveStyle;
        var containerStyle;
        for(i = 0; i < len; i += 1){
            // [perspectiveElem,container]
            comp = this.comp.threeDElements[i];
            if (comp.type === "3d") {
                perspectiveStyle = comp.perspectiveElem.style;
                containerStyle = comp.container.style;
                var perspective = this.pe.v + "px";
                var origin = "0px 0px 0px";
                var matrix = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
                perspectiveStyle.perspective = perspective;
                perspectiveStyle.webkitPerspective = perspective;
                containerStyle.transformOrigin = origin;
                containerStyle.mozTransformOrigin = origin;
                containerStyle.webkitTransformOrigin = origin;
                perspectiveStyle.transform = matrix;
                perspectiveStyle.webkitTransform = matrix;
            }
        }
    };
    HCameraElement.prototype.createElements = function() {};
    HCameraElement.prototype.hide = function() {};
    HCameraElement.prototype.renderFrame = function() {
        var _mdf = this._isFirstFrame;
        var i;
        var len;
        if (this.hierarchy) {
            len = this.hierarchy.length;
            for(i = 0; i < len; i += 1)_mdf = this.hierarchy[i].finalTransform.mProp._mdf || _mdf;
        }
        if (_mdf || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {
            this.mat.reset();
            if (this.hierarchy) {
                len = this.hierarchy.length - 1;
                for(i = len; i >= 0; i -= 1){
                    var mTransf = this.hierarchy[i].finalTransform.mProp;
                    this.mat.translate(-mTransf.p.v[0], -mTransf.p.v[1], mTransf.p.v[2]);
                    this.mat.rotateX(-mTransf.or.v[0]).rotateY(-mTransf.or.v[1]).rotateZ(mTransf.or.v[2]);
                    this.mat.rotateX(-mTransf.rx.v).rotateY(-mTransf.ry.v).rotateZ(mTransf.rz.v);
                    this.mat.scale(1 / mTransf.s.v[0], 1 / mTransf.s.v[1], 1 / mTransf.s.v[2]);
                    this.mat.translate(mTransf.a.v[0], mTransf.a.v[1], mTransf.a.v[2]);
                }
            }
            if (this.p) this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]);
            else this.mat.translate(-this.px.v, -this.py.v, this.pz.v);
            if (this.a) {
                var diffVector;
                if (this.p) diffVector = [
                    this.p.v[0] - this.a.v[0],
                    this.p.v[1] - this.a.v[1],
                    this.p.v[2] - this.a.v[2]
                ];
                else diffVector = [
                    this.px.v - this.a.v[0],
                    this.py.v - this.a.v[1],
                    this.pz.v - this.a.v[2]
                ];
                var mag = Math.sqrt(Math.pow(diffVector[0], 2) + Math.pow(diffVector[1], 2) + Math.pow(diffVector[2], 2)); // var lookDir = getNormalizedPoint(getDiffVector(this.a.v,this.p.v));
                var lookDir = [
                    diffVector[0] / mag,
                    diffVector[1] / mag,
                    diffVector[2] / mag
                ];
                var lookLengthOnXZ = Math.sqrt(lookDir[2] * lookDir[2] + lookDir[0] * lookDir[0]);
                var mRotationX = Math.atan2(lookDir[1], lookLengthOnXZ);
                var mRotationY = Math.atan2(lookDir[0], -lookDir[2]);
                this.mat.rotateY(mRotationY).rotateX(-mRotationX);
            }
            this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v);
            this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]);
            this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0);
            this.mat.translate(0, 0, this.pe.v);
            var hasMatrixChanged = !this._prevMat.equals(this.mat);
            if ((hasMatrixChanged || this.pe._mdf) && this.comp.threeDElements) {
                len = this.comp.threeDElements.length;
                var comp;
                var perspectiveStyle;
                var containerStyle;
                for(i = 0; i < len; i += 1){
                    comp = this.comp.threeDElements[i];
                    if (comp.type === "3d") {
                        if (hasMatrixChanged) {
                            var matValue = this.mat.toCSS();
                            containerStyle = comp.container.style;
                            containerStyle.transform = matValue;
                            containerStyle.webkitTransform = matValue;
                        }
                        if (this.pe._mdf) {
                            perspectiveStyle = comp.perspectiveElem.style;
                            perspectiveStyle.perspective = this.pe.v + "px";
                            perspectiveStyle.webkitPerspective = this.pe.v + "px";
                        }
                    }
                }
                this.mat.clone(this._prevMat);
            }
        }
        this._isFirstFrame = false;
    };
    HCameraElement.prototype.prepareFrame = function(num) {
        this.prepareProperties(num, true);
    };
    HCameraElement.prototype.destroy = function() {};
    HCameraElement.prototype.getBaseElement = function() {
        return null;
    };
    function HImageElement(data, globalData, comp) {
        this.assetData = globalData.getAssetData(data.refId);
        this.initElement(data, globalData, comp);
    }
    extendPrototype([
        BaseElement,
        TransformElement,
        HBaseElement,
        HSolidElement,
        HierarchyElement,
        FrameElement,
        RenderableElement
    ], HImageElement);
    HImageElement.prototype.createContent = function() {
        var assetPath = this.globalData.getAssetsPath(this.assetData);
        var img = new Image();
        if (this.data.hasMask) {
            this.imageElem = createNS("image");
            this.imageElem.setAttribute("width", this.assetData.w + "px");
            this.imageElem.setAttribute("height", this.assetData.h + "px");
            this.imageElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", assetPath);
            this.layerElement.appendChild(this.imageElem);
            this.baseElement.setAttribute("width", this.assetData.w);
            this.baseElement.setAttribute("height", this.assetData.h);
        } else this.layerElement.appendChild(img);
        img.crossOrigin = "anonymous";
        img.src = assetPath;
        if (this.data.ln) this.baseElement.setAttribute("id", this.data.ln);
    };
    function HybridRendererBase(animationItem, config) {
        this.animationItem = animationItem;
        this.layers = null;
        this.renderedFrame = -1;
        this.renderConfig = {
            className: config && config.className || "",
            imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || "xMidYMid slice",
            hideOnTransparent: !(config && config.hideOnTransparent === false),
            filterSize: {
                width: config && config.filterSize && config.filterSize.width || "400%",
                height: config && config.filterSize && config.filterSize.height || "400%",
                x: config && config.filterSize && config.filterSize.x || "-100%",
                y: config && config.filterSize && config.filterSize.y || "-100%"
            }
        };
        this.globalData = {
            _mdf: false,
            frameNum: -1,
            renderConfig: this.renderConfig
        };
        this.pendingElements = [];
        this.elements = [];
        this.threeDElements = [];
        this.destroyed = false;
        this.camera = null;
        this.supports3d = true;
        this.rendererType = "html";
    }
    extendPrototype([
        BaseRenderer
    ], HybridRendererBase);
    HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem;
    HybridRendererBase.prototype.checkPendingElements = function() {
        while(this.pendingElements.length){
            var element = this.pendingElements.pop();
            element.checkParenting();
        }
    };
    HybridRendererBase.prototype.appendElementInPos = function(element, pos) {
        var newDOMElement = element.getBaseElement();
        if (!newDOMElement) return;
        var layer = this.layers[pos];
        if (!layer.ddd || !this.supports3d) {
            if (this.threeDElements) this.addTo3dContainer(newDOMElement, pos);
            else {
                var i = 0;
                var nextDOMElement;
                var nextLayer;
                var tmpDOMElement;
                while(i < pos){
                    if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement) {
                        nextLayer = this.elements[i];
                        tmpDOMElement = this.layers[i].ddd ? this.getThreeDContainerByPos(i) : nextLayer.getBaseElement();
                        nextDOMElement = tmpDOMElement || nextDOMElement;
                    }
                    i += 1;
                }
                if (nextDOMElement) {
                    if (!layer.ddd || !this.supports3d) this.layerElement.insertBefore(newDOMElement, nextDOMElement);
                } else if (!layer.ddd || !this.supports3d) this.layerElement.appendChild(newDOMElement);
            }
        } else this.addTo3dContainer(newDOMElement, pos);
    };
    HybridRendererBase.prototype.createShape = function(data) {
        if (!this.supports3d) return new SVGShapeElement(data, this.globalData, this);
        return new HShapeElement(data, this.globalData, this);
    };
    HybridRendererBase.prototype.createText = function(data) {
        if (!this.supports3d) return new SVGTextLottieElement(data, this.globalData, this);
        return new HTextElement(data, this.globalData, this);
    };
    HybridRendererBase.prototype.createCamera = function(data) {
        this.camera = new HCameraElement(data, this.globalData, this);
        return this.camera;
    };
    HybridRendererBase.prototype.createImage = function(data) {
        if (!this.supports3d) return new IImageElement(data, this.globalData, this);
        return new HImageElement(data, this.globalData, this);
    };
    HybridRendererBase.prototype.createSolid = function(data) {
        if (!this.supports3d) return new ISolidElement(data, this.globalData, this);
        return new HSolidElement(data, this.globalData, this);
    };
    HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;
    HybridRendererBase.prototype.getThreeDContainerByPos = function(pos) {
        var i = 0;
        var len = this.threeDElements.length;
        while(i < len){
            if (this.threeDElements[i].startPos <= pos && this.threeDElements[i].endPos >= pos) return this.threeDElements[i].perspectiveElem;
            i += 1;
        }
        return null;
    };
    HybridRendererBase.prototype.createThreeDContainer = function(pos, type) {
        var perspectiveElem = createTag("div");
        var style;
        var containerStyle;
        styleDiv(perspectiveElem);
        var container = createTag("div");
        styleDiv(container);
        if (type === "3d") {
            style = perspectiveElem.style;
            style.width = this.globalData.compSize.w + "px";
            style.height = this.globalData.compSize.h + "px";
            var center = "50% 50%";
            style.webkitTransformOrigin = center;
            style.mozTransformOrigin = center;
            style.transformOrigin = center;
            containerStyle = container.style;
            var matrix = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
            containerStyle.transform = matrix;
            containerStyle.webkitTransform = matrix;
        }
        perspectiveElem.appendChild(container); // this.resizerElem.appendChild(perspectiveElem);
        var threeDContainerData = {
            container: container,
            perspectiveElem: perspectiveElem,
            startPos: pos,
            endPos: pos,
            type: type
        };
        this.threeDElements.push(threeDContainerData);
        return threeDContainerData;
    };
    HybridRendererBase.prototype.build3dContainers = function() {
        var i;
        var len = this.layers.length;
        var lastThreeDContainerData;
        var currentContainer = "";
        for(i = 0; i < len; i += 1)if (this.layers[i].ddd && this.layers[i].ty !== 3) {
            if (currentContainer !== "3d") {
                currentContainer = "3d";
                lastThreeDContainerData = this.createThreeDContainer(i, "3d");
            }
            lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);
        } else {
            if (currentContainer !== "2d") {
                currentContainer = "2d";
                lastThreeDContainerData = this.createThreeDContainer(i, "2d");
            }
            lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);
        }
        len = this.threeDElements.length;
        for(i = len - 1; i >= 0; i -= 1)this.resizerElem.appendChild(this.threeDElements[i].perspectiveElem);
    };
    HybridRendererBase.prototype.addTo3dContainer = function(elem, pos) {
        var i = 0;
        var len = this.threeDElements.length;
        while(i < len){
            if (pos <= this.threeDElements[i].endPos) {
                var j = this.threeDElements[i].startPos;
                var nextElement;
                while(j < pos){
                    if (this.elements[j] && this.elements[j].getBaseElement) nextElement = this.elements[j].getBaseElement();
                    j += 1;
                }
                if (nextElement) this.threeDElements[i].container.insertBefore(elem, nextElement);
                else this.threeDElements[i].container.appendChild(elem);
                break;
            }
            i += 1;
        }
    };
    HybridRendererBase.prototype.configAnimation = function(animData) {
        var resizerElem = createTag("div");
        var wrapper = this.animationItem.wrapper;
        var style = resizerElem.style;
        style.width = animData.w + "px";
        style.height = animData.h + "px";
        this.resizerElem = resizerElem;
        styleDiv(resizerElem);
        style.transformStyle = "flat";
        style.mozTransformStyle = "flat";
        style.webkitTransformStyle = "flat";
        if (this.renderConfig.className) resizerElem.setAttribute("class", this.renderConfig.className);
        wrapper.appendChild(resizerElem);
        style.overflow = "hidden";
        var svg = createNS("svg");
        svg.setAttribute("width", "1");
        svg.setAttribute("height", "1");
        styleDiv(svg);
        this.resizerElem.appendChild(svg);
        var defs = createNS("defs");
        svg.appendChild(defs);
        this.data = animData; // Mask animation
        this.setupGlobalData(animData, svg);
        this.globalData.defs = defs;
        this.layers = animData.layers;
        this.layerElement = this.resizerElem;
        this.build3dContainers();
        this.updateContainerSize();
    };
    HybridRendererBase.prototype.destroy = function() {
        if (this.animationItem.wrapper) this.animationItem.wrapper.innerText = "";
        this.animationItem.container = null;
        this.globalData.defs = null;
        var i;
        var len = this.layers ? this.layers.length : 0;
        for(i = 0; i < len; i += 1)this.elements[i].destroy();
        this.elements.length = 0;
        this.destroyed = true;
        this.animationItem = null;
    };
    HybridRendererBase.prototype.updateContainerSize = function() {
        var elementWidth = this.animationItem.wrapper.offsetWidth;
        var elementHeight = this.animationItem.wrapper.offsetHeight;
        var elementRel = elementWidth / elementHeight;
        var animationRel = this.globalData.compSize.w / this.globalData.compSize.h;
        var sx;
        var sy;
        var tx;
        var ty;
        if (animationRel > elementRel) {
            sx = elementWidth / this.globalData.compSize.w;
            sy = elementWidth / this.globalData.compSize.w;
            tx = 0;
            ty = (elementHeight - this.globalData.compSize.h * (elementWidth / this.globalData.compSize.w)) / 2;
        } else {
            sx = elementHeight / this.globalData.compSize.h;
            sy = elementHeight / this.globalData.compSize.h;
            tx = (elementWidth - this.globalData.compSize.w * (elementHeight / this.globalData.compSize.h)) / 2;
            ty = 0;
        }
        var style = this.resizerElem.style;
        style.webkitTransform = "matrix3d(" + sx + ",0,0,0,0," + sy + ",0,0,0,0,1,0," + tx + "," + ty + ",0,1)";
        style.transform = style.webkitTransform;
    };
    HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame;
    HybridRendererBase.prototype.hide = function() {
        this.resizerElem.style.display = "none";
    };
    HybridRendererBase.prototype.show = function() {
        this.resizerElem.style.display = "block";
    };
    HybridRendererBase.prototype.initItems = function() {
        this.buildAllItems();
        if (this.camera) this.camera.setup();
        else {
            var cWidth = this.globalData.compSize.w;
            var cHeight = this.globalData.compSize.h;
            var i;
            var len = this.threeDElements.length;
            for(i = 0; i < len; i += 1){
                var style = this.threeDElements[i].perspectiveElem.style;
                style.webkitPerspective = Math.sqrt(Math.pow(cWidth, 2) + Math.pow(cHeight, 2)) + "px";
                style.perspective = style.webkitPerspective;
            }
        }
    };
    HybridRendererBase.prototype.searchExtraCompositions = function(assets) {
        var i;
        var len = assets.length;
        var floatingContainer = createTag("div");
        for(i = 0; i < len; i += 1)if (assets[i].xt) {
            var comp = this.createComp(assets[i], floatingContainer, this.globalData.comp, null);
            comp.initExpressions();
            this.globalData.projectInterface.registerComposition(comp);
        }
    };
    function HCompElement(data, globalData, comp) {
        this.layers = data.layers;
        this.supports3d = !data.hasMask;
        this.completeLayers = false;
        this.pendingElements = [];
        this.elements = this.layers ? createSizedArray(this.layers.length) : [];
        this.initElement(data, globalData, comp);
        this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
            _placeholder: true
        };
    }
    extendPrototype([
        HybridRendererBase,
        ICompElement,
        HBaseElement
    ], HCompElement);
    HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements;
    HCompElement.prototype.createContainerElements = function() {
        this._createBaseContainerElements(); // divElement.style.clip = 'rect(0px, '+this.data.w+'px, '+this.data.h+'px, 0px)';
        if (this.data.hasMask) {
            this.svgElement.setAttribute("width", this.data.w);
            this.svgElement.setAttribute("height", this.data.h);
            this.transformedElement = this.baseElement;
        } else this.transformedElement = this.layerElement;
    };
    HCompElement.prototype.addTo3dContainer = function(elem, pos) {
        var j = 0;
        var nextElement;
        while(j < pos){
            if (this.elements[j] && this.elements[j].getBaseElement) nextElement = this.elements[j].getBaseElement();
            j += 1;
        }
        if (nextElement) this.layerElement.insertBefore(elem, nextElement);
        else this.layerElement.appendChild(elem);
    };
    HCompElement.prototype.createComp = function(data) {
        if (!this.supports3d) return new SVGCompElement(data, this.globalData, this);
        return new HCompElement(data, this.globalData, this);
    };
    function HybridRenderer(animationItem, config) {
        this.animationItem = animationItem;
        this.layers = null;
        this.renderedFrame = -1;
        this.renderConfig = {
            className: config && config.className || "",
            imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || "xMidYMid slice",
            hideOnTransparent: !(config && config.hideOnTransparent === false),
            filterSize: {
                width: config && config.filterSize && config.filterSize.width || "400%",
                height: config && config.filterSize && config.filterSize.height || "400%",
                x: config && config.filterSize && config.filterSize.x || "-100%",
                y: config && config.filterSize && config.filterSize.y || "-100%"
            }
        };
        this.globalData = {
            _mdf: false,
            frameNum: -1,
            renderConfig: this.renderConfig
        };
        this.pendingElements = [];
        this.elements = [];
        this.threeDElements = [];
        this.destroyed = false;
        this.camera = null;
        this.supports3d = true;
        this.rendererType = "html";
    }
    extendPrototype([
        HybridRendererBase
    ], HybridRenderer);
    HybridRenderer.prototype.createComp = function(data) {
        if (!this.supports3d) return new SVGCompElement(data, this.globalData, this);
        return new HCompElement(data, this.globalData, this);
    };
    var Expressions = function() {
        var ob = {};
        ob.initExpressions = initExpressions;
        function initExpressions(animation) {
            var stackCount = 0;
            var registers = [];
            function pushExpression() {
                stackCount += 1;
            }
            function popExpression() {
                stackCount -= 1;
                if (stackCount === 0) releaseInstances();
            }
            function registerExpressionProperty(expression) {
                if (registers.indexOf(expression) === -1) registers.push(expression);
            }
            function releaseInstances() {
                var i;
                var len = registers.length;
                for(i = 0; i < len; i += 1)registers[i].release();
                registers.length = 0;
            }
            animation.renderer.compInterface = CompExpressionInterface(animation.renderer);
            animation.renderer.globalData.projectInterface.registerComposition(animation.renderer);
            animation.renderer.globalData.pushExpression = pushExpression;
            animation.renderer.globalData.popExpression = popExpression;
            animation.renderer.globalData.registerExpressionProperty = registerExpressionProperty;
        }
        return ob;
    }();
    function _typeof$1(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof$1 = function _typeof(obj) {
            return typeof obj;
        };
        else _typeof$1 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
        return _typeof$1(obj);
    }
    /* eslint-disable */ /*
   Copyright 2014 David Bau.

   Permission is hereby granted, free of charge, to any person obtaining
   a copy of this software and associated documentation files (the
   "Software"), to deal in the Software without restriction, including
   without limitation the rights to use, copy, modify, merge, publish,
   distribute, sublicense, and/or sell copies of the Software, and to
   permit persons to whom the Software is furnished to do so, subject to
   the following conditions:

   The above copyright notice and this permission notice shall be
   included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

   */ function seedRandom(pool, math) {
        //
        // The following constants are related to IEEE 754 limits.
        //
        var global = this, width = 256, // each RC4 output is 0 <= x < 256
        chunks = 6, // at least six RC4 outputs for each double
        digits = 52, // there are 52 significant digits in a double
        rngname = "random", // rngname: name for Math.random and Math.seedrandom
        startdenom = math.pow(width, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto; // node.js crypto module, initialized at the bottom.
        //
        // seedrandom()
        // This is the seedrandom function described above.
        //
        function seedrandom(seed, options, callback) {
            var key = [];
            options = options === true ? {
                entropy: true
            } : options || {}; // Flatten the seed string or build one from local entropy if needed.
            var shortseed = mixkey(flatten(options.entropy ? [
                seed,
                tostring(pool)
            ] : seed === null ? autoseed() : seed, 3), key); // Use the seed to initialize an ARC4 generator.
            var arc4 = new ARC4(key); // This function returns a random double in [0, 1) that contains
            // randomness in every bit of the mantissa of the IEEE 754 value.
            var prng = function prng() {
                var n = arc4.g(chunks), // Start with a numerator n < 2 ^ 48
                d = startdenom, //   and denominator d = 2 ^ 48.
                x = 0; //   and no 'extra last byte'.
                while(n < significance){
                    // Fill up all significant digits by
                    n = (n + x) * width; //   shifting numerator and
                    d *= width; //   denominator and generating a
                    x = arc4.g(1); //   new least-significant-byte.
                }
                while(n >= overflow){
                    // To avoid rounding up, before adding
                    n /= 2; //   last byte, shift everything
                    d /= 2; //   right using integer math until
                    x >>>= 1; //   we have exactly the desired bits.
                }
                return (n + x) / d; // Form the number within [0, 1).
            };
            prng.int32 = function() {
                return arc4.g(4) | 0;
            };
            prng.quick = function() {
                return arc4.g(4) / 0x100000000;
            };
            prng["double"] = prng; // Mix the randomness into accumulated entropy.
            mixkey(tostring(arc4.S), pool); // Calling convention: what to return as a function of prng, seed, is_math.
            return (options.pass || callback || function(prng, seed, is_math_call, state) {
                if (state) {
                    // Load the arc4 state from the given state if it has an S array.
                    if (state.S) copy(state, arc4);
                     // Only provide the .state method if requested via options.state.
                    prng.state = function() {
                        return copy(arc4, {});
                    };
                } // If called as a method of Math (Math.seedrandom()), mutate
                // Math.random because that is how seedrandom.js has worked since v1.0.
                if (is_math_call) {
                    math[rngname] = prng;
                    return seed;
                } else return prng;
            })(prng, shortseed, "global" in options ? options.global : this == math, options.state);
        }
        math["seed" + rngname] = seedrandom; //
        // ARC4
        //
        // An ARC4 implementation.  The constructor takes a key in the form of
        // an array of at most (width) integers that should be 0 <= x < (width).
        //
        // The g(count) method returns a pseudorandom integer that concatenates
        // the next (count) outputs from ARC4.  Its return value is a number x
        // that is in the range 0 <= x < (width ^ count).
        //
        function ARC4(key) {
            var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = []; // The empty key [] is treated as [0].
            if (!keylen) key = [
                keylen++
            ];
             // Set up S using the standard key scheduling algorithm.
            while(i < width)s[i] = i++;
            for(i = 0; i < width; i++){
                s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];
                s[j] = t;
            } // The "g" method returns the next (count) outputs as one number.
            me.g = function(count) {
                // Using instance members instead of closure state nearly doubles speed.
                var t, r = 0, i = me.i, j = me.j, s = me.S;
                while(count--){
                    t = s[i = mask & i + 1];
                    r = r * width + s[mask & (s[i] = s[j = mask & j + t]) + (s[j] = t)];
                }
                me.i = i;
                me.j = j;
                return r; // For robust unpredictability, the function call below automatically
            // discards an initial batch of values.  This is called RC4-drop[256].
            // See http://google.com/search?q=rsa+fluhrer+response&btnI
            };
        } //
        // copy()
        // Copies internal state of ARC4 to or from a plain object.
        //
        function copy(f, t) {
            t.i = f.i;
            t.j = f.j;
            t.S = f.S.slice();
            return t;
        } //
        // flatten()
        // Converts an object tree to nested arrays of strings.
        //
        function flatten(obj, depth) {
            var result = [], typ = _typeof$1(obj), prop;
            if (depth && typ == "object") {
                for(prop in obj)try {
                    result.push(flatten(obj[prop], depth - 1));
                } catch (e) {}
            }
            return result.length ? result : typ == "string" ? obj : obj + "\0";
        } //
        // mixkey()
        // Mixes a string seed into a key that is an array of integers, and
        // returns a shortened string seed that is equivalent to the result key.
        //
        function mixkey(seed, key) {
            var stringseed = seed + "", smear, j = 0;
            while(j < stringseed.length)key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
            return tostring(key);
        } //
        // autoseed()
        // Returns an object for autoseeding, using window.crypto and Node crypto
        // module if available.
        //
        function autoseed() {
            try {
                if (nodecrypto) return tostring(nodecrypto.randomBytes(width));
                var out = new Uint8Array(width);
                (global.crypto || global.msCrypto).getRandomValues(out);
                return tostring(out);
            } catch (e) {
                var browser = global.navigator, plugins = browser && browser.plugins;
                return [
                    +new Date(),
                    global,
                    plugins,
                    global.screen,
                    tostring(pool)
                ];
            }
        } //
        // tostring()
        // Converts an array of charcodes to a string
        //
        function tostring(a) {
            return String.fromCharCode.apply(0, a);
        } //
        // When seedrandom.js is loaded, we immediately mix a few bits
        // from the built-in RNG into the entropy pool.  Because we do
        // not want to interfere with deterministic PRNG state later,
        // seedrandom will not call math.random on its own again after
        // initialization.
        //
        mixkey(math.random(), pool); //
    // Nodejs and AMD support: export the implementation as a module using
    // either convention.
    //
    // End anonymous scope, and pass initial values.
    }
    function initialize$2(BMMath) {
        seedRandom([], BMMath);
    }
    var propTypes = {
        SHAPE: "shape"
    };
    function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
            return typeof obj;
        };
        else _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
        return _typeof(obj);
    }
    var ExpressionManager = function() {
        "use strict";
        var ob = {};
        var Math = BMMath;
        var window = null;
        var document = null;
        var XMLHttpRequest = null;
        var fetch = null;
        var frames = null;
        initialize$2(BMMath);
        function $bm_isInstanceOfArray(arr) {
            return arr.constructor === Array || arr.constructor === Float32Array;
        }
        function isNumerable(tOfV, v) {
            return tOfV === "number" || tOfV === "boolean" || tOfV === "string" || v instanceof Number;
        }
        function $bm_neg(a) {
            var tOfA = _typeof(a);
            if (tOfA === "number" || tOfA === "boolean" || a instanceof Number) return -a;
            if ($bm_isInstanceOfArray(a)) {
                var i;
                var lenA = a.length;
                var retArr = [];
                for(i = 0; i < lenA; i += 1)retArr[i] = -a[i];
                return retArr;
            }
            if (a.propType) return a.v;
            return -a;
        }
        var easeInBez = BezierFactory.getBezierEasing(0.333, 0, 0.833, 0.833, "easeIn").get;
        var easeOutBez = BezierFactory.getBezierEasing(0.167, 0.167, 0.667, 1, "easeOut").get;
        var easeInOutBez = BezierFactory.getBezierEasing(0.33, 0, 0.667, 1, "easeInOut").get;
        function sum(a, b) {
            var tOfA = _typeof(a);
            var tOfB = _typeof(b);
            if (tOfA === "string" || tOfB === "string") return a + b;
            if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) return a + b;
            if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
                a = a.slice(0);
                a[0] += b;
                return a;
            }
            if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
                b = b.slice(0);
                b[0] = a + b[0];
                return b;
            }
            if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
                var i = 0;
                var lenA = a.length;
                var lenB = b.length;
                var retArr = [];
                while(i < lenA || i < lenB){
                    if ((typeof a[i] === "number" || a[i] instanceof Number) && (typeof b[i] === "number" || b[i] instanceof Number)) retArr[i] = a[i] + b[i];
                    else retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];
                    i += 1;
                }
                return retArr;
            }
            return 0;
        }
        var add = sum;
        function sub(a, b) {
            var tOfA = _typeof(a);
            var tOfB = _typeof(b);
            if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
                if (tOfA === "string") a = parseInt(a, 10);
                if (tOfB === "string") b = parseInt(b, 10);
                return a - b;
            }
            if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
                a = a.slice(0);
                a[0] -= b;
                return a;
            }
            if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
                b = b.slice(0);
                b[0] = a - b[0];
                return b;
            }
            if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
                var i = 0;
                var lenA = a.length;
                var lenB = b.length;
                var retArr = [];
                while(i < lenA || i < lenB){
                    if ((typeof a[i] === "number" || a[i] instanceof Number) && (typeof b[i] === "number" || b[i] instanceof Number)) retArr[i] = a[i] - b[i];
                    else retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];
                    i += 1;
                }
                return retArr;
            }
            return 0;
        }
        function mul(a, b) {
            var tOfA = _typeof(a);
            var tOfB = _typeof(b);
            var arr;
            if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) return a * b;
            var i;
            var len;
            if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
                len = a.length;
                arr = createTypedArray("float32", len);
                for(i = 0; i < len; i += 1)arr[i] = a[i] * b;
                return arr;
            }
            if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
                len = b.length;
                arr = createTypedArray("float32", len);
                for(i = 0; i < len; i += 1)arr[i] = a * b[i];
                return arr;
            }
            return 0;
        }
        function div(a, b) {
            var tOfA = _typeof(a);
            var tOfB = _typeof(b);
            var arr;
            if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) return a / b;
            var i;
            var len;
            if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
                len = a.length;
                arr = createTypedArray("float32", len);
                for(i = 0; i < len; i += 1)arr[i] = a[i] / b;
                return arr;
            }
            if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
                len = b.length;
                arr = createTypedArray("float32", len);
                for(i = 0; i < len; i += 1)arr[i] = a / b[i];
                return arr;
            }
            return 0;
        }
        function mod(a, b) {
            if (typeof a === "string") a = parseInt(a, 10);
            if (typeof b === "string") b = parseInt(b, 10);
            return a % b;
        }
        var $bm_sum = sum;
        var $bm_sub = sub;
        var $bm_mul = mul;
        var $bm_div = div;
        var $bm_mod = mod;
        function clamp(num, min, max) {
            if (min > max) {
                var mm = max;
                max = min;
                min = mm;
            }
            return Math.min(Math.max(num, min), max);
        }
        function radiansToDegrees(val) {
            return val / degToRads;
        }
        var radians_to_degrees = radiansToDegrees;
        function degreesToRadians(val) {
            return val * degToRads;
        }
        var degrees_to_radians = radiansToDegrees;
        var helperLengthArray = [
            0,
            0,
            0,
            0,
            0,
            0
        ];
        function length(arr1, arr2) {
            if (typeof arr1 === "number" || arr1 instanceof Number) {
                arr2 = arr2 || 0;
                return Math.abs(arr1 - arr2);
            }
            if (!arr2) arr2 = helperLengthArray;
            var i;
            var len = Math.min(arr1.length, arr2.length);
            var addedLength = 0;
            for(i = 0; i < len; i += 1)addedLength += Math.pow(arr2[i] - arr1[i], 2);
            return Math.sqrt(addedLength);
        }
        function normalize(vec) {
            return div(vec, length(vec));
        }
        function rgbToHsl(val) {
            var r = val[0];
            var g = val[1];
            var b = val[2];
            var max = Math.max(r, g, b);
            var min = Math.min(r, g, b);
            var h;
            var s;
            var l = (max + min) / 2;
            if (max === min) {
                h = 0; // achromatic
                s = 0; // achromatic
            } else {
                var d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch(max){
                    case r:
                        h = (g - b) / d + (g < b ? 6 : 0);
                        break;
                    case g:
                        h = (b - r) / d + 2;
                        break;
                    case b:
                        h = (r - g) / d + 4;
                        break;
                    default:
                        break;
                }
                h /= 6;
            }
            return [
                h,
                s,
                l,
                val[3]
            ];
        }
        function hue2rgb(p, q, t) {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 0.5) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
        }
        function hslToRgb(val) {
            var h = val[0];
            var s = val[1];
            var l = val[2];
            var r;
            var g;
            var b;
            if (s === 0) {
                r = l; // achromatic
                b = l; // achromatic
                g = l; // achromatic
            } else {
                var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                var p = 2 * l - q;
                r = hue2rgb(p, q, h + 1 / 3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1 / 3);
            }
            return [
                r,
                g,
                b,
                val[3]
            ];
        }
        function linear(t, tMin, tMax, value1, value2) {
            if (value1 === undefined || value2 === undefined) {
                value1 = tMin;
                value2 = tMax;
                tMin = 0;
                tMax = 1;
            }
            if (tMax < tMin) {
                var _tMin = tMax;
                tMax = tMin;
                tMin = _tMin;
            }
            if (t <= tMin) return value1;
            if (t >= tMax) return value2;
            var perc = tMax === tMin ? 0 : (t - tMin) / (tMax - tMin);
            if (!value1.length) return value1 + (value2 - value1) * perc;
            var i;
            var len = value1.length;
            var arr = createTypedArray("float32", len);
            for(i = 0; i < len; i += 1)arr[i] = value1[i] + (value2[i] - value1[i]) * perc;
            return arr;
        }
        function random(min, max) {
            if (max === undefined) {
                if (min === undefined) {
                    min = 0;
                    max = 1;
                } else {
                    max = min;
                    min = undefined;
                }
            }
            if (max.length) {
                var i;
                var len = max.length;
                if (!min) min = createTypedArray("float32", len);
                var arr = createTypedArray("float32", len);
                var rnd = BMMath.random();
                for(i = 0; i < len; i += 1)arr[i] = min[i] + rnd * (max[i] - min[i]);
                return arr;
            }
            if (min === undefined) min = 0;
            var rndm = BMMath.random();
            return min + rndm * (max - min);
        }
        function createPath(points, inTangents, outTangents, closed) {
            var i;
            var len = points.length;
            var path = shapePool.newElement();
            path.setPathData(!!closed, len);
            var arrPlaceholder = [
                0,
                0
            ];
            var inVertexPoint;
            var outVertexPoint;
            for(i = 0; i < len; i += 1){
                inVertexPoint = inTangents && inTangents[i] ? inTangents[i] : arrPlaceholder;
                outVertexPoint = outTangents && outTangents[i] ? outTangents[i] : arrPlaceholder;
                path.setTripleAt(points[i][0], points[i][1], outVertexPoint[0] + points[i][0], outVertexPoint[1] + points[i][1], inVertexPoint[0] + points[i][0], inVertexPoint[1] + points[i][1], i, true);
            }
            return path;
        }
        function initiateExpression(elem, data, property) {
            var val = data.x;
            var needsVelocity = /velocity(?![\w\d])/.test(val);
            var _needsRandom = val.indexOf("random") !== -1;
            var elemType = elem.data.ty;
            var transform;
            var $bm_transform;
            var content;
            var effect;
            var thisProperty = property;
            thisProperty.valueAtTime = thisProperty.getValueAtTime;
            Object.defineProperty(thisProperty, "value", {
                get: function get() {
                    return thisProperty.v;
                }
            });
            elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate;
            elem.comp.displayStartTime = 0;
            var inPoint = elem.data.ip / elem.comp.globalData.frameRate;
            var outPoint = elem.data.op / elem.comp.globalData.frameRate;
            var width = elem.data.sw ? elem.data.sw : 0;
            var height = elem.data.sh ? elem.data.sh : 0;
            var name = elem.data.nm;
            var loopIn;
            var loop_in;
            var loopOut;
            var loop_out;
            var smooth;
            var toWorld;
            var fromWorld;
            var fromComp;
            var toComp;
            var fromCompToSurface;
            var position;
            var rotation;
            var anchorPoint;
            var scale;
            var thisLayer;
            var thisComp;
            var mask;
            var valueAtTime;
            var velocityAtTime;
            var scoped_bm_rt; // val = val.replace(/(\\?"|')((http)(s)?(:\/))?\/.*?(\\?"|')/g, "\"\""); // deter potential network calls
            var expression_function = eval("[function _expression_function(){" + val + ";scoped_bm_rt=$bm_rt}]")[0]; // eslint-disable-line no-eval
            var numKeys = property.kf ? data.k.length : 0;
            var active = !this.data || this.data.hd !== true;
            var wiggle = (function wiggle(freq, amp) {
                var iWiggle;
                var j;
                var lenWiggle = this.pv.length ? this.pv.length : 1;
                var addedAmps = createTypedArray("float32", lenWiggle);
                freq = 5;
                var iterations = Math.floor(time * freq);
                iWiggle = 0;
                j = 0;
                while(iWiggle < iterations){
                    // var rnd = BMMath.random();
                    for(j = 0; j < lenWiggle; j += 1)addedAmps[j] += -amp + amp * 2 * BMMath.random(); // addedAmps[j] += -amp + amp*2*rnd;
                    iWiggle += 1;
                } // var rnd2 = BMMath.random();
                var periods = time * freq;
                var perc = periods - Math.floor(periods);
                var arr = createTypedArray("float32", lenWiggle);
                if (lenWiggle > 1) {
                    for(j = 0; j < lenWiggle; j += 1)arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp * 2 * BMMath.random()) * perc; // arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp*2*rnd)*perc;
                    return arr;
                }
                return this.pv + addedAmps[0] + (-amp + amp * 2 * BMMath.random()) * perc;
            }).bind(this);
            if (thisProperty.loopIn) {
                loopIn = thisProperty.loopIn.bind(thisProperty);
                loop_in = loopIn;
            }
            if (thisProperty.loopOut) {
                loopOut = thisProperty.loopOut.bind(thisProperty);
                loop_out = loopOut;
            }
            if (thisProperty.smooth) smooth = thisProperty.smooth.bind(thisProperty);
            function loopInDuration(type, duration) {
                return loopIn(type, duration, true);
            }
            function loopOutDuration(type, duration) {
                return loopOut(type, duration, true);
            }
            if (this.getValueAtTime) valueAtTime = this.getValueAtTime.bind(this);
            if (this.getVelocityAtTime) velocityAtTime = this.getVelocityAtTime.bind(this);
            var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);
            function lookAt(elem1, elem2) {
                var fVec = [
                    elem2[0] - elem1[0],
                    elem2[1] - elem1[1],
                    elem2[2] - elem1[2]
                ];
                var pitch = Math.atan2(fVec[0], Math.sqrt(fVec[1] * fVec[1] + fVec[2] * fVec[2])) / degToRads;
                var yaw = -Math.atan2(fVec[1], fVec[2]) / degToRads;
                return [
                    yaw,
                    pitch,
                    0
                ];
            }
            function easeOut(t, tMin, tMax, val1, val2) {
                return applyEase(easeOutBez, t, tMin, tMax, val1, val2);
            }
            function easeIn(t, tMin, tMax, val1, val2) {
                return applyEase(easeInBez, t, tMin, tMax, val1, val2);
            }
            function ease(t, tMin, tMax, val1, val2) {
                return applyEase(easeInOutBez, t, tMin, tMax, val1, val2);
            }
            function applyEase(fn, t, tMin, tMax, val1, val2) {
                if (val1 === undefined) {
                    val1 = tMin;
                    val2 = tMax;
                } else t = (t - tMin) / (tMax - tMin);
                if (t > 1) t = 1;
                else if (t < 0) t = 0;
                var mult = fn(t);
                if ($bm_isInstanceOfArray(val1)) {
                    var iKey;
                    var lenKey = val1.length;
                    var arr = createTypedArray("float32", lenKey);
                    for(iKey = 0; iKey < lenKey; iKey += 1)arr[iKey] = (val2[iKey] - val1[iKey]) * mult + val1[iKey];
                    return arr;
                }
                return (val2 - val1) * mult + val1;
            }
            function nearestKey(time) {
                var iKey;
                var lenKey = data.k.length;
                var index;
                var keyTime;
                if (!data.k.length || typeof data.k[0] === "number") {
                    index = 0;
                    keyTime = 0;
                } else {
                    index = -1;
                    time *= elem.comp.globalData.frameRate;
                    if (time < data.k[0].t) {
                        index = 1;
                        keyTime = data.k[0].t;
                    } else {
                        for(iKey = 0; iKey < lenKey - 1; iKey += 1){
                            if (time === data.k[iKey].t) {
                                index = iKey + 1;
                                keyTime = data.k[iKey].t;
                                break;
                            } else if (time > data.k[iKey].t && time < data.k[iKey + 1].t) {
                                if (time - data.k[iKey].t > data.k[iKey + 1].t - time) {
                                    index = iKey + 2;
                                    keyTime = data.k[iKey + 1].t;
                                } else {
                                    index = iKey + 1;
                                    keyTime = data.k[iKey].t;
                                }
                                break;
                            }
                        }
                        if (index === -1) {
                            index = iKey + 1;
                            keyTime = data.k[iKey].t;
                        }
                    }
                }
                var obKey = {};
                obKey.index = index;
                obKey.time = keyTime / elem.comp.globalData.frameRate;
                return obKey;
            }
            function key(ind) {
                var obKey;
                var iKey;
                var lenKey;
                if (!data.k.length || typeof data.k[0] === "number") throw new Error("The property has no keyframe at index " + ind);
                ind -= 1;
                obKey = {
                    time: data.k[ind].t / elem.comp.globalData.frameRate,
                    value: []
                };
                var arr = Object.prototype.hasOwnProperty.call(data.k[ind], "s") ? data.k[ind].s : data.k[ind - 1].e;
                lenKey = arr.length;
                for(iKey = 0; iKey < lenKey; iKey += 1){
                    obKey[iKey] = arr[iKey];
                    obKey.value[iKey] = arr[iKey];
                }
                return obKey;
            }
            function framesToTime(fr, fps) {
                if (!fps) fps = elem.comp.globalData.frameRate;
                return fr / fps;
            }
            function timeToFrames(t, fps) {
                if (!t && t !== 0) t = time;
                if (!fps) fps = elem.comp.globalData.frameRate;
                return t * fps;
            }
            function seedRandom(seed) {
                BMMath.seedrandom(randSeed + seed);
            }
            function sourceRectAtTime() {
                return elem.sourceRectAtTime();
            }
            function substring(init, end) {
                if (typeof value === "string") {
                    if (end === undefined) return value.substring(init);
                    return value.substring(init, end);
                }
                return "";
            }
            function substr(init, end) {
                if (typeof value === "string") {
                    if (end === undefined) return value.substr(init);
                    return value.substr(init, end);
                }
                return "";
            }
            function posterizeTime(framesPerSecond) {
                time = framesPerSecond === 0 ? 0 : Math.floor(time * framesPerSecond) / framesPerSecond;
                value = valueAtTime(time);
            }
            var time;
            var velocity;
            var value;
            var text;
            var textIndex;
            var textTotal;
            var selectorValue;
            var index = elem.data.ind;
            var hasParent = !!(elem.hierarchy && elem.hierarchy.length);
            var parent;
            var randSeed = Math.floor(Math.random() * 1000000);
            var globalData = elem.globalData;
            function executeExpression(_value) {
                // globalData.pushExpression();
                value = _value;
                if (this.frameExpressionId === elem.globalData.frameId && this.propType !== "textSelector") return value;
                if (this.propType === "textSelector") {
                    textIndex = this.textIndex;
                    textTotal = this.textTotal;
                    selectorValue = this.selectorValue;
                }
                if (!thisLayer) {
                    text = elem.layerInterface.text;
                    thisLayer = elem.layerInterface;
                    thisComp = elem.comp.compInterface;
                    toWorld = thisLayer.toWorld.bind(thisLayer);
                    fromWorld = thisLayer.fromWorld.bind(thisLayer);
                    fromComp = thisLayer.fromComp.bind(thisLayer);
                    toComp = thisLayer.toComp.bind(thisLayer);
                    mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null;
                    fromCompToSurface = fromComp;
                }
                if (!transform) {
                    transform = elem.layerInterface("ADBE Transform Group");
                    $bm_transform = transform;
                    if (transform) anchorPoint = transform.anchorPoint;
                }
                if (elemType === 4 && !content) content = thisLayer("ADBE Root Vectors Group");
                if (!effect) effect = thisLayer(4);
                hasParent = !!(elem.hierarchy && elem.hierarchy.length);
                if (hasParent && !parent) parent = elem.hierarchy[0].layerInterface;
                time = this.comp.renderedFrame / this.comp.globalData.frameRate;
                if (_needsRandom) seedRandom(randSeed + time);
                if (needsVelocity) velocity = velocityAtTime(time);
                expression_function();
                this.frameExpressionId = elem.globalData.frameId; // TODO: Check if it's possible to return on ShapeInterface the .v value
                // Changed this to a ternary operation because Rollup failed compiling it correctly
                scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt;
                return scoped_bm_rt;
            } // Bundlers will see these as dead code and unless we reference them
            executeExpression.__preventDeadCodeRemoval = [
                $bm_transform,
                anchorPoint,
                time,
                velocity,
                inPoint,
                outPoint,
                width,
                height,
                name,
                loop_in,
                loop_out,
                smooth,
                toComp,
                fromCompToSurface,
                toWorld,
                fromWorld,
                mask,
                position,
                rotation,
                scale,
                thisComp,
                numKeys,
                active,
                wiggle,
                loopInDuration,
                loopOutDuration,
                comp,
                lookAt,
                easeOut,
                easeIn,
                ease,
                nearestKey,
                key,
                text,
                textIndex,
                textTotal,
                selectorValue,
                framesToTime,
                timeToFrames,
                sourceRectAtTime,
                substring,
                substr,
                posterizeTime,
                index,
                globalData
            ];
            return executeExpression;
        }
        ob.initiateExpression = initiateExpression;
        ob.__preventDeadCodeRemoval = [
            window,
            document,
            XMLHttpRequest,
            fetch,
            frames,
            $bm_neg,
            add,
            $bm_sum,
            $bm_sub,
            $bm_mul,
            $bm_div,
            $bm_mod,
            clamp,
            radians_to_degrees,
            degreesToRadians,
            degrees_to_radians,
            normalize,
            rgbToHsl,
            hslToRgb,
            linear,
            random,
            createPath
        ];
        return ob;
    }();
    var expressionHelpers = function() {
        function searchExpressions(elem, data, prop) {
            if (data.x) {
                prop.k = true;
                prop.x = true;
                prop.initiateExpression = ExpressionManager.initiateExpression;
                prop.effectsSequence.push(prop.initiateExpression(elem, data, prop).bind(prop));
            }
        }
        function getValueAtTime(frameNum) {
            frameNum *= this.elem.globalData.frameRate;
            frameNum -= this.offsetTime;
            if (frameNum !== this._cachingAtTime.lastFrame) {
                this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < frameNum ? this._cachingAtTime.lastIndex : 0;
                this._cachingAtTime.value = this.interpolateValue(frameNum, this._cachingAtTime);
                this._cachingAtTime.lastFrame = frameNum;
            }
            return this._cachingAtTime.value;
        }
        function getSpeedAtTime(frameNum) {
            var delta = -0.01;
            var v1 = this.getValueAtTime(frameNum);
            var v2 = this.getValueAtTime(frameNum + delta);
            var speed = 0;
            if (v1.length) {
                var i;
                for(i = 0; i < v1.length; i += 1)speed += Math.pow(v2[i] - v1[i], 2);
                speed = Math.sqrt(speed) * 100;
            } else speed = 0;
            return speed;
        }
        function getVelocityAtTime(frameNum) {
            if (this.vel !== undefined) return this.vel;
            var delta = -0.001; // frameNum += this.elem.data.st;
            var v1 = this.getValueAtTime(frameNum);
            var v2 = this.getValueAtTime(frameNum + delta);
            var velocity;
            if (v1.length) {
                velocity = createTypedArray("float32", v1.length);
                var i;
                for(i = 0; i < v1.length; i += 1)// removing frameRate
                // if needed, don't add it here
                // velocity[i] = this.elem.globalData.frameRate*((v2[i] - v1[i])/delta);
                velocity[i] = (v2[i] - v1[i]) / delta;
            } else velocity = (v2 - v1) / delta;
            return velocity;
        }
        function getStaticValueAtTime() {
            return this.pv;
        }
        function setGroupProperty(propertyGroup) {
            this.propertyGroup = propertyGroup;
        }
        return {
            searchExpressions: searchExpressions,
            getSpeedAtTime: getSpeedAtTime,
            getVelocityAtTime: getVelocityAtTime,
            getValueAtTime: getValueAtTime,
            getStaticValueAtTime: getStaticValueAtTime,
            setGroupProperty: setGroupProperty
        };
    }();
    function addPropertyDecorator() {
        function loopOut(type, duration, durationFlag) {
            if (!this.k || !this.keyframes) return this.pv;
            type = type ? type.toLowerCase() : "";
            var currentFrame = this.comp.renderedFrame;
            var keyframes = this.keyframes;
            var lastKeyFrame = keyframes[keyframes.length - 1].t;
            if (currentFrame <= lastKeyFrame) return this.pv;
            var cycleDuration;
            var firstKeyFrame;
            if (!durationFlag) {
                if (!duration || duration > keyframes.length - 1) duration = keyframes.length - 1;
                firstKeyFrame = keyframes[keyframes.length - 1 - duration].t;
                cycleDuration = lastKeyFrame - firstKeyFrame;
            } else {
                if (!duration) cycleDuration = Math.max(0, lastKeyFrame - this.elem.data.ip);
                else cycleDuration = Math.abs(lastKeyFrame - this.elem.comp.globalData.frameRate * duration);
                firstKeyFrame = lastKeyFrame - cycleDuration;
            }
            var i;
            var len;
            var ret;
            if (type === "pingpong") {
                var iterations = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
                if (iterations % 2 !== 0) return this.getValueAtTime((cycleDuration - (currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line
            } else if (type === "offset") {
                var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
                var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
                var current = this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line
                var repeats = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
                if (this.pv.length) {
                    ret = new Array(initV.length);
                    len = ret.length;
                    for(i = 0; i < len; i += 1)ret[i] = (endV[i] - initV[i]) * repeats + current[i];
                    return ret;
                }
                return (endV - initV) * repeats + current;
            } else if (type === "continue") {
                var lastValue = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
                var nextLastValue = this.getValueAtTime((lastKeyFrame - 0.001) / this.comp.globalData.frameRate, 0);
                if (this.pv.length) {
                    ret = new Array(lastValue.length);
                    len = ret.length;
                    for(i = 0; i < len; i += 1)ret[i] = lastValue[i] + (lastValue[i] - nextLastValue[i]) * ((currentFrame - lastKeyFrame) / this.comp.globalData.frameRate) / 0.0005; // eslint-disable-line
                    return ret;
                }
                return lastValue + (lastValue - nextLastValue) * ((currentFrame - lastKeyFrame) / 0.001);
            }
            return this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line
        }
        function loopIn(type, duration, durationFlag) {
            if (!this.k) return this.pv;
            type = type ? type.toLowerCase() : "";
            var currentFrame = this.comp.renderedFrame;
            var keyframes = this.keyframes;
            var firstKeyFrame = keyframes[0].t;
            if (currentFrame >= firstKeyFrame) return this.pv;
            var cycleDuration;
            var lastKeyFrame;
            if (!durationFlag) {
                if (!duration || duration > keyframes.length - 1) duration = keyframes.length - 1;
                lastKeyFrame = keyframes[duration].t;
                cycleDuration = lastKeyFrame - firstKeyFrame;
            } else {
                if (!duration) cycleDuration = Math.max(0, this.elem.data.op - firstKeyFrame);
                else cycleDuration = Math.abs(this.elem.comp.globalData.frameRate * duration);
                lastKeyFrame = firstKeyFrame + cycleDuration;
            }
            var i;
            var len;
            var ret;
            if (type === "pingpong") {
                var iterations = Math.floor((firstKeyFrame - currentFrame) / cycleDuration);
                if (iterations % 2 === 0) return this.getValueAtTime(((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line
            } else if (type === "offset") {
                var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
                var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
                var current = this.getValueAtTime((cycleDuration - (firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
                var repeats = Math.floor((firstKeyFrame - currentFrame) / cycleDuration) + 1;
                if (this.pv.length) {
                    ret = new Array(initV.length);
                    len = ret.length;
                    for(i = 0; i < len; i += 1)ret[i] = current[i] - (endV[i] - initV[i]) * repeats;
                    return ret;
                }
                return current - (endV - initV) * repeats;
            } else if (type === "continue") {
                var firstValue = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
                var nextFirstValue = this.getValueAtTime((firstKeyFrame + 0.001) / this.comp.globalData.frameRate, 0);
                if (this.pv.length) {
                    ret = new Array(firstValue.length);
                    len = ret.length;
                    for(i = 0; i < len; i += 1)ret[i] = firstValue[i] + (firstValue[i] - nextFirstValue[i]) * (firstKeyFrame - currentFrame) / 0.001;
                    return ret;
                }
                return firstValue + (firstValue - nextFirstValue) * (firstKeyFrame - currentFrame) / 0.001;
            }
            return this.getValueAtTime((cycleDuration - ((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0); // eslint-disable-line
        }
        function smooth(width, samples) {
            if (!this.k) return this.pv;
            width = (width || 0.4) * 0.5;
            samples = Math.floor(samples || 5);
            if (samples <= 1) return this.pv;
            var currentTime = this.comp.renderedFrame / this.comp.globalData.frameRate;
            var initFrame = currentTime - width;
            var endFrame = currentTime + width;
            var sampleFrequency = samples > 1 ? (endFrame - initFrame) / (samples - 1) : 1;
            var i = 0;
            var j = 0;
            var value;
            if (this.pv.length) value = createTypedArray("float32", this.pv.length);
            else value = 0;
            var sampleValue;
            while(i < samples){
                sampleValue = this.getValueAtTime(initFrame + i * sampleFrequency);
                if (this.pv.length) for(j = 0; j < this.pv.length; j += 1)value[j] += sampleValue[j];
                else value += sampleValue;
                i += 1;
            }
            if (this.pv.length) for(j = 0; j < this.pv.length; j += 1)value[j] /= samples;
            else value /= samples;
            return value;
        }
        function getTransformValueAtTime(time) {
            if (!this._transformCachingAtTime) this._transformCachingAtTime = {
                v: new Matrix()
            };
             /// /
            var matrix = this._transformCachingAtTime.v;
            matrix.cloneFromProps(this.pre.props);
            if (this.appliedTransformations < 1) {
                var anchor = this.a.getValueAtTime(time);
                matrix.translate(-anchor[0] * this.a.mult, -anchor[1] * this.a.mult, anchor[2] * this.a.mult);
            }
            if (this.appliedTransformations < 2) {
                var scale = this.s.getValueAtTime(time);
                matrix.scale(scale[0] * this.s.mult, scale[1] * this.s.mult, scale[2] * this.s.mult);
            }
            if (this.sk && this.appliedTransformations < 3) {
                var skew = this.sk.getValueAtTime(time);
                var skewAxis = this.sa.getValueAtTime(time);
                matrix.skewFromAxis(-skew * this.sk.mult, skewAxis * this.sa.mult);
            }
            if (this.r && this.appliedTransformations < 4) {
                var rotation = this.r.getValueAtTime(time);
                matrix.rotate(-rotation * this.r.mult);
            } else if (!this.r && this.appliedTransformations < 4) {
                var rotationZ = this.rz.getValueAtTime(time);
                var rotationY = this.ry.getValueAtTime(time);
                var rotationX = this.rx.getValueAtTime(time);
                var orientation = this.or.getValueAtTime(time);
                matrix.rotateZ(-rotationZ * this.rz.mult).rotateY(rotationY * this.ry.mult).rotateX(rotationX * this.rx.mult).rotateZ(-orientation[2] * this.or.mult).rotateY(orientation[1] * this.or.mult).rotateX(orientation[0] * this.or.mult);
            }
            if (this.data.p && this.data.p.s) {
                var positionX = this.px.getValueAtTime(time);
                var positionY = this.py.getValueAtTime(time);
                if (this.data.p.z) {
                    var positionZ = this.pz.getValueAtTime(time);
                    matrix.translate(positionX * this.px.mult, positionY * this.py.mult, -positionZ * this.pz.mult);
                } else matrix.translate(positionX * this.px.mult, positionY * this.py.mult, 0);
            } else {
                var position = this.p.getValueAtTime(time);
                matrix.translate(position[0] * this.p.mult, position[1] * this.p.mult, -position[2] * this.p.mult);
            }
            return matrix; /// /
        }
        function getTransformStaticValueAtTime() {
            return this.v.clone(new Matrix());
        }
        var getTransformProperty = TransformPropertyFactory.getTransformProperty;
        TransformPropertyFactory.getTransformProperty = function(elem, data, container) {
            var prop = getTransformProperty(elem, data, container);
            if (prop.dynamicProperties.length) prop.getValueAtTime = getTransformValueAtTime.bind(prop);
            else prop.getValueAtTime = getTransformStaticValueAtTime.bind(prop);
            prop.setGroupProperty = expressionHelpers.setGroupProperty;
            return prop;
        };
        var propertyGetProp = PropertyFactory.getProp;
        PropertyFactory.getProp = function(elem, data, type, mult, container) {
            var prop = propertyGetProp(elem, data, type, mult, container); // prop.getVelocityAtTime = getVelocityAtTime;
            // prop.loopOut = loopOut;
            // prop.loopIn = loopIn;
            if (prop.kf) prop.getValueAtTime = expressionHelpers.getValueAtTime.bind(prop);
            else prop.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(prop);
            prop.setGroupProperty = expressionHelpers.setGroupProperty;
            prop.loopOut = loopOut;
            prop.loopIn = loopIn;
            prop.smooth = smooth;
            prop.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(prop);
            prop.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(prop);
            prop.numKeys = data.a === 1 ? data.k.length : 0;
            prop.propertyIndex = data.ix;
            var value = 0;
            if (type !== 0) value = createTypedArray("float32", data.a === 1 ? data.k[0].s.length : data.k.length);
            prop._cachingAtTime = {
                lastFrame: initialDefaultFrame,
                lastIndex: 0,
                value: value
            };
            expressionHelpers.searchExpressions(elem, data, prop);
            if (prop.k) container.addDynamicProperty(prop);
            return prop;
        };
        function getShapeValueAtTime(frameNum) {
            // For now this caching object is created only when needed instead of creating it when the shape is initialized.
            if (!this._cachingAtTime) this._cachingAtTime = {
                shapeValue: shapePool.clone(this.pv),
                lastIndex: 0,
                lastTime: initialDefaultFrame
            };
            frameNum *= this.elem.globalData.frameRate;
            frameNum -= this.offsetTime;
            if (frameNum !== this._cachingAtTime.lastTime) {
                this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < frameNum ? this._caching.lastIndex : 0;
                this._cachingAtTime.lastTime = frameNum;
                this.interpolateShape(frameNum, this._cachingAtTime.shapeValue, this._cachingAtTime);
            }
            return this._cachingAtTime.shapeValue;
        }
        var ShapePropertyConstructorFunction = ShapePropertyFactory.getConstructorFunction();
        var KeyframedShapePropertyConstructorFunction = ShapePropertyFactory.getKeyframedConstructorFunction();
        function ShapeExpressions() {}
        ShapeExpressions.prototype = {
            vertices: function vertices(prop, time) {
                if (this.k) this.getValue();
                var shapePath = this.v;
                if (time !== undefined) shapePath = this.getValueAtTime(time, 0);
                var i;
                var len = shapePath._length;
                var vertices = shapePath[prop];
                var points = shapePath.v;
                var arr = createSizedArray(len);
                for(i = 0; i < len; i += 1)if (prop === "i" || prop === "o") arr[i] = [
                    vertices[i][0] - points[i][0],
                    vertices[i][1] - points[i][1]
                ];
                else arr[i] = [
                    vertices[i][0],
                    vertices[i][1]
                ];
                return arr;
            },
            points: function points(time) {
                return this.vertices("v", time);
            },
            inTangents: function inTangents(time) {
                return this.vertices("i", time);
            },
            outTangents: function outTangents(time) {
                return this.vertices("o", time);
            },
            isClosed: function isClosed() {
                return this.v.c;
            },
            pointOnPath: function pointOnPath(perc, time) {
                var shapePath = this.v;
                if (time !== undefined) shapePath = this.getValueAtTime(time, 0);
                if (!this._segmentsLength) this._segmentsLength = bez.getSegmentsLength(shapePath);
                var segmentsLength = this._segmentsLength;
                var lengths = segmentsLength.lengths;
                var lengthPos = segmentsLength.totalLength * perc;
                var i = 0;
                var len = lengths.length;
                var accumulatedLength = 0;
                var pt;
                while(i < len){
                    if (accumulatedLength + lengths[i].addedLength > lengthPos) {
                        var initIndex = i;
                        var endIndex = shapePath.c && i === len - 1 ? 0 : i + 1;
                        var segmentPerc = (lengthPos - accumulatedLength) / lengths[i].addedLength;
                        pt = bez.getPointInSegment(shapePath.v[initIndex], shapePath.v[endIndex], shapePath.o[initIndex], shapePath.i[endIndex], segmentPerc, lengths[i]);
                        break;
                    } else accumulatedLength += lengths[i].addedLength;
                    i += 1;
                }
                if (!pt) pt = shapePath.c ? [
                    shapePath.v[0][0],
                    shapePath.v[0][1]
                ] : [
                    shapePath.v[shapePath._length - 1][0],
                    shapePath.v[shapePath._length - 1][1]
                ];
                return pt;
            },
            vectorOnPath: function vectorOnPath(perc, time, vectorType) {
                // perc doesn't use triple equality because it can be a Number object as well as a primitive.
                if (perc == 1) // eslint-disable-line eqeqeq
                perc = this.v.c;
                else if (perc == 0) // eslint-disable-line eqeqeq
                perc = 0.999;
                var pt1 = this.pointOnPath(perc, time);
                var pt2 = this.pointOnPath(perc + 0.001, time);
                var xLength = pt2[0] - pt1[0];
                var yLength = pt2[1] - pt1[1];
                var magnitude = Math.sqrt(Math.pow(xLength, 2) + Math.pow(yLength, 2));
                if (magnitude === 0) return [
                    0,
                    0
                ];
                var unitVector = vectorType === "tangent" ? [
                    xLength / magnitude,
                    yLength / magnitude
                ] : [
                    -yLength / magnitude,
                    xLength / magnitude
                ];
                return unitVector;
            },
            tangentOnPath: function tangentOnPath(perc, time) {
                return this.vectorOnPath(perc, time, "tangent");
            },
            normalOnPath: function normalOnPath(perc, time) {
                return this.vectorOnPath(perc, time, "normal");
            },
            setGroupProperty: expressionHelpers.setGroupProperty,
            getValueAtTime: expressionHelpers.getStaticValueAtTime
        };
        extendPrototype([
            ShapeExpressions
        ], ShapePropertyConstructorFunction);
        extendPrototype([
            ShapeExpressions
        ], KeyframedShapePropertyConstructorFunction);
        KeyframedShapePropertyConstructorFunction.prototype.getValueAtTime = getShapeValueAtTime;
        KeyframedShapePropertyConstructorFunction.prototype.initiateExpression = ExpressionManager.initiateExpression;
        var propertyGetShapeProp = ShapePropertyFactory.getShapeProp;
        ShapePropertyFactory.getShapeProp = function(elem, data, type, arr, trims) {
            var prop = propertyGetShapeProp(elem, data, type, arr, trims);
            prop.propertyIndex = data.ix;
            prop.lock = false;
            if (type === 3) expressionHelpers.searchExpressions(elem, data.pt, prop);
            else if (type === 4) expressionHelpers.searchExpressions(elem, data.ks, prop);
            if (prop.k) elem.addDynamicProperty(prop);
            return prop;
        };
    }
    function initialize$1() {
        addPropertyDecorator();
    }
    function addDecorator() {
        function searchExpressions() {
            if (this.data.d.x) {
                this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this);
                this.addEffect(this.getExpressionValue.bind(this));
                return true;
            }
            return null;
        }
        TextProperty.prototype.getExpressionValue = function(currentValue, text) {
            var newValue = this.calculateExpression(text);
            if (currentValue.t !== newValue) {
                var newData = {};
                this.copyData(newData, currentValue);
                newData.t = newValue.toString();
                newData.__complete = false;
                return newData;
            }
            return currentValue;
        };
        TextProperty.prototype.searchProperty = function() {
            var isKeyframed = this.searchKeyframes();
            var hasExpressions = this.searchExpressions();
            this.kf = isKeyframed || hasExpressions;
            return this.kf;
        };
        TextProperty.prototype.searchExpressions = searchExpressions;
    }
    function initialize() {
        addDecorator();
    }
    function SVGComposableEffect() {}
    SVGComposableEffect.prototype = {
        createMergeNode: function createMergeNode(resultId, ins) {
            var feMerge = createNS("feMerge");
            feMerge.setAttribute("result", resultId);
            var feMergeNode;
            var i;
            for(i = 0; i < ins.length; i += 1){
                feMergeNode = createNS("feMergeNode");
                feMergeNode.setAttribute("in", ins[i]);
                feMerge.appendChild(feMergeNode);
                feMerge.appendChild(feMergeNode);
            }
            return feMerge;
        }
    };
    function SVGTintFilter(filter, filterManager, elem, id, source) {
        this.filterManager = filterManager;
        var feColorMatrix = createNS("feColorMatrix");
        feColorMatrix.setAttribute("type", "matrix");
        feColorMatrix.setAttribute("color-interpolation-filters", "linearRGB");
        feColorMatrix.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0");
        feColorMatrix.setAttribute("result", id + "_tint_1");
        filter.appendChild(feColorMatrix);
        feColorMatrix = createNS("feColorMatrix");
        feColorMatrix.setAttribute("type", "matrix");
        feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
        feColorMatrix.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0");
        feColorMatrix.setAttribute("result", id + "_tint_2");
        filter.appendChild(feColorMatrix);
        this.matrixFilter = feColorMatrix;
        var feMerge = this.createMergeNode(id, [
            source,
            id + "_tint_1",
            id + "_tint_2"
        ]);
        filter.appendChild(feMerge);
    }
    extendPrototype([
        SVGComposableEffect
    ], SVGTintFilter);
    SVGTintFilter.prototype.renderFrame = function(forceRender) {
        if (forceRender || this.filterManager._mdf) {
            var colorBlack = this.filterManager.effectElements[0].p.v;
            var colorWhite = this.filterManager.effectElements[1].p.v;
            var opacity = this.filterManager.effectElements[2].p.v / 100;
            this.matrixFilter.setAttribute("values", colorWhite[0] - colorBlack[0] + " 0 0 0 " + colorBlack[0] + " " + (colorWhite[1] - colorBlack[1]) + " 0 0 0 " + colorBlack[1] + " " + (colorWhite[2] - colorBlack[2]) + " 0 0 0 " + colorBlack[2] + " 0 0 0 " + opacity + " 0");
        }
    };
    function SVGFillFilter(filter, filterManager, elem, id) {
        this.filterManager = filterManager;
        var feColorMatrix = createNS("feColorMatrix");
        feColorMatrix.setAttribute("type", "matrix");
        feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
        feColorMatrix.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0");
        feColorMatrix.setAttribute("result", id);
        filter.appendChild(feColorMatrix);
        this.matrixFilter = feColorMatrix;
    }
    SVGFillFilter.prototype.renderFrame = function(forceRender) {
        if (forceRender || this.filterManager._mdf) {
            var color = this.filterManager.effectElements[2].p.v;
            var opacity = this.filterManager.effectElements[6].p.v;
            this.matrixFilter.setAttribute("values", "0 0 0 0 " + color[0] + " 0 0 0 0 " + color[1] + " 0 0 0 0 " + color[2] + " 0 0 0 " + opacity + " 0");
        }
    };
    function SVGStrokeEffect(fil, filterManager, elem) {
        this.initialized = false;
        this.filterManager = filterManager;
        this.elem = elem;
        this.paths = [];
    }
    SVGStrokeEffect.prototype.initialize = function() {
        var elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
        var path;
        var groupPath;
        var i;
        var len;
        if (this.filterManager.effectElements[1].p.v === 1) {
            len = this.elem.maskManager.masksProperties.length;
            i = 0;
        } else {
            i = this.filterManager.effectElements[0].p.v - 1;
            len = i + 1;
        }
        groupPath = createNS("g");
        groupPath.setAttribute("fill", "none");
        groupPath.setAttribute("stroke-linecap", "round");
        groupPath.setAttribute("stroke-dashoffset", 1);
        for(i; i < len; i += 1){
            path = createNS("path");
            groupPath.appendChild(path);
            this.paths.push({
                p: path,
                m: i
            });
        }
        if (this.filterManager.effectElements[10].p.v === 3) {
            var mask = createNS("mask");
            var id = createElementID();
            mask.setAttribute("id", id);
            mask.setAttribute("mask-type", "alpha");
            mask.appendChild(groupPath);
            this.elem.globalData.defs.appendChild(mask);
            var g = createNS("g");
            g.setAttribute("mask", "url(" + getLocationHref() + "#" + id + ")");
            while(elemChildren[0])g.appendChild(elemChildren[0]);
            this.elem.layerElement.appendChild(g);
            this.masker = mask;
            groupPath.setAttribute("stroke", "#fff");
        } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
            if (this.filterManager.effectElements[10].p.v === 2) {
                elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
                while(elemChildren.length)this.elem.layerElement.removeChild(elemChildren[0]);
            }
            this.elem.layerElement.appendChild(groupPath);
            this.elem.layerElement.removeAttribute("mask");
            groupPath.setAttribute("stroke", "#fff");
        }
        this.initialized = true;
        this.pathMasker = groupPath;
    };
    SVGStrokeEffect.prototype.renderFrame = function(forceRender) {
        if (!this.initialized) this.initialize();
        var i;
        var len = this.paths.length;
        var mask;
        var path;
        for(i = 0; i < len; i += 1)if (this.paths[i].m !== -1) {
            mask = this.elem.maskManager.viewData[this.paths[i].m];
            path = this.paths[i].p;
            if (forceRender || this.filterManager._mdf || mask.prop._mdf) path.setAttribute("d", mask.lastPath);
            if (forceRender || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || mask.prop._mdf) {
                var dasharrayValue;
                if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {
                    var s = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
                    var e = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
                    var l = path.getTotalLength();
                    dasharrayValue = "0 0 0 " + l * s + " ";
                    var lineLength = l * (e - s);
                    var segment = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
                    var units = Math.floor(lineLength / segment);
                    var j;
                    for(j = 0; j < units; j += 1)dasharrayValue += "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01 + " ";
                    dasharrayValue += "0 " + l * 10 + " 0 0";
                } else dasharrayValue = "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
                path.setAttribute("stroke-dasharray", dasharrayValue);
            }
        }
        if (forceRender || this.filterManager.effectElements[4].p._mdf) this.pathMasker.setAttribute("stroke-width", this.filterManager.effectElements[4].p.v * 2);
        if (forceRender || this.filterManager.effectElements[6].p._mdf) this.pathMasker.setAttribute("opacity", this.filterManager.effectElements[6].p.v);
        if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
            if (forceRender || this.filterManager.effectElements[3].p._mdf) {
                var color = this.filterManager.effectElements[3].p.v;
                this.pathMasker.setAttribute("stroke", "rgb(" + bmFloor(color[0] * 255) + "," + bmFloor(color[1] * 255) + "," + bmFloor(color[2] * 255) + ")");
            }
        }
    };
    function SVGTritoneFilter(filter, filterManager, elem, id) {
        this.filterManager = filterManager;
        var feColorMatrix = createNS("feColorMatrix");
        feColorMatrix.setAttribute("type", "matrix");
        feColorMatrix.setAttribute("color-interpolation-filters", "linearRGB");
        feColorMatrix.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0");
        filter.appendChild(feColorMatrix);
        var feComponentTransfer = createNS("feComponentTransfer");
        feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB");
        feComponentTransfer.setAttribute("result", id);
        this.matrixFilter = feComponentTransfer;
        var feFuncR = createNS("feFuncR");
        feFuncR.setAttribute("type", "table");
        feComponentTransfer.appendChild(feFuncR);
        this.feFuncR = feFuncR;
        var feFuncG = createNS("feFuncG");
        feFuncG.setAttribute("type", "table");
        feComponentTransfer.appendChild(feFuncG);
        this.feFuncG = feFuncG;
        var feFuncB = createNS("feFuncB");
        feFuncB.setAttribute("type", "table");
        feComponentTransfer.appendChild(feFuncB);
        this.feFuncB = feFuncB;
        filter.appendChild(feComponentTransfer);
    }
    SVGTritoneFilter.prototype.renderFrame = function(forceRender) {
        if (forceRender || this.filterManager._mdf) {
            var color1 = this.filterManager.effectElements[0].p.v;
            var color2 = this.filterManager.effectElements[1].p.v;
            var color3 = this.filterManager.effectElements[2].p.v;
            var tableR = color3[0] + " " + color2[0] + " " + color1[0];
            var tableG = color3[1] + " " + color2[1] + " " + color1[1];
            var tableB = color3[2] + " " + color2[2] + " " + color1[2];
            this.feFuncR.setAttribute("tableValues", tableR);
            this.feFuncG.setAttribute("tableValues", tableG);
            this.feFuncB.setAttribute("tableValues", tableB);
        }
    };
    function SVGProLevelsFilter(filter, filterManager, elem, id) {
        this.filterManager = filterManager;
        var effectElements = this.filterManager.effectElements;
        var feComponentTransfer = createNS("feComponentTransfer"); // Red
        if (effectElements[10].p.k || effectElements[10].p.v !== 0 || effectElements[11].p.k || effectElements[11].p.v !== 1 || effectElements[12].p.k || effectElements[12].p.v !== 1 || effectElements[13].p.k || effectElements[13].p.v !== 0 || effectElements[14].p.k || effectElements[14].p.v !== 1) this.feFuncR = this.createFeFunc("feFuncR", feComponentTransfer);
         // Green
        if (effectElements[17].p.k || effectElements[17].p.v !== 0 || effectElements[18].p.k || effectElements[18].p.v !== 1 || effectElements[19].p.k || effectElements[19].p.v !== 1 || effectElements[20].p.k || effectElements[20].p.v !== 0 || effectElements[21].p.k || effectElements[21].p.v !== 1) this.feFuncG = this.createFeFunc("feFuncG", feComponentTransfer);
         // Blue
        if (effectElements[24].p.k || effectElements[24].p.v !== 0 || effectElements[25].p.k || effectElements[25].p.v !== 1 || effectElements[26].p.k || effectElements[26].p.v !== 1 || effectElements[27].p.k || effectElements[27].p.v !== 0 || effectElements[28].p.k || effectElements[28].p.v !== 1) this.feFuncB = this.createFeFunc("feFuncB", feComponentTransfer);
         // Alpha
        if (effectElements[31].p.k || effectElements[31].p.v !== 0 || effectElements[32].p.k || effectElements[32].p.v !== 1 || effectElements[33].p.k || effectElements[33].p.v !== 1 || effectElements[34].p.k || effectElements[34].p.v !== 0 || effectElements[35].p.k || effectElements[35].p.v !== 1) this.feFuncA = this.createFeFunc("feFuncA", feComponentTransfer);
         // RGB
        if (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) {
            feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB");
            filter.appendChild(feComponentTransfer);
        }
        if (effectElements[3].p.k || effectElements[3].p.v !== 0 || effectElements[4].p.k || effectElements[4].p.v !== 1 || effectElements[5].p.k || effectElements[5].p.v !== 1 || effectElements[6].p.k || effectElements[6].p.v !== 0 || effectElements[7].p.k || effectElements[7].p.v !== 1) {
            feComponentTransfer = createNS("feComponentTransfer");
            feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB");
            feComponentTransfer.setAttribute("result", id);
            filter.appendChild(feComponentTransfer);
            this.feFuncRComposed = this.createFeFunc("feFuncR", feComponentTransfer);
            this.feFuncGComposed = this.createFeFunc("feFuncG", feComponentTransfer);
            this.feFuncBComposed = this.createFeFunc("feFuncB", feComponentTransfer);
        }
    }
    SVGProLevelsFilter.prototype.createFeFunc = function(type, feComponentTransfer) {
        var feFunc = createNS(type);
        feFunc.setAttribute("type", "table");
        feComponentTransfer.appendChild(feFunc);
        return feFunc;
    };
    SVGProLevelsFilter.prototype.getTableValue = function(inputBlack, inputWhite, gamma, outputBlack, outputWhite) {
        var cnt = 0;
        var segments = 256;
        var perc;
        var min = Math.min(inputBlack, inputWhite);
        var max = Math.max(inputBlack, inputWhite);
        var table = Array.call(null, {
            length: segments
        });
        var colorValue;
        var pos = 0;
        var outputDelta = outputWhite - outputBlack;
        var inputDelta = inputWhite - inputBlack;
        while(cnt <= 256){
            perc = cnt / 256;
            if (perc <= min) colorValue = inputDelta < 0 ? outputWhite : outputBlack;
            else if (perc >= max) colorValue = inputDelta < 0 ? outputBlack : outputWhite;
            else colorValue = outputBlack + outputDelta * Math.pow((perc - inputBlack) / inputDelta, 1 / gamma);
            table[pos] = colorValue;
            pos += 1;
            cnt += 256 / (segments - 1);
        }
        return table.join(" ");
    };
    SVGProLevelsFilter.prototype.renderFrame = function(forceRender) {
        if (forceRender || this.filterManager._mdf) {
            var val;
            var effectElements = this.filterManager.effectElements;
            if (this.feFuncRComposed && (forceRender || effectElements[3].p._mdf || effectElements[4].p._mdf || effectElements[5].p._mdf || effectElements[6].p._mdf || effectElements[7].p._mdf)) {
                val = this.getTableValue(effectElements[3].p.v, effectElements[4].p.v, effectElements[5].p.v, effectElements[6].p.v, effectElements[7].p.v);
                this.feFuncRComposed.setAttribute("tableValues", val);
                this.feFuncGComposed.setAttribute("tableValues", val);
                this.feFuncBComposed.setAttribute("tableValues", val);
            }
            if (this.feFuncR && (forceRender || effectElements[10].p._mdf || effectElements[11].p._mdf || effectElements[12].p._mdf || effectElements[13].p._mdf || effectElements[14].p._mdf)) {
                val = this.getTableValue(effectElements[10].p.v, effectElements[11].p.v, effectElements[12].p.v, effectElements[13].p.v, effectElements[14].p.v);
                this.feFuncR.setAttribute("tableValues", val);
            }
            if (this.feFuncG && (forceRender || effectElements[17].p._mdf || effectElements[18].p._mdf || effectElements[19].p._mdf || effectElements[20].p._mdf || effectElements[21].p._mdf)) {
                val = this.getTableValue(effectElements[17].p.v, effectElements[18].p.v, effectElements[19].p.v, effectElements[20].p.v, effectElements[21].p.v);
                this.feFuncG.setAttribute("tableValues", val);
            }
            if (this.feFuncB && (forceRender || effectElements[24].p._mdf || effectElements[25].p._mdf || effectElements[26].p._mdf || effectElements[27].p._mdf || effectElements[28].p._mdf)) {
                val = this.getTableValue(effectElements[24].p.v, effectElements[25].p.v, effectElements[26].p.v, effectElements[27].p.v, effectElements[28].p.v);
                this.feFuncB.setAttribute("tableValues", val);
            }
            if (this.feFuncA && (forceRender || effectElements[31].p._mdf || effectElements[32].p._mdf || effectElements[33].p._mdf || effectElements[34].p._mdf || effectElements[35].p._mdf)) {
                val = this.getTableValue(effectElements[31].p.v, effectElements[32].p.v, effectElements[33].p.v, effectElements[34].p.v, effectElements[35].p.v);
                this.feFuncA.setAttribute("tableValues", val);
            }
        }
    };
    function SVGDropShadowEffect(filter, filterManager, elem, id, source) {
        var globalFilterSize = filterManager.container.globalData.renderConfig.filterSize;
        var filterSize = filterManager.data.fs || globalFilterSize;
        filter.setAttribute("x", filterSize.x || globalFilterSize.x);
        filter.setAttribute("y", filterSize.y || globalFilterSize.y);
        filter.setAttribute("width", filterSize.width || globalFilterSize.width);
        filter.setAttribute("height", filterSize.height || globalFilterSize.height);
        this.filterManager = filterManager;
        var feGaussianBlur = createNS("feGaussianBlur");
        feGaussianBlur.setAttribute("in", "SourceAlpha");
        feGaussianBlur.setAttribute("result", id + "_drop_shadow_1");
        feGaussianBlur.setAttribute("stdDeviation", "0");
        this.feGaussianBlur = feGaussianBlur;
        filter.appendChild(feGaussianBlur);
        var feOffset = createNS("feOffset");
        feOffset.setAttribute("dx", "25");
        feOffset.setAttribute("dy", "0");
        feOffset.setAttribute("in", id + "_drop_shadow_1");
        feOffset.setAttribute("result", id + "_drop_shadow_2");
        this.feOffset = feOffset;
        filter.appendChild(feOffset);
        var feFlood = createNS("feFlood");
        feFlood.setAttribute("flood-color", "#00ff00");
        feFlood.setAttribute("flood-opacity", "1");
        feFlood.setAttribute("result", id + "_drop_shadow_3");
        this.feFlood = feFlood;
        filter.appendChild(feFlood);
        var feComposite = createNS("feComposite");
        feComposite.setAttribute("in", id + "_drop_shadow_3");
        feComposite.setAttribute("in2", id + "_drop_shadow_2");
        feComposite.setAttribute("operator", "in");
        feComposite.setAttribute("result", id + "_drop_shadow_4");
        filter.appendChild(feComposite);
        var feMerge = this.createMergeNode(id, [
            id + "_drop_shadow_4",
            source
        ]);
        filter.appendChild(feMerge); //
    }
    extendPrototype([
        SVGComposableEffect
    ], SVGDropShadowEffect);
    SVGDropShadowEffect.prototype.renderFrame = function(forceRender) {
        if (forceRender || this.filterManager._mdf) {
            if (forceRender || this.filterManager.effectElements[4].p._mdf) this.feGaussianBlur.setAttribute("stdDeviation", this.filterManager.effectElements[4].p.v / 4);
            if (forceRender || this.filterManager.effectElements[0].p._mdf) {
                var col = this.filterManager.effectElements[0].p.v;
                this.feFlood.setAttribute("flood-color", rgbToHex(Math.round(col[0] * 255), Math.round(col[1] * 255), Math.round(col[2] * 255)));
            }
            if (forceRender || this.filterManager.effectElements[1].p._mdf) this.feFlood.setAttribute("flood-opacity", this.filterManager.effectElements[1].p.v / 255);
            if (forceRender || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
                var distance = this.filterManager.effectElements[3].p.v;
                var angle = (this.filterManager.effectElements[2].p.v - 90) * degToRads;
                var x = distance * Math.cos(angle);
                var y = distance * Math.sin(angle);
                this.feOffset.setAttribute("dx", x);
                this.feOffset.setAttribute("dy", y);
            }
        }
    };
    var _svgMatteSymbols = [];
    function SVGMatte3Effect(filterElem, filterManager, elem) {
        this.initialized = false;
        this.filterManager = filterManager;
        this.filterElem = filterElem;
        this.elem = elem;
        elem.matteElement = createNS("g");
        elem.matteElement.appendChild(elem.layerElement);
        elem.matteElement.appendChild(elem.transformedElement);
        elem.baseElement = elem.matteElement;
    }
    SVGMatte3Effect.prototype.findSymbol = function(mask) {
        var i = 0;
        var len = _svgMatteSymbols.length;
        while(i < len){
            if (_svgMatteSymbols[i] === mask) return _svgMatteSymbols[i];
            i += 1;
        }
        return null;
    };
    SVGMatte3Effect.prototype.replaceInParent = function(mask, symbolId) {
        var parentNode = mask.layerElement.parentNode;
        if (!parentNode) return;
        var children = parentNode.children;
        var i = 0;
        var len = children.length;
        while(i < len){
            if (children[i] === mask.layerElement) break;
            i += 1;
        }
        var nextChild;
        if (i <= len - 2) nextChild = children[i + 1];
        var useElem = createNS("use");
        useElem.setAttribute("href", "#" + symbolId);
        if (nextChild) parentNode.insertBefore(useElem, nextChild);
        else parentNode.appendChild(useElem);
    };
    SVGMatte3Effect.prototype.setElementAsMask = function(elem, mask) {
        if (!this.findSymbol(mask)) {
            var symbolId = createElementID();
            var masker = createNS("mask");
            masker.setAttribute("id", mask.layerId);
            masker.setAttribute("mask-type", "alpha");
            _svgMatteSymbols.push(mask);
            var defs = elem.globalData.defs;
            defs.appendChild(masker);
            var symbol = createNS("symbol");
            symbol.setAttribute("id", symbolId);
            this.replaceInParent(mask, symbolId);
            symbol.appendChild(mask.layerElement);
            defs.appendChild(symbol);
            var useElem = createNS("use");
            useElem.setAttribute("href", "#" + symbolId);
            masker.appendChild(useElem);
            mask.data.hd = false;
            mask.show();
        }
        elem.setMatte(mask.layerId);
    };
    SVGMatte3Effect.prototype.initialize = function() {
        var ind = this.filterManager.effectElements[0].p.v;
        var elements = this.elem.comp.elements;
        var i = 0;
        var len = elements.length;
        while(i < len){
            if (elements[i] && elements[i].data.ind === ind) this.setElementAsMask(this.elem, elements[i]);
            i += 1;
        }
        this.initialized = true;
    };
    SVGMatte3Effect.prototype.renderFrame = function() {
        if (!this.initialized) this.initialize();
    };
    function SVGGaussianBlurEffect(filter, filterManager, elem, id) {
        // Outset the filter region by 100% on all sides to accommodate blur expansion.
        filter.setAttribute("x", "-100%");
        filter.setAttribute("y", "-100%");
        filter.setAttribute("width", "300%");
        filter.setAttribute("height", "300%");
        this.filterManager = filterManager;
        var feGaussianBlur = createNS("feGaussianBlur");
        feGaussianBlur.setAttribute("result", id);
        filter.appendChild(feGaussianBlur);
        this.feGaussianBlur = feGaussianBlur;
    }
    SVGGaussianBlurEffect.prototype.renderFrame = function(forceRender) {
        if (forceRender || this.filterManager._mdf) {
            // Empirical value, matching AE's blur appearance.
            var kBlurrinessToSigma = 0.3;
            var sigma = this.filterManager.effectElements[0].p.v * kBlurrinessToSigma; // Dimensions mapping:
            //
            //   1 -> horizontal & vertical
            //   2 -> horizontal only
            //   3 -> vertical only
            //
            var dimensions = this.filterManager.effectElements[1].p.v;
            var sigmaX = dimensions == 3 ? 0 : sigma; // eslint-disable-line eqeqeq
            var sigmaY = dimensions == 2 ? 0 : sigma; // eslint-disable-line eqeqeq
            this.feGaussianBlur.setAttribute("stdDeviation", sigmaX + " " + sigmaY); // Repeat edges mapping:
            //
            //   0 -> off -> duplicate
            //   1 -> on  -> wrap
            var edgeMode = this.filterManager.effectElements[2].p.v == 1 ? "wrap" : "duplicate"; // eslint-disable-line eqeqeq
            this.feGaussianBlur.setAttribute("edgeMode", edgeMode);
        }
    };
    registerRenderer("canvas", CanvasRenderer);
    registerRenderer("html", HybridRenderer);
    registerRenderer("svg", SVGRenderer); // Registering shape modifiers
    ShapeModifiers.registerModifier("tm", TrimModifier);
    ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier);
    ShapeModifiers.registerModifier("rp", RepeaterModifier);
    ShapeModifiers.registerModifier("rd", RoundCornersModifier); // Registering expression plugin
    setExpressionsPlugin(Expressions);
    initialize$1();
    initialize(); // Registering svg effects
    registerEffect(20, SVGTintFilter, true);
    registerEffect(21, SVGFillFilter, true);
    registerEffect(22, SVGStrokeEffect, false);
    registerEffect(23, SVGTritoneFilter, true);
    registerEffect(24, SVGProLevelsFilter, true);
    registerEffect(25, SVGDropShadowEffect, true);
    registerEffect(28, SVGMatte3Effect, false);
    registerEffect(29, SVGGaussianBlurEffect, true);
    return lottie;
});

},{}],"fCF2B":[function(require,module,exports) {
"use strict";
// do not edit .js files directly - edit src/index.jst
var envHasBigInt64Array = typeof BigInt64Array !== "undefined";
module.exports = function equal(a, b) {
    if (a === b) return true;
    if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
            length = a.length;
            if (length != b.length) return false;
            for(i = length; i-- !== 0;)if (!equal(a[i], b[i])) return false;
            return true;
        }
        if (a instanceof Map && b instanceof Map) {
            if (a.size !== b.size) return false;
            for (i of a.entries())if (!b.has(i[0])) return false;
            for (i of a.entries())if (!equal(i[1], b.get(i[0]))) return false;
            return true;
        }
        if (a instanceof Set && b instanceof Set) {
            if (a.size !== b.size) return false;
            for (i of a.entries())if (!b.has(i[0])) return false;
            return true;
        }
        if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
            length = a.length;
            if (length != b.length) return false;
            for(i = length; i-- !== 0;)if (a[i] !== b[i]) return false;
            return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for(i = length; i-- !== 0;)if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for(i = length; i-- !== 0;){
            var key = keys[i];
            if (key === "_owner" && a.$$typeof) continue;
            if (!equal(a[key], b[key])) return false;
        }
        return true;
    }
    // true if both NaN, false otherwise
    return a !== a && b !== b;
};

},{}],"hJtbI":[function(require,module,exports) {
"use strict";
module.exports = require("267ec3ca7b46b25c")();

},{"267ec3ca7b46b25c":"6Q67C"}],"6Q67C":[function(require,module,exports) {
var Buffer = require("27ffece411fab229").Buffer;
"use strict";
module.exports = rfdc;
function copyBuffer(cur) {
    if (cur instanceof Buffer) return Buffer.from(cur);
    return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length);
}
function rfdc(opts) {
    opts = opts || {};
    if (opts.circles) return rfdcCircles(opts);
    return opts.proto ? cloneProto : clone;
    function cloneArray(a, fn) {
        var keys = Object.keys(a);
        var a2 = new Array(keys.length);
        for(var i = 0; i < keys.length; i++){
            var k = keys[i];
            var cur = a[k];
            if (typeof cur !== "object" || cur === null) a2[k] = cur;
            else if (cur instanceof Date) a2[k] = new Date(cur);
            else if (ArrayBuffer.isView(cur)) a2[k] = copyBuffer(cur);
            else a2[k] = fn(cur);
        }
        return a2;
    }
    function clone(o) {
        if (typeof o !== "object" || o === null) return o;
        if (o instanceof Date) return new Date(o);
        if (Array.isArray(o)) return cloneArray(o, clone);
        if (o instanceof Map) return new Map(cloneArray(Array.from(o), clone));
        if (o instanceof Set) return new Set(cloneArray(Array.from(o), clone));
        var o2 = {};
        for(var k in o){
            if (Object.hasOwnProperty.call(o, k) === false) continue;
            var cur = o[k];
            if (typeof cur !== "object" || cur === null) o2[k] = cur;
            else if (cur instanceof Date) o2[k] = new Date(cur);
            else if (cur instanceof Map) o2[k] = new Map(cloneArray(Array.from(cur), clone));
            else if (cur instanceof Set) o2[k] = new Set(cloneArray(Array.from(cur), clone));
            else if (ArrayBuffer.isView(cur)) o2[k] = copyBuffer(cur);
            else o2[k] = clone(cur);
        }
        return o2;
    }
    function cloneProto(o) {
        if (typeof o !== "object" || o === null) return o;
        if (o instanceof Date) return new Date(o);
        if (Array.isArray(o)) return cloneArray(o, cloneProto);
        if (o instanceof Map) return new Map(cloneArray(Array.from(o), cloneProto));
        if (o instanceof Set) return new Set(cloneArray(Array.from(o), cloneProto));
        var o2 = {};
        for(var k in o){
            var cur = o[k];
            if (typeof cur !== "object" || cur === null) o2[k] = cur;
            else if (cur instanceof Date) o2[k] = new Date(cur);
            else if (cur instanceof Map) o2[k] = new Map(cloneArray(Array.from(cur), cloneProto));
            else if (cur instanceof Set) o2[k] = new Set(cloneArray(Array.from(cur), cloneProto));
            else if (ArrayBuffer.isView(cur)) o2[k] = copyBuffer(cur);
            else o2[k] = cloneProto(cur);
        }
        return o2;
    }
}
function rfdcCircles(opts) {
    var refs = [];
    var refsNew = [];
    return opts.proto ? cloneProto : clone;
    function cloneArray(a, fn) {
        var keys = Object.keys(a);
        var a2 = new Array(keys.length);
        for(var i = 0; i < keys.length; i++){
            var k = keys[i];
            var cur = a[k];
            if (typeof cur !== "object" || cur === null) a2[k] = cur;
            else if (cur instanceof Date) a2[k] = new Date(cur);
            else if (ArrayBuffer.isView(cur)) a2[k] = copyBuffer(cur);
            else {
                var index = refs.indexOf(cur);
                if (index !== -1) a2[k] = refsNew[index];
                else a2[k] = fn(cur);
            }
        }
        return a2;
    }
    function clone(o) {
        if (typeof o !== "object" || o === null) return o;
        if (o instanceof Date) return new Date(o);
        if (Array.isArray(o)) return cloneArray(o, clone);
        if (o instanceof Map) return new Map(cloneArray(Array.from(o), clone));
        if (o instanceof Set) return new Set(cloneArray(Array.from(o), clone));
        var o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for(var k in o){
            if (Object.hasOwnProperty.call(o, k) === false) continue;
            var cur = o[k];
            if (typeof cur !== "object" || cur === null) o2[k] = cur;
            else if (cur instanceof Date) o2[k] = new Date(cur);
            else if (cur instanceof Map) o2[k] = new Map(cloneArray(Array.from(cur), clone));
            else if (cur instanceof Set) o2[k] = new Set(cloneArray(Array.from(cur), clone));
            else if (ArrayBuffer.isView(cur)) o2[k] = copyBuffer(cur);
            else {
                var i = refs.indexOf(cur);
                if (i !== -1) o2[k] = refsNew[i];
                else o2[k] = clone(cur);
            }
        }
        refs.pop();
        refsNew.pop();
        return o2;
    }
    function cloneProto(o) {
        if (typeof o !== "object" || o === null) return o;
        if (o instanceof Date) return new Date(o);
        if (Array.isArray(o)) return cloneArray(o, cloneProto);
        if (o instanceof Map) return new Map(cloneArray(Array.from(o), cloneProto));
        if (o instanceof Set) return new Set(cloneArray(Array.from(o), cloneProto));
        var o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for(var k in o){
            var cur = o[k];
            if (typeof cur !== "object" || cur === null) o2[k] = cur;
            else if (cur instanceof Date) o2[k] = new Date(cur);
            else if (cur instanceof Map) o2[k] = new Map(cloneArray(Array.from(cur), cloneProto));
            else if (cur instanceof Set) o2[k] = new Set(cloneArray(Array.from(cur), cloneProto));
            else if (ArrayBuffer.isView(cur)) o2[k] = copyBuffer(cur);
            else {
                var i = refs.indexOf(cur);
                if (i !== -1) o2[k] = refsNew[i];
                else o2[k] = cloneProto(cur);
            }
        }
        refs.pop();
        refsNew.pop();
        return o2;
    }
}

},{"27ffece411fab229":"lx3ES"}],"lx3ES":[function(require,module,exports) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ "use strict";
var base64 = require("c3e23dd6bd410a7");
var ieee754 = require("358291acfaef525b");
var customInspectSymbol = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
var K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        var arr = new Uint8Array(1);
        var proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    var buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === "string") return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayLike(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
    var valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    var b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== "number") throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") encoding = "utf8";
    if (!Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
    var length = byteLength(string, encoding) | 0;
    var buf = createBuffer(length);
    var actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer(length);
    for(var i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    var buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    var x = a.length;
    var y = b.length;
    for(var i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    var i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;
    for(i = 0; i < list.length; ++i){
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) buf = Buffer.from(buf);
        if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    var len = string.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    var loweredCase = false;
    for(;;)switch(encoding){
        case "ascii":
        case "latin1":
        case "binary":
            return len;
        case "utf8":
        case "utf-8":
            return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return len * 2;
        case "hex":
            return len >>> 1;
        case "base64":
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    var loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return "";
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return "";
    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return "";
    if (!encoding) encoding = "utf8";
    while(true)switch(encoding){
        case "hex":
            return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
            return utf8Slice(this, start, end);
        case "ascii":
            return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
            return latin1Slice(this, start, end);
        case "base64":
            return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for(var i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for(var i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for(var i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    var length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    var str = "";
    var max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError("out of range index");
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for(var i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === "string") val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
        val = val & 0xFF // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    var i;
    if (dir) {
        var foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            var found = true;
            for(var j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    var strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    for(var i = 0; i < length; ++i){
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function latin1Write(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = "utf8";
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    if (!encoding) encoding = "utf8";
    var loweredCase = false;
    for(;;)switch(encoding){
        case "hex":
            return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
            return utf8Write(this, string, offset, length);
        case "ascii":
            return asciiWrite(this, string, offset, length);
        case "latin1":
        case "binary":
            return latin1Write(this, string, offset, length);
        case "base64":
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while(i < end){
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    var res = "";
    var i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);
    return ret;
}
function latin1Slice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = "";
    for(var i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = "";
    for(var i = 0; i < bytes.length; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    var newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
}
Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset + --byteLength];
    var mul = 1;
    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;
    return val;
};
Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
}
Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError("targetStart out of bounds");
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    var len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else if (this === target && start < targetStart && targetStart < end) // descending copy from end
    for(var i = len - 1; i >= 0; --i)target[i + targetStart] = this[i + start];
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== "string") throw new TypeError("encoding must be a string");
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
        if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === "number") val = val & 255;
    else if (typeof val === "boolean") val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError("Out of range index");
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;
    if (typeof val === "number") for(i = start; i < end; ++i)this[i] = val;
    else {
        var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        var len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// HELPER FUNCTIONS
// ================
var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split("=")[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, "");
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return "";
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + "=";
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for(var i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else throw new Error("Invalid code point");
    }
    return bytes;
}
function asciiToBytes(str) {
    var byteArray = [];
    for(var i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
    return byteArray;
}
function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];
    for(var i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    for(var i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = function() {
    var alphabet = "0123456789abcdef";
    var table = new Array(256);
    for(var i = 0; i < 16; ++i){
        var i16 = i * 16;
        for(var j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();

},{"c3e23dd6bd410a7":"aeHmY","358291acfaef525b":"2VnEe"}],"aeHmY":[function(require,module,exports) {
"use strict";
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
    }
    return output.join("");
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + "==");
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + "=");
    }
    return parts.join("");
}

},{}],"2VnEe":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"AGLTb":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
} : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
var _extends = Object.assign || function(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i];
        for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
    }
    return target;
};
var _createClass = function() {
    function defineProperties(target, props) {
        for(var i = 0; i < props.length; i++){
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
    };
}();
var _react = require("947de8dd85bf0584");
var _react2 = _interopRequireDefault(_react);
var _propTypes = require("b371dd3b65a9a1c2");
var _propTypes2 = _interopRequireDefault(_propTypes);
var _classnames = require("427b441dc316697b");
var _classnames2 = _interopRequireDefault(_classnames);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _possibleConstructorReturn(self, call) {
    if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return call && (typeof call === "object" || typeof call === "function") ? call : self;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var ANIMATION_STATE_CLASSES = {
    animating: "rah-animating",
    animatingUp: "rah-animating--up",
    animatingDown: "rah-animating--down",
    animatingToHeightZero: "rah-animating--to-height-zero",
    animatingToHeightAuto: "rah-animating--to-height-auto",
    animatingToHeightSpecific: "rah-animating--to-height-specific",
    static: "rah-static",
    staticHeightZero: "rah-static--height-zero",
    staticHeightAuto: "rah-static--height-auto",
    staticHeightSpecific: "rah-static--height-specific"
};
var PROPS_TO_OMIT = [
    "animateOpacity",
    "animationStateClasses",
    "applyInlineTransitions",
    "children",
    "contentClassName",
    "delay",
    "duration",
    "easing",
    "height",
    "onAnimationEnd",
    "onAnimationStart"
];
function omit(obj) {
    for(var _len = arguments.length, keys = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)keys[_key - 1] = arguments[_key];
    if (!keys.length) return obj;
    var res = {};
    var objectKeys = Object.keys(obj);
    for(var i = 0; i < objectKeys.length; i++){
        var key = objectKeys[i];
        if (keys.indexOf(key) === -1) res[key] = obj[key];
    }
    return res;
}
// Start animation helper using nested requestAnimationFrames
function startAnimationHelper(callback) {
    var requestAnimationFrameIDs = [];
    requestAnimationFrameIDs[0] = requestAnimationFrame(function() {
        requestAnimationFrameIDs[1] = requestAnimationFrame(function() {
            callback();
        });
    });
    return requestAnimationFrameIDs;
}
function cancelAnimationFrames(requestAnimationFrameIDs) {
    requestAnimationFrameIDs.forEach(function(id) {
        return cancelAnimationFrame(id);
    });
}
function isNumber(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
}
function isPercentage(height) {
    // Percentage height
    return typeof height === "string" && height.search("%") === height.length - 1 && isNumber(height.substr(0, height.length - 1));
}
function runCallback(callback, params) {
    if (callback && typeof callback === "function") callback(params);
}
var AnimateHeight = function(_React$Component) {
    _inherits(AnimateHeight, _React$Component);
    function AnimateHeight(props) {
        _classCallCheck(this, AnimateHeight);
        var _this = _possibleConstructorReturn(this, (AnimateHeight.__proto__ || Object.getPrototypeOf(AnimateHeight)).call(this, props));
        _this.animationFrameIDs = [];
        var height = "auto";
        var overflow = "visible";
        if (isNumber(props.height)) {
            // If value is string "0" make sure we convert it to number 0
            height = props.height < 0 || props.height === "0" ? 0 : props.height;
            overflow = "hidden";
        } else if (isPercentage(props.height)) {
            // If value is string "0%" make sure we convert it to number 0
            height = props.height === "0%" ? 0 : props.height;
            overflow = "hidden";
        }
        _this.animationStateClasses = _extends({}, ANIMATION_STATE_CLASSES, props.animationStateClasses);
        var animationStateClasses = _this.getStaticStateClasses(height);
        var isBrowser = typeof window !== "undefined";
        if (isBrowser && window.matchMedia) _this.prefersReducedMotion = window.matchMedia("(prefers-reduced-motion)").matches;
        _this.state = {
            animationStateClasses: animationStateClasses,
            height: height,
            overflow: overflow,
            shouldUseTransitions: false
        };
        return _this;
    }
    _createClass(AnimateHeight, [
        {
            key: "componentDidMount",
            value: function componentDidMount() {
                var height = this.state.height;
                // Hide content if height is 0 (to prevent tabbing into it)
                // Check for contentElement is added cause this would fail in tests (react-test-renderer)
                // Read more here: https://github.com/Stanko/react-animate-height/issues/17
                if (this.contentElement && this.contentElement.style) this.hideContent(height);
            }
        },
        {
            key: "componentDidUpdate",
            value: function componentDidUpdate(prevProps, prevState) {
                var _this2 = this;
                var _props = this.props, height = _props.height, onAnimationEnd = _props.onAnimationEnd, onAnimationStart = _props.onAnimationStart;
                var _getTimings = this.getTimings(), duration = _getTimings.duration, delay = _getTimings.delay;
                // Check if 'height' prop has changed
                if (this.contentElement && height !== prevProps.height) {
                    var _cx;
                    // Remove display: none from the content div
                    // if it was hidden to prevent tabbing into it
                    this.showContent(prevState.height);
                    // Cache content height
                    this.contentElement.style.overflow = "hidden";
                    var contentHeight = this.contentElement.offsetHeight;
                    this.contentElement.style.overflow = "";
                    // set total animation time
                    var totalDuration = duration + delay;
                    var newHeight = null;
                    var timeoutState = {
                        height: null,
                        overflow: "hidden"
                    };
                    var isCurrentHeightAuto = prevState.height === "auto";
                    if (isNumber(height)) {
                        // If value is string "0" make sure we convert it to number 0
                        newHeight = height < 0 || height === "0" ? 0 : height;
                        timeoutState.height = newHeight;
                    } else if (isPercentage(height)) {
                        // If value is string "0%" make sure we convert it to number 0
                        newHeight = height === "0%" ? 0 : height;
                        timeoutState.height = newHeight;
                    } else {
                        // If not, animate to content height
                        // and then reset to auto
                        newHeight = contentHeight; // TODO solve contentHeight = 0
                        timeoutState.height = "auto";
                        timeoutState.overflow = null;
                    }
                    if (isCurrentHeightAuto) {
                        // This is the height to be animated to
                        timeoutState.height = newHeight;
                        // If previous height was 'auto'
                        // set starting height explicitly to be able to use transition
                        newHeight = contentHeight;
                    }
                    // Animation classes
                    var animationStateClasses = (0, _classnames2.default)((_cx = {}, _defineProperty(_cx, this.animationStateClasses.animating, true), _defineProperty(_cx, this.animationStateClasses.animatingUp, prevProps.height === "auto" || height < prevProps.height), _defineProperty(_cx, this.animationStateClasses.animatingDown, height === "auto" || height > prevProps.height), _defineProperty(_cx, this.animationStateClasses.animatingToHeightZero, timeoutState.height === 0), _defineProperty(_cx, this.animationStateClasses.animatingToHeightAuto, timeoutState.height === "auto"), _defineProperty(_cx, this.animationStateClasses.animatingToHeightSpecific, timeoutState.height > 0), _cx));
                    // Animation classes to be put after animation is complete
                    var timeoutAnimationStateClasses = this.getStaticStateClasses(timeoutState.height);
                    // Set starting height and animating classes
                    // We are safe to call set state as it will not trigger infinite loop
                    // because of the "height !== prevProps.height" check
                    this.setState({
                        animationStateClasses: animationStateClasses,
                        height: newHeight,
                        overflow: "hidden",
                        // When animating from 'auto' we first need to set fixed height
                        // that change should be animated
                        shouldUseTransitions: !isCurrentHeightAuto
                    });
                    // Clear timeouts
                    clearTimeout(this.timeoutID);
                    clearTimeout(this.animationClassesTimeoutID);
                    if (isCurrentHeightAuto) {
                        // When animating from 'auto' we use a short timeout to start animation
                        // after setting fixed height above
                        timeoutState.shouldUseTransitions = true;
                        cancelAnimationFrames(this.animationFrameIDs);
                        this.animationFrameIDs = startAnimationHelper(function() {
                            _this2.setState(timeoutState);
                            // ANIMATION STARTS, run a callback if it exists
                            runCallback(onAnimationStart, {
                                newHeight: timeoutState.height
                            });
                        });
                        // Set static classes and remove transitions when animation ends
                        this.animationClassesTimeoutID = setTimeout(function() {
                            _this2.setState({
                                animationStateClasses: timeoutAnimationStateClasses,
                                shouldUseTransitions: false
                            });
                            // ANIMATION ENDS
                            // Hide content if height is 0 (to prevent tabbing into it)
                            _this2.hideContent(timeoutState.height);
                            // Run a callback if it exists
                            runCallback(onAnimationEnd, {
                                newHeight: timeoutState.height
                            });
                        }, totalDuration);
                    } else {
                        // ANIMATION STARTS, run a callback if it exists
                        runCallback(onAnimationStart, {
                            newHeight: newHeight
                        });
                        // Set end height, classes and remove transitions when animation is complete
                        this.timeoutID = setTimeout(function() {
                            timeoutState.animationStateClasses = timeoutAnimationStateClasses;
                            timeoutState.shouldUseTransitions = false;
                            _this2.setState(timeoutState);
                            // ANIMATION ENDS
                            // If height is auto, don't hide the content
                            // (case when element is empty, therefore height is 0)
                            if (height !== "auto") // Hide content if height is 0 (to prevent tabbing into it)
                            _this2.hideContent(newHeight); // TODO solve newHeight = 0
                            // Run a callback if it exists
                            runCallback(onAnimationEnd, {
                                newHeight: newHeight
                            });
                        }, totalDuration);
                    }
                }
            }
        },
        {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                cancelAnimationFrames(this.animationFrameIDs);
                clearTimeout(this.timeoutID);
                clearTimeout(this.animationClassesTimeoutID);
                this.timeoutID = null;
            }
        },
        {
            key: "getTimings",
            value: function getTimings() {
                if (this.prefersReducedMotion) return {
                    delay: 0,
                    duration: 0
                };
                var _props2 = this.props, delay = _props2.delay, duration = _props2.duration;
                return {
                    delay: delay,
                    duration: duration
                };
            }
        },
        {
            key: "showContent",
            value: function showContent(height) {
                if (height === 0) this.contentElement.style.display = "";
            }
        },
        {
            key: "hideContent",
            value: function hideContent(newHeight) {
                if (newHeight === 0) this.contentElement.style.display = "none";
            }
        },
        {
            key: "getStaticStateClasses",
            value: function getStaticStateClasses(height) {
                var _cx2;
                return (0, _classnames2.default)((_cx2 = {}, _defineProperty(_cx2, this.animationStateClasses.static, true), _defineProperty(_cx2, this.animationStateClasses.staticHeightZero, height === 0), _defineProperty(_cx2, this.animationStateClasses.staticHeightSpecific, height > 0), _defineProperty(_cx2, this.animationStateClasses.staticHeightAuto, height === "auto"), _cx2));
            }
        },
        {
            key: "render",
            value: function render() {
                var _cx3, _this3 = this;
                var _props3 = this.props, animateOpacity = _props3.animateOpacity, applyInlineTransitions = _props3.applyInlineTransitions, children = _props3.children, className = _props3.className, contentClassName = _props3.contentClassName, easing = _props3.easing, id = _props3.id, style = _props3.style;
                var _state = this.state, height = _state.height, overflow = _state.overflow, animationStateClasses = _state.animationStateClasses, shouldUseTransitions = _state.shouldUseTransitions;
                var _getTimings2 = this.getTimings(), duration = _getTimings2.duration, delay = _getTimings2.delay;
                var componentStyle = _extends({}, style, {
                    height: height,
                    overflow: overflow || style.overflow
                });
                if (shouldUseTransitions && applyInlineTransitions) {
                    componentStyle.transition = "height " + duration + "ms " + easing + " " + delay + "ms";
                    // Include transition passed through styles
                    if (style.transition) componentStyle.transition = style.transition + ", " + componentStyle.transition;
                    // Add webkit vendor prefix still used by opera, blackberry...
                    componentStyle.WebkitTransition = componentStyle.transition;
                }
                var contentStyle = {};
                if (animateOpacity) {
                    contentStyle.transition = "opacity " + duration + "ms " + easing + " " + delay + "ms";
                    // Add webkit vendor prefix still used by opera, blackberry...
                    contentStyle.WebkitTransition = contentStyle.transition;
                    if (height === 0) contentStyle.opacity = 0;
                }
                var componentClasses = (0, _classnames2.default)((_cx3 = {}, _defineProperty(_cx3, animationStateClasses, true), _defineProperty(_cx3, className, className), _cx3));
                // Check if user passed aria-hidden prop
                var hasAriaHiddenProp = typeof this.props["aria-hidden"] !== "undefined";
                var ariaHidden = hasAriaHiddenProp ? this.props["aria-hidden"] : height === 0;
                return _react2.default.createElement("div", _extends({}, omit.apply(undefined, [
                    this.props
                ].concat(PROPS_TO_OMIT)), {
                    "aria-hidden": ariaHidden,
                    className: componentClasses,
                    id: id,
                    style: componentStyle
                }), _react2.default.createElement("div", {
                    className: contentClassName,
                    style: contentStyle,
                    ref: function ref(el) {
                        return _this3.contentElement = el;
                    }
                }, children));
            }
        }
    ]);
    return AnimateHeight;
}(_react2.default.Component);
var heightPropType = function heightPropType(props, propName, componentName) {
    var value = props[propName];
    if (typeof value === "number" && value >= 0 || isPercentage(value) || value === "auto") return null;
    return new TypeError('value "' + value + '" of type "' + (typeof value === "undefined" ? "undefined" : _typeof(value)) + '" is invalid type for ' + propName + " in " + componentName + ". " + 'It needs to be a positive number, string "auto" or percentage string (e.g. "15%").');
};
AnimateHeight.propTypes = {
    "aria-hidden": _propTypes2.default.bool,
    animateOpacity: _propTypes2.default.bool,
    animationStateClasses: _propTypes2.default.object,
    applyInlineTransitions: _propTypes2.default.bool,
    children: _propTypes2.default.any.isRequired,
    className: _propTypes2.default.string,
    contentClassName: _propTypes2.default.string,
    delay: _propTypes2.default.number,
    duration: _propTypes2.default.number,
    easing: _propTypes2.default.string,
    height: heightPropType,
    id: _propTypes2.default.string,
    onAnimationEnd: _propTypes2.default.func,
    onAnimationStart: _propTypes2.default.func,
    style: _propTypes2.default.object
};
AnimateHeight.defaultProps = {
    animateOpacity: false,
    animationStateClasses: ANIMATION_STATE_CLASSES,
    applyInlineTransitions: true,
    duration: 250,
    delay: 0,
    easing: "ease",
    style: {}
};
exports.default = AnimateHeight;

},{"947de8dd85bf0584":"2kGyk","b371dd3b65a9a1c2":"cdRwn","427b441dc316697b":"1giFm"}],"cdRwn":[function(require,module,exports) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var ReactIs = require("56fb1bceeb17ba72");
// By explicitly using `prop-types` you are opting into new development behavior.
// http://fb.me/prop-types-in-prod
var throwOnDirectAccess = true;
module.exports = require("ffbd63add44a3e40")(ReactIs.isElement, throwOnDirectAccess);

},{"56fb1bceeb17ba72":"krxlJ","ffbd63add44a3e40":"4BcN9"}],"krxlJ":[function(require,module,exports) {
"use strict";
module.exports = require("6b0b46cedaff2f7e");

},{"6b0b46cedaff2f7e":"aswVp"}],"aswVp":[function(require,module,exports) {
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ "use strict";
(function() {
    "use strict";
    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
    // nor polyfill, then a plain number is used for performance.
    var hasSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 0xeac7;
    var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 0xeaca;
    var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 0xeacb;
    var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 0xeacc;
    var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 0xead2;
    var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 0xeacd;
    var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
    // (unstable) APIs that have been removed. Can we remove the symbols?
    var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 0xeacf;
    var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 0xeacf;
    var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 0xead0;
    var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 0xead1;
    var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 0xead8;
    var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 0xead3;
    var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 0xead4;
    var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 0xead9;
    var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 0xead5;
    var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 0xead6;
    var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 0xead7;
    function isValidElementType(type) {
        return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
        type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
    }
    function typeOf(object) {
        if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch($$typeof){
                case REACT_ELEMENT_TYPE:
                    var type = object.type;
                    switch(type){
                        case REACT_ASYNC_MODE_TYPE:
                        case REACT_CONCURRENT_MODE_TYPE:
                        case REACT_FRAGMENT_TYPE:
                        case REACT_PROFILER_TYPE:
                        case REACT_STRICT_MODE_TYPE:
                        case REACT_SUSPENSE_TYPE:
                            return type;
                        default:
                            var $$typeofType = type && type.$$typeof;
                            switch($$typeofType){
                                case REACT_CONTEXT_TYPE:
                                case REACT_FORWARD_REF_TYPE:
                                case REACT_LAZY_TYPE:
                                case REACT_MEMO_TYPE:
                                case REACT_PROVIDER_TYPE:
                                    return $$typeofType;
                                default:
                                    return $$typeof;
                            }
                    }
                case REACT_PORTAL_TYPE:
                    return $$typeof;
            }
        }
        return undefined;
    } // AsyncMode is deprecated along with isAsyncMode
    var AsyncMode = REACT_ASYNC_MODE_TYPE;
    var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
    var ContextConsumer = REACT_CONTEXT_TYPE;
    var ContextProvider = REACT_PROVIDER_TYPE;
    var Element = REACT_ELEMENT_TYPE;
    var ForwardRef = REACT_FORWARD_REF_TYPE;
    var Fragment = REACT_FRAGMENT_TYPE;
    var Lazy = REACT_LAZY_TYPE;
    var Memo = REACT_MEMO_TYPE;
    var Portal = REACT_PORTAL_TYPE;
    var Profiler = REACT_PROFILER_TYPE;
    var StrictMode = REACT_STRICT_MODE_TYPE;
    var Suspense = REACT_SUSPENSE_TYPE;
    var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated
    function isAsyncMode(object) {
        if (!hasWarnedAboutDeprecatedIsAsyncMode) {
            hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint
            console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
        }
        return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
    }
    function isConcurrentMode(object) {
        return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
    }
    function isContextConsumer(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
    }
    function isContextProvider(object) {
        return typeOf(object) === REACT_PROVIDER_TYPE;
    }
    function isElement(object) {
        return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function isForwardRef(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
    }
    function isFragment(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
    }
    function isLazy(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
    }
    function isMemo(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
    }
    function isPortal(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
    }
    function isProfiler(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
    }
    function isStrictMode(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
    }
    function isSuspense(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
    }
    exports.AsyncMode = AsyncMode;
    exports.ConcurrentMode = ConcurrentMode;
    exports.ContextConsumer = ContextConsumer;
    exports.ContextProvider = ContextProvider;
    exports.Element = Element;
    exports.ForwardRef = ForwardRef;
    exports.Fragment = Fragment;
    exports.Lazy = Lazy;
    exports.Memo = Memo;
    exports.Portal = Portal;
    exports.Profiler = Profiler;
    exports.StrictMode = StrictMode;
    exports.Suspense = Suspense;
    exports.isAsyncMode = isAsyncMode;
    exports.isConcurrentMode = isConcurrentMode;
    exports.isContextConsumer = isContextConsumer;
    exports.isContextProvider = isContextProvider;
    exports.isElement = isElement;
    exports.isForwardRef = isForwardRef;
    exports.isFragment = isFragment;
    exports.isLazy = isLazy;
    exports.isMemo = isMemo;
    exports.isPortal = isPortal;
    exports.isProfiler = isProfiler;
    exports.isStrictMode = isStrictMode;
    exports.isSuspense = isSuspense;
    exports.isValidElementType = isValidElementType;
    exports.typeOf = typeOf;
})();

},{}],"4BcN9":[function(require,module,exports) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ "use strict";
var ReactIs = require("d3740ba93a23fc23");
var assign = require("f965188bd87c545e");
var ReactPropTypesSecret = require("cee8d035fc5f084b");
var has = require("677d608fbaaab649");
var checkPropTypes = require("e34bad52932bc1c4");
var printWarning = function() {};
printWarning = function(text) {
    var message = "Warning: " + text;
    if (typeof console !== "undefined") console.error(message);
    try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
    } catch (x) {}
};
function emptyFunctionThatReturnsNull() {
    return null;
}
module.exports = function(isValidElement, throwOnDirectAccess) {
    /* global Symbol */ var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = "@@iterator"; // Before Symbol spec.
    /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */ function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") return iteratorFn;
    }
    /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */ var ANONYMOUS = "<<anonymous>>";
    // Important!
    // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
    var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
    };
    /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */ /*eslint-disable no-self-compare*/ function is(x, y) {
        // SameValue algorithm
        if (x === y) // Steps 1-5, 7-10
        // Steps 6.b-6.e: +0 != -0
        return x !== 0 || 1 / x === 1 / y;
        else // Step 6.a: NaN == NaN
        return x !== x && y !== y;
    }
    /*eslint-enable no-self-compare*/ /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */ function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
    }
    // Make `instanceof Error` still work for returned errors.
    PropTypeError.prototype = Error.prototype;
    function createChainableTypeChecker(validate) {
        var manualPropTypeCallCache = {};
        var manualPropTypeWarningCount = 0;
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
            componentName = componentName || ANONYMOUS;
            propFullName = propFullName || propName;
            if (secret !== ReactPropTypesSecret) {
                if (throwOnDirectAccess) {
                    // New behavior only for users of `prop-types` package
                    var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types");
                    err.name = "Invariant Violation";
                    throw err;
                } else if (typeof console !== "undefined") {
                    // Old behavior for people using React.PropTypes
                    var cacheKey = componentName + ":" + propName;
                    if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
                    manualPropTypeWarningCount < 3) {
                        printWarning("You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated " + "and will throw in the standalone `prop-types` package. " + "You may be seeing this warning due to a third-party PropTypes " + "library. See https://fb.me/react-warning-dont-call-proptypes " + "for details.");
                        manualPropTypeCallCache[cacheKey] = true;
                        manualPropTypeWarningCount++;
                    }
                }
            }
            if (props[propName] == null) {
                if (isRequired) {
                    if (props[propName] === null) return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
                    return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
                }
                return null;
            } else return validate(props, propName, componentName, location, propFullName);
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
    }
    function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== expectedType) {
                // `propValue` being instance of, say, date/regexp, pass the 'object'
                // check, but we can offer a more precise error message here rather than
                // 'of type `object`'.
                var preciseType = getPreciseType(propValue);
                return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."), {
                    expectedType: expectedType
                });
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
    }
    function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== "function") return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
            var propValue = props[propName];
            if (!Array.isArray(propValue)) {
                var propType = getPropType(propValue);
                return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
            }
            for(var i = 0; i < propValue.length; i++){
                var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
                if (error instanceof Error) return error;
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            if (!isValidElement(propValue)) {
                var propType = getPropType(propValue);
                return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            if (!ReactIs.isValidElementType(propValue)) {
                var propType = getPropType(propValue);
                return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
            if (!(props[propName] instanceof expectedClass)) {
                var expectedClassName = expectedClass.name || ANONYMOUS;
                var actualClassName = getClassName(props[propName]);
                return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
            {
                if (arguments.length > 1) printWarning("Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. " + "A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).");
                else printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
            return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            for(var i = 0; i < expectedValues.length; i++){
                if (is(propValue, expectedValues[i])) return null;
            }
            var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
                var type = getPreciseType(value);
                if (type === "symbol") return String(value);
                return value;
            });
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
    }
    function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== "function") return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
            for(var key in propValue)if (has(propValue, key)) {
                var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
                if (error instanceof Error) return error;
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
            printWarning("Invalid argument supplied to oneOfType, expected an instance of array.");
            return emptyFunctionThatReturnsNull;
        }
        for(var i = 0; i < arrayOfTypeCheckers.length; i++){
            var checker = arrayOfTypeCheckers[i];
            if (typeof checker !== "function") {
                printWarning("Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + ".");
                return emptyFunctionThatReturnsNull;
            }
        }
        function validate(props, propName, componentName, location, propFullName) {
            var expectedTypes = [];
            for(var i = 0; i < arrayOfTypeCheckers.length; i++){
                var checker = arrayOfTypeCheckers[i];
                var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
                if (checkerResult == null) return null;
                if (checkerResult.data && has(checkerResult.data, "expectedType")) expectedTypes.push(checkerResult.data.expectedType);
            }
            var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
    }
    function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
            if (!isNode(props[propName])) return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError((componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; " + "it must be a function, usually from the `prop-types` package, but received `" + type + "`.");
    }
    function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
            for(var key in shapeTypes){
                var checker = shapeTypes[key];
                if (typeof checker !== "function") return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
                var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
                if (error) return error;
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
            // We need to check all keys in case some are required but missing from props.
            var allKeys = assign({}, props[propName], shapeTypes);
            for(var key in allKeys){
                var checker = shapeTypes[key];
                if (has(shapeTypes, key) && typeof checker !== "function") return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
                if (!checker) return new PropTypeError("Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`." + "\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  "));
                var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
                if (error) return error;
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function isNode(propValue) {
        switch(typeof propValue){
            case "number":
            case "string":
            case "undefined":
                return true;
            case "boolean":
                return !propValue;
            case "object":
                if (Array.isArray(propValue)) return propValue.every(isNode);
                if (propValue === null || isValidElement(propValue)) return true;
                var iteratorFn = getIteratorFn(propValue);
                if (iteratorFn) {
                    var iterator = iteratorFn.call(propValue);
                    var step;
                    if (iteratorFn !== propValue.entries) while(!(step = iterator.next()).done){
                        if (!isNode(step.value)) return false;
                    }
                    else // Iterator will provide entry [k,v] tuples rather than values.
                    while(!(step = iterator.next()).done){
                        var entry = step.value;
                        if (entry) {
                            if (!isNode(entry[1])) return false;
                        }
                    }
                } else return false;
                return true;
            default:
                return false;
        }
    }
    function isSymbol(propType, propValue) {
        // Native Symbol.
        if (propType === "symbol") return true;
        // falsy value can't be a Symbol
        if (!propValue) return false;
        // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
        if (propValue["@@toStringTag"] === "Symbol") return true;
        // Fallback for non-spec compliant Symbols which are polyfilled.
        if (typeof Symbol === "function" && propValue instanceof Symbol) return true;
        return false;
    }
    // Equivalent of `typeof` but with special handling for array and regexp.
    function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) return "array";
        if (propValue instanceof RegExp) // Old webkits (at least until Android 4.0) return 'function' rather than
        // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
        // passes PropTypes.object.
        return "object";
        if (isSymbol(propType, propValue)) return "symbol";
        return propType;
    }
    // This handles more types than `getPropType`. Only used for error messages.
    // See `createPrimitiveTypeChecker`.
    function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) return "" + propValue;
        var propType = getPropType(propValue);
        if (propType === "object") {
            if (propValue instanceof Date) return "date";
            else if (propValue instanceof RegExp) return "regexp";
        }
        return propType;
    }
    // Returns a string that is postfixed to a warning about an invalid type.
    // For example, "undefined" or "of type array"
    function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch(type){
            case "array":
            case "object":
                return "an " + type;
            case "boolean":
            case "date":
            case "regexp":
                return "a " + type;
            default:
                return type;
        }
    }
    // Returns class name of the object, if any.
    function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) return ANONYMOUS;
        return propValue.constructor.name;
    }
    ReactPropTypes.checkPropTypes = checkPropTypes;
    ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
};

},{"d3740ba93a23fc23":"krxlJ","f965188bd87c545e":"cOuox","cee8d035fc5f084b":"7zOyX","677d608fbaaab649":"lAPBy","e34bad52932bc1c4":"4Vuhu"}],"cOuox":[function(require,module,exports) {
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/ "use strict";
/* eslint-disable no-unused-vars */ var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
    if (val === null || val === undefined) throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(val);
}
function shouldUseNative() {
    try {
        if (!Object.assign) return false;
        // Detect buggy property enumeration order in older V8 versions.
        // https://bugs.chromium.org/p/v8/issues/detail?id=4118
        var test1 = new String("abc"); // eslint-disable-line no-new-wrappers
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") return false;
        // https://bugs.chromium.org/p/v8/issues/detail?id=3056
        var test2 = {};
        for(var i = 0; i < 10; i++)test2["_" + String.fromCharCode(i)] = i;
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
            return test2[n];
        });
        if (order2.join("") !== "0123456789") return false;
        // https://bugs.chromium.org/p/v8/issues/detail?id=3056
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
            test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") return false;
        return true;
    } catch (err) {
        // We don't expect any of the above to throw, but better to be safe.
        return false;
    }
}
module.exports = shouldUseNative() ? Object.assign : function(target, source) {
    var from;
    var to = toObject(target);
    var symbols;
    for(var s = 1; s < arguments.length; s++){
        from = Object(arguments[s]);
        for(var key in from)if (hasOwnProperty.call(from, key)) to[key] = from[key];
        if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for(var i = 0; i < symbols.length; i++)if (propIsEnumerable.call(from, symbols[i])) to[symbols[i]] = from[symbols[i]];
        }
    }
    return to;
};

},{}],"7zOyX":[function(require,module,exports) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ "use strict";
var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
module.exports = ReactPropTypesSecret;

},{}],"lAPBy":[function(require,module,exports) {
module.exports = Function.call.bind(Object.prototype.hasOwnProperty);

},{}],"4Vuhu":[function(require,module,exports) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ "use strict";
var printWarning = function() {};
var ReactPropTypesSecret = require("93ffe5975666f365");
var loggedTypeFailures = {};
var has = require("7aa7233091e559ec");
printWarning = function(text) {
    var message = "Warning: " + text;
    if (typeof console !== "undefined") console.error(message);
    try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
    } catch (x) {}
};
/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */ function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
    for(var typeSpecName in typeSpecs)if (has(typeSpecs, typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
            // This is intentionally an invariant that gets caught. It's the same
            // behavior as without this statement except with a better message.
            if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; " + "it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`." + "This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                err.name = "Invariant Violation";
                throw err;
            }
            error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
            error = ex;
        }
        if (error && !(error instanceof Error)) printWarning((componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker " + "function must return `null` or an `Error` but returned a " + typeof error + ". " + "You may have forgotten to pass an argument to the type checker " + "creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and " + "shape all require an argument).");
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
            // Only monitor this failure once because there tends to be a lot of the
            // same error.
            loggedTypeFailures[error.message] = true;
            var stack = getStack ? getStack() : "";
            printWarning("Failed " + location + " type: " + error.message + (stack != null ? stack : ""));
        }
    }
}
/**
 * Resets warning cache when testing.
 *
 * @private
 */ checkPropTypes.resetWarningCache = function() {
    loggedTypeFailures = {};
};
module.exports = checkPropTypes;

},{"93ffe5975666f365":"7zOyX","7aa7233091e559ec":"lAPBy"}],"h3scm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ResponsiveMasonry", ()=>(0, _responsiveMasonryDefault.default));
var _masonry = require("./Masonry");
var _masonryDefault = parcelHelpers.interopDefault(_masonry);
var _responsiveMasonry = require("./ResponsiveMasonry");
var _responsiveMasonryDefault = parcelHelpers.interopDefault(_responsiveMasonry);
exports.default = (0, _masonryDefault.default);

},{"./Masonry":"4fn0d","./ResponsiveMasonry":"WuPDX","@parcel/transformer-js/src/esmodule-helpers.js":"hqSvo"}],"4fn0d":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
function _extends() {
    _extends = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
var Masonry = /*#__PURE__*/ function(_React$Component) {
    _inheritsLoose(Masonry, _React$Component);
    function Masonry() {
        return _React$Component.apply(this, arguments) || this;
    }
    var _proto = Masonry.prototype;
    _proto.getColumns = function getColumns() {
        var _this$props = this.props, children = _this$props.children, columnsCount = _this$props.columnsCount;
        var columns = Array.from({
            length: columnsCount
        }, function() {
            return [];
        });
        (0, _reactDefault.default).Children.forEach(children, function(child, index) {
            if (child && (0, _reactDefault.default).isValidElement(child)) columns[index % columnsCount].push(child);
        });
        return columns;
    };
    _proto.renderColumns = function renderColumns() {
        var gutter = this.props.gutter;
        return this.getColumns().map(function(column, i) {
            return /*#__PURE__*/ (0, _reactDefault.default).createElement("div", {
                key: i,
                style: {
                    display: "flex",
                    flexDirection: "column",
                    justifyContent: "flex-start",
                    alignContent: "stretch",
                    flex: 1,
                    width: 0,
                    gap: gutter
                }
            }, column.map(function(item) {
                return item;
            }));
        });
    };
    _proto.render = function render() {
        var _this$props2 = this.props, gutter = _this$props2.gutter, className = _this$props2.className, style = _this$props2.style;
        return /*#__PURE__*/ (0, _reactDefault.default).createElement("div", {
            style: _extends({
                display: "flex",
                flexDirection: "row",
                justifyContent: "center",
                alignContent: "stretch",
                boxSizing: "border-box",
                width: "100%",
                gap: gutter
            }, style),
            className: className
        }, this.renderColumns());
    };
    return Masonry;
}((0, _reactDefault.default).Component);
Masonry.propTypes = {
    children: (0, _propTypesDefault.default).oneOfType([
        (0, _propTypesDefault.default).arrayOf((0, _propTypesDefault.default).node),
        (0, _propTypesDefault.default).node
    ]).isRequired,
    columnsCount: (0, _propTypesDefault.default).number,
    gutter: (0, _propTypesDefault.default).string,
    className: (0, _propTypesDefault.default).string,
    style: (0, _propTypesDefault.default).object
};
Masonry.defaultProps = {
    columnsCount: 3,
    gutter: "0",
    className: null,
    style: {}
};
exports.default = Masonry;

},{"prop-types":"cdRwn","react":"2kGyk","@parcel/transformer-js/src/esmodule-helpers.js":"hqSvo"}],"WuPDX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _propTypes = require("prop-types");
var _propTypesDefault = parcelHelpers.interopDefault(_propTypes);
var _react = require("react");
var _reactDefault = parcelHelpers.interopDefault(_react);
var DEFAULT_COLUMNS_COUNT = 1;
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? (0, _react.useLayoutEffect) : (0, _react.useEffect);
var useHasMounted = function useHasMounted() {
    var _useState = (0, _react.useState)(false), hasMounted = _useState[0], setHasMounted = _useState[1];
    useIsomorphicLayoutEffect(function() {
        setHasMounted(true);
    }, []);
    return hasMounted;
};
var useWindowWidth = function useWindowWidth() {
    var hasMounted = useHasMounted();
    var _useState2 = (0, _react.useState)(0), width = _useState2[0], setWidth = _useState2[1];
    var handleResize = (0, _react.useCallback)(function() {
        if (!hasMounted) return;
        setWidth(window.innerWidth);
    }, [
        hasMounted
    ]);
    useIsomorphicLayoutEffect(function() {
        if (hasMounted) {
            window.addEventListener("resize", handleResize);
            handleResize();
            return function() {
                return window.removeEventListener("resize", handleResize);
            };
        }
    }, [
        hasMounted,
        handleResize
    ]);
    return width;
};
var MasonryResponsive = function MasonryResponsive(_ref) {
    var columnsCountBreakPoints = _ref.columnsCountBreakPoints, children = _ref.children, className = _ref.className, style = _ref.style;
    var windowWidth = useWindowWidth();
    var columnsCount = (0, _react.useMemo)(function() {
        var breakPoints = Object.keys(columnsCountBreakPoints).sort(function(a, b) {
            return a - b;
        });
        var count = breakPoints.length > 0 ? columnsCountBreakPoints[breakPoints[0]] : DEFAULT_COLUMNS_COUNT;
        breakPoints.forEach(function(breakPoint) {
            if (breakPoint < windowWidth) count = columnsCountBreakPoints[breakPoint];
        });
        return count;
    }, [
        windowWidth,
        columnsCountBreakPoints
    ]);
    return /*#__PURE__*/ (0, _reactDefault.default).createElement("div", {
        className: className,
        style: style
    }, (0, _reactDefault.default).Children.map(children, function(child, index) {
        return (0, _reactDefault.default).cloneElement(child, {
            key: index,
            columnsCount: columnsCount
        });
    }));
};
MasonryResponsive.propTypes = {
    children: (0, _propTypesDefault.default).oneOfType([
        (0, _propTypesDefault.default).arrayOf((0, _propTypesDefault.default).node),
        (0, _propTypesDefault.default).node
    ]).isRequired,
    columnsCountBreakPoints: (0, _propTypesDefault.default).object,
    className: (0, _propTypesDefault.default).string,
    style: (0, _propTypesDefault.default).object
};
MasonryResponsive.defaultProps = {
    columnsCountBreakPoints: {
        350: 1,
        750: 2,
        900: 3
    },
    className: null,
    style: null
};
exports.default = MasonryResponsive;

},{"prop-types":"cdRwn","react":"2kGyk","@parcel/transformer-js/src/esmodule-helpers.js":"hqSvo"}],"knIBK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _react = require("react");
var _reactIntersectionObserverHook = require("react-intersection-observer-hook");
var DEFAULT_DELAY_IN_MS = 100;
function useInfiniteScroll(_ref) {
    var loading = _ref.loading, hasNextPage = _ref.hasNextPage, onLoadMore = _ref.onLoadMore, rootMargin = _ref.rootMargin, disabled = _ref.disabled, _ref$delayInMs = _ref.delayInMs, delayInMs = _ref$delayInMs === void 0 ? DEFAULT_DELAY_IN_MS : _ref$delayInMs;
    var _useTrackVisibility = (0, _reactIntersectionObserverHook.useTrackVisibility)({
        rootMargin: rootMargin
    }), ref = _useTrackVisibility[0], _useTrackVisibility$ = _useTrackVisibility[1], rootRef = _useTrackVisibility$.rootRef, isVisible = _useTrackVisibility$.isVisible;
    var shouldLoadMore = !disabled && !loading && isVisible && hasNextPage; // eslint-disable-next-line consistent-return
    (0, _react.useEffect)(function() {
        if (shouldLoadMore) {
            // When we trigger 'onLoadMore' and new items are added to the list,
            // right before they become rendered on the screen, 'loading' becomes false
            // and 'isVisible' can be true for a brief time, based on the scroll position.
            // So, it triggers 'onLoadMore' just after the first one is finished.
            // We use a small delay here to prevent this kind of situations.
            // It can be configured by hook args.
            var timer = setTimeout(function() {
                onLoadMore();
            }, delayInMs);
            return function() {
                clearTimeout(timer);
            };
        }
    }, [
        onLoadMore,
        shouldLoadMore,
        delayInMs
    ]);
    return [
        ref,
        {
            rootRef: rootRef
        }
    ];
}
exports.default = useInfiniteScroll;

},{"react":"2kGyk","react-intersection-observer-hook":"aKSuF","@parcel/transformer-js/src/esmodule-helpers.js":"hqSvo"}],"aKSuF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useIntersectionObserver", ()=>useIntersectionObserver);
parcelHelpers.export(exports, "useTrackVisibility", ()=>useTrackVisibility);
var _react = require("react");
var DEFAULT_ROOT_MARGIN = "0px";
var DEFAULT_THRESHOLD = [
    0
]; // For more info:
// https://developers.google.com/web/updates/2016/04/intersectionobserver
// https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
function useIntersectionObserver(args) {
    var _args$rootMargin, _args$threshold;
    var rootMargin = (_args$rootMargin = args == null ? void 0 : args.rootMargin) != null ? _args$rootMargin : DEFAULT_ROOT_MARGIN;
    var threshold = (_args$threshold = args == null ? void 0 : args.threshold) != null ? _args$threshold : DEFAULT_THRESHOLD;
    var nodeRef = (0, _react.useRef)(null);
    var rootRef = (0, _react.useRef)(null);
    var observerRef = (0, _react.useRef)(null);
    var _useState = (0, _react.useState)(), entry = _useState[0], setEntry = _useState[1];
    var unobserve = (0, _react.useCallback)(function() {
        // Disconnect the current observer (if there is one)
        var currentObserver = observerRef.current;
        currentObserver == null || currentObserver.disconnect();
        observerRef.current = null;
    }, []);
    var observe = (0, _react.useCallback)(function() {
        var node = nodeRef.current;
        if (node) {
            var root = rootRef.current;
            var options = {
                root: root,
                rootMargin: rootMargin,
                threshold: threshold
            }; // Create a observer for current "node" with given options.
            var observer = new IntersectionObserver(function(_ref) {
                var newEntry = _ref[0];
                setEntry(newEntry);
            }, options);
            observer.observe(node);
            observerRef.current = observer;
        }
    }, [
        rootMargin,
        threshold
    ]);
    var initializeObserver = (0, _react.useCallback)(function() {
        unobserve();
        observe();
    }, [
        observe,
        unobserve
    ]);
    var refCallback = (0, _react.useCallback)(function(node) {
        nodeRef.current = node;
        initializeObserver();
    }, [
        initializeObserver
    ]);
    var rootRefCallback = (0, _react.useCallback)(function(rootNode) {
        rootRef.current = rootNode;
        initializeObserver();
    }, [
        initializeObserver
    ]);
    (0, _react.useEffect)(function() {
        // After React 18, StrictMode unmounts and mounts components to be sure
        // if they are resilient effects being mounted and destroyed multiple times.
        // This a behavior to be sure nothing breaks when off-screen components
        // can preserve their state with future React versions.
        // So in StrictMode, React unmounts the component, clean-up of this useEffect gets triggered and
        // we stop observing the node. But we need to start observing after component re-mounts with its preserved state.
        // So to handle this case, we call initializeObserver here.
        // https://reactjs.org/blog/2022/03/08/react-18-upgrade-guide.html#updates-to-strict-mode
        initializeObserver();
        return function() {
            // We disconnect the observer on unmount to prevent memory leaks etc.
            unobserve();
        };
    }, [
        initializeObserver,
        unobserve
    ]);
    return [
        refCallback,
        {
            entry: entry,
            rootRef: rootRefCallback
        }
    ];
}
function _extends() {
    _extends = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
function useTrackVisibility(args) {
    var _result$entry;
    var _useIntersectionObser = useIntersectionObserver(args), ref = _useIntersectionObser[0], result = _useIntersectionObser[1];
    var isVisible = Boolean((_result$entry = result.entry) == null ? void 0 : _result$entry.isIntersecting);
    var _useState = (0, _react.useState)(isVisible), wasEverVisible = _useState[0], setWasEverVisible = _useState[1];
    (0, _react.useEffect)(function() {
        if (isVisible) setWasEverVisible(isVisible);
    }, [
        isVisible
    ]);
    return [
        ref,
        _extends({}, result, {
            isVisible: isVisible,
            wasEverVisible: wasEverVisible
        })
    ];
}

},{"react":"2kGyk","@parcel/transformer-js/src/esmodule-helpers.js":"hqSvo"}],"3TmwF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "useDebounce", ()=>(0, _useDebounceDefault.default));
parcelHelpers.export(exports, "useDebouncedCallback", ()=>(0, _useDebouncedCallbackDefault.default));
parcelHelpers.export(exports, "useThrottledCallback", ()=>(0, _useThrottledCallbackDefault.default));
var _useDebounce = require("./useDebounce");
var _useDebounceDefault = parcelHelpers.interopDefault(_useDebounce);
var _useDebouncedCallback = require("./useDebouncedCallback");
var _useDebouncedCallbackDefault = parcelHelpers.interopDefault(_useDebouncedCallback);
var _useThrottledCallback = require("./useThrottledCallback");
var _useThrottledCallbackDefault = parcelHelpers.interopDefault(_useThrottledCallback);

},{"./useDebounce":"dMmhk","./useDebouncedCallback":"ki3Tb","./useThrottledCallback":"bolVF","@parcel/transformer-js/src/esmodule-helpers.js":"hqSvo"}],"dMmhk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _react = require("react");
var _useDebouncedCallback = require("./useDebouncedCallback");
var _useDebouncedCallbackDefault = parcelHelpers.interopDefault(_useDebouncedCallback);
function valueEquality(left, right) {
    return left === right;
}
function adjustFunctionValueOfSetState(value) {
    return typeof value === "function" ? function() {
        return value;
    } : value;
}
function useStateIgnoreCallback(initialState) {
    var _a = (0, _react.useState)(adjustFunctionValueOfSetState(initialState)), state = _a[0], setState = _a[1];
    var setStateIgnoreCallback = (0, _react.useCallback)(function(value) {
        return setState(adjustFunctionValueOfSetState(value));
    }, []);
    return [
        state,
        setStateIgnoreCallback
    ];
}
function useDebounce(value, delay, options) {
    var eq = options && options.equalityFn || valueEquality;
    var _a = useStateIgnoreCallback(value), state = _a[0], dispatch = _a[1];
    var debounced = (0, _useDebouncedCallbackDefault.default)((0, _react.useCallback)(function(value) {
        return dispatch(value);
    }, [
        dispatch
    ]), delay, options);
    var previousValue = (0, _react.useRef)(value);
    if (!eq(previousValue.current, value)) {
        debounced(value);
        previousValue.current = value;
    }
    return [
        state,
        debounced
    ];
}
exports.default = useDebounce;

},{"react":"2kGyk","./useDebouncedCallback":"ki3Tb","@parcel/transformer-js/src/esmodule-helpers.js":"hqSvo"}],"ki3Tb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _react = require("react");
function useDebouncedCallback(func, wait, options) {
    var _this = this;
    var lastCallTime = (0, _react.useRef)(null);
    var lastInvokeTime = (0, _react.useRef)(0);
    var timerId = (0, _react.useRef)(null);
    var lastArgs = (0, _react.useRef)([]);
    var lastThis = (0, _react.useRef)();
    var result = (0, _react.useRef)();
    var funcRef = (0, _react.useRef)(func);
    var mounted = (0, _react.useRef)(true);
    funcRef.current = func;
    // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.
    var useRAF = !wait && wait !== 0 && typeof window !== "undefined";
    if (typeof func !== "function") throw new TypeError("Expected a function");
    wait = +wait || 0;
    options = options || {};
    var leading = !!options.leading;
    var trailing = "trailing" in options ? !!options.trailing : true; // `true` by default
    var maxing = "maxWait" in options;
    var maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : null;
    (0, _react.useEffect)(function() {
        mounted.current = true;
        return function() {
            mounted.current = false;
        };
    }, []);
    // You may have a question, why we have so many code under the useMemo definition.
    //
    // This was made as we want to escape from useCallback hell and
    // not to initialize a number of functions each time useDebouncedCallback is called.
    //
    // It means that we have less garbage for our GC calls which improves performance.
    // Also, it makes this library smaller.
    //
    // And the last reason, that the code without lots of useCallback with deps is easier to read.
    // You have only one place for that.
    var debounced = (0, _react.useMemo)(function() {
        var invokeFunc = function(time) {
            var args = lastArgs.current;
            var thisArg = lastThis.current;
            lastArgs.current = lastThis.current = null;
            lastInvokeTime.current = time;
            return result.current = funcRef.current.apply(thisArg, args);
        };
        var startTimer = function(pendingFunc, wait) {
            if (useRAF) cancelAnimationFrame(timerId.current);
            timerId.current = useRAF ? requestAnimationFrame(pendingFunc) : setTimeout(pendingFunc, wait);
        };
        var shouldInvoke = function(time) {
            if (!mounted.current) return false;
            var timeSinceLastCall = time - lastCallTime.current;
            var timeSinceLastInvoke = time - lastInvokeTime.current;
            // Either this is the first call, activity has stopped and we're at the
            // trailing edge, the system time has gone backwards and we're treating
            // it as the trailing edge, or we've hit the `maxWait` limit.
            return !lastCallTime.current || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        };
        var trailingEdge = function(time) {
            timerId.current = null;
            // Only invoke if we have `lastArgs` which means `func` has been
            // debounced at least once.
            if (trailing && lastArgs.current) return invokeFunc(time);
            lastArgs.current = lastThis.current = null;
            return result.current;
        };
        var timerExpired = function() {
            var time = Date.now();
            if (shouldInvoke(time)) return trailingEdge(time);
            // https://github.com/xnimorz/use-debounce/issues/97
            if (!mounted.current) return;
            // Remaining wait calculation
            var timeSinceLastCall = time - lastCallTime.current;
            var timeSinceLastInvoke = time - lastInvokeTime.current;
            var timeWaiting = wait - timeSinceLastCall;
            var remainingWait = maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            // Restart the timer
            startTimer(timerExpired, remainingWait);
        };
        var func = function() {
            var args = [];
            for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
            var time = Date.now();
            var isInvoking = shouldInvoke(time);
            lastArgs.current = args;
            lastThis.current = _this;
            lastCallTime.current = time;
            if (isInvoking) {
                if (!timerId.current && mounted.current) {
                    // Reset any `maxWait` timer.
                    lastInvokeTime.current = lastCallTime.current;
                    // Start the timer for the trailing edge.
                    startTimer(timerExpired, wait);
                    // Invoke the leading edge.
                    return leading ? invokeFunc(lastCallTime.current) : result.current;
                }
                if (maxing) {
                    // Handle invocations in a tight loop.
                    startTimer(timerExpired, wait);
                    return invokeFunc(lastCallTime.current);
                }
            }
            if (!timerId.current) startTimer(timerExpired, wait);
            return result.current;
        };
        func.cancel = function() {
            if (timerId.current) useRAF ? cancelAnimationFrame(timerId.current) : clearTimeout(timerId.current);
            lastInvokeTime.current = 0;
            lastArgs.current = lastCallTime.current = lastThis.current = timerId.current = null;
        };
        func.isPending = function() {
            return !!timerId.current;
        };
        func.flush = function() {
            return !timerId.current ? result.current : trailingEdge(Date.now());
        };
        return func;
    }, [
        leading,
        maxing,
        wait,
        maxWait,
        trailing,
        useRAF
    ]);
    return debounced;
}
exports.default = useDebouncedCallback;

},{"react":"2kGyk","@parcel/transformer-js/src/esmodule-helpers.js":"hqSvo"}],"bolVF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _useDebouncedCallback = require("./useDebouncedCallback");
var _useDebouncedCallbackDefault = parcelHelpers.interopDefault(_useDebouncedCallback);
function useThrottledCallback(func, wait, _a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.leading, leading = _c === void 0 ? true : _c, _d = _b.trailing, trailing = _d === void 0 ? true : _d;
    return (0, _useDebouncedCallbackDefault.default)(func, wait, {
        maxWait: wait,
        leading: leading,
        trailing: trailing
    });
}
exports.default = useThrottledCallback;

},{"./useDebouncedCallback":"ki3Tb","@parcel/transformer-js/src/esmodule-helpers.js":"hqSvo"}],"2hWPw":[function(require,module,exports) {
"use strict";
module.exports = require("628cf0a008c6206").default;

},{"628cf0a008c6206":"gb9p8"}],"gb9p8":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _createClass = function() {
    function defineProperties(target, props) {
        for(var i = 0; i < props.length; i++){
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
    };
}();
var _react = require("1649fb96814d9542");
var _react2 = _interopRequireDefault(_react);
var _propTypes = require("f8b82b80838a213");
var _propTypes2 = _interopRequireDefault(_propTypes);
var _howler4 = require("ed4354d675fc156");
var _utils = require("592184e7162c72dc");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _possibleConstructorReturn(self, call) {
    if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return call && (typeof call === "object" || typeof call === "function") ? call : self;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var ReactHowler = function(_Component) {
    _inherits(ReactHowler, _Component);
    function ReactHowler(props) {
        _classCallCheck(this, ReactHowler);
        var _this = _possibleConstructorReturn(this, (ReactHowler.__proto__ || Object.getPrototypeOf(ReactHowler)).call(this, props));
        _this.initHowler = _this.initHowler.bind(_this);
        return _this;
    }
    _createClass(ReactHowler, [
        {
            key: "componentDidMount",
            value: function componentDidMount() {
                this.initHowler();
            }
        },
        {
            key: "componentDidUpdate",
            value: function componentDidUpdate(prevProps) {
                // The src prop must be either a string or an array of strings
                // Because of this, we can use it's JSON representation to check for changes
                if (JSON.stringify(prevProps.src) !== JSON.stringify(this.props.src)) this.initHowler(this.props);
                else this.toggleHowler(prevProps);
            }
        },
        {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                this.destroyHowler();
            }
        },
        {
            key: "initHowler",
            value: function initHowler() {
                var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
                this.destroyHowler();
                if (typeof _howler4.Howl !== "undefined") {
                    // Check if window is available
                    this.howler = new _howler4.Howl({
                        src: props.src,
                        xhr: props.xhr,
                        format: props.format,
                        mute: props.mute,
                        loop: props.loop,
                        preload: props.preload,
                        volume: props.volume,
                        rate: props.rate,
                        onend: props.onEnd,
                        onplay: props.onPlay,
                        onplayerror: props.onPlayError,
                        onpause: props.onPause,
                        onvolume: props.onVolume,
                        onstop: props.onStop,
                        onload: props.onLoad,
                        onseek: props.onSeek,
                        onloaderror: props.onLoadError,
                        html5: props.html5
                    });
                    if (props.playing) this.play();
                }
            }
        },
        {
            key: "destroyHowler",
            value: function destroyHowler() {
                if (this.howler) {
                    this.howler.off(); // Remove event listener
                    this.howler.stop(); // Stop playback
                    this.howler.unload(); // Remove sound from pool
                    this.howler = null; // Destroy it
                }
            }
        },
        {
            key: "toggleHowler",
            value: function toggleHowler(prevProps) {
                this.props.playing ? this.play() : this.pause();
                this.loop(this.props.loop);
                if (prevProps.mute !== this.props.mute) this.mute(this.props.mute);
                if (prevProps.volume !== this.props.volume) this.volume(this.props.volume);
                if (this.props.preload && this.howlerState() === "unloaded") this.load();
            }
        },
        {
            key: "play",
            /**
     * Begins playback of a sound when not playing
     */ value: function play() {
                var playing = this.howler.playing();
                if (!playing) {
                    // Automatically load if we're trying to play
                    // and the howl is not loaded
                    if (this.howlerState() === "unloaded") this.load();
                    this.howler.play();
                }
            }
        },
        {
            key: "pause",
            value: function pause() {
                var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
                if (id) this.howler.pause(id);
                else this.howler.pause();
            }
        },
        {
            key: "rate",
            value: function rate() {
                var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
                var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
                if (typeof value === "number") {
                    if (id) this.howler.rate(value, id);
                    else this.howler.rate(value);
                }
            }
        },
        {
            key: "howlerState",
            value: function howlerState() {
                return this.howler.state();
            }
        },
        {
            key: "stop",
            value: function stop() {
                var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
                if (id) this.howler.stop(id);
                else this.howler.stop();
            }
        },
        {
            key: "mute",
            value: function mute() {
                var _howler;
                (_howler = this.howler).mute.apply(_howler, arguments);
            }
        },
        {
            key: "volume",
            value: function volume() {
                var _howler2;
                return (_howler2 = this.howler).volume.apply(_howler2, arguments);
            }
        },
        {
            key: "loop",
            value: function loop() {
                var _howler3;
                return (_howler3 = this.howler).loop.apply(_howler3, arguments);
            }
        },
        {
            key: "seek",
            value: function seek() {
                var pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
                if (!this.howler) return 0;
                if (!pos && pos !== 0) return this.howler.seek();
                if (pos || pos === 0) {
                    this.howler.seek(pos);
                    return pos;
                }
            }
        },
        {
            key: "duration",
            value: function duration() {
                return this.howler.duration();
            }
        },
        {
            key: "load",
            value: function load() {
                this.howler.load();
            }
        },
        {
            key: "render",
            value: function render() {
                return _react2.default.createElement("div", null);
            }
        },
        {
            key: "howler",
            set: function set(howl) {
                if (howl) this._howler = howl;
            },
            get: function get() {
                return this._howler;
            }
        }
    ]);
    return ReactHowler;
}(_react.Component);
ReactHowler.propTypes = {
    src: _propTypes2.default.oneOfType([
        _propTypes2.default.string,
        _propTypes2.default.arrayOf(_propTypes2.default.string)
    ]).isRequired,
    format: _propTypes2.default.arrayOf(_propTypes2.default.string),
    xhr: _propTypes2.default.object,
    playing: _propTypes2.default.bool,
    mute: _propTypes2.default.bool,
    loop: _propTypes2.default.bool,
    preload: _propTypes2.default.bool,
    volume: _propTypes2.default.number,
    rate: _propTypes2.default.number,
    onEnd: _propTypes2.default.func,
    onPause: _propTypes2.default.func,
    onPlay: _propTypes2.default.func,
    onPlayError: _propTypes2.default.func,
    onVolume: _propTypes2.default.func,
    onStop: _propTypes2.default.func,
    onLoad: _propTypes2.default.func,
    onSeek: _propTypes2.default.func,
    onLoadError: _propTypes2.default.func,
    html5: _propTypes2.default.bool
};
ReactHowler.defaultProps = {
    playing: true,
    format: [],
    xhr: {},
    mute: false,
    preload: true,
    loop: false,
    volume: 1.0,
    rate: 1,
    onEnd: _utils.noop,
    onPause: _utils.noop,
    onPlay: _utils.noop,
    onPlayError: _utils.noop,
    onVolume: _utils.noop,
    onStop: _utils.noop,
    onLoad: _utils.noop,
    onSeek: _utils.noop,
    onLoadError: _utils.noop,
    html5: false
};
exports.default = ReactHowler;

},{"1649fb96814d9542":"2kGyk","f8b82b80838a213":"cdRwn","ed4354d675fc156":"7U14B","592184e7162c72dc":"ezFly"}],"7U14B":[function(require,module,exports) {
"use strict";
var Howler = void 0;
if (typeof window !== "undefined") Howler = require("83d0f53a748f1389");
module.exports = Howler;

},{"83d0f53a748f1389":"aAg6H"}],"aAg6H":[function(require,module,exports) {
var global = arguments[3];
/*!
 *  howler.js v2.2.3
 *  howlerjs.com
 *
 *  (c) 2013-2020, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */ (function() {
    "use strict";
    /** Global Methods **/ /***************************************************************************/ /**
   * Create the global controller. All contained methods and properties apply
   * to all sounds that are currently playing or will be in the future.
   */ var HowlerGlobal1 = function() {
        this.init();
    };
    HowlerGlobal1.prototype = {
        /**
     * Initialize the global Howler object.
     * @return {Howler}
     */ init: function() {
            var self = this || Howler1;
            // Create a global ID counter.
            self._counter = 1000;
            // Pool of unlocked HTML5 Audio objects.
            self._html5AudioPool = [];
            self.html5PoolSize = 10;
            // Internal properties.
            self._codecs = {};
            self._howls = [];
            self._muted = false;
            self._volume = 1;
            self._canPlayEvent = "canplaythrough";
            self._navigator = typeof window !== "undefined" && window.navigator ? window.navigator : null;
            // Public properties.
            self.masterGain = null;
            self.noAudio = false;
            self.usingWebAudio = true;
            self.autoSuspend = true;
            self.ctx = null;
            // Set to false to disable the auto audio unlocker.
            self.autoUnlock = true;
            // Setup the various state values for global tracking.
            self._setup();
            return self;
        },
        /**
     * Get/set the global volume for all sounds.
     * @param  {Float} vol Volume from 0.0 to 1.0.
     * @return {Howler/Float}     Returns self or current volume.
     */ volume: function(vol) {
            var self = this || Howler1;
            vol = parseFloat(vol);
            // If we don't have an AudioContext created yet, run the setup.
            if (!self.ctx) setupAudioContext();
            if (typeof vol !== "undefined" && vol >= 0 && vol <= 1) {
                self._volume = vol;
                // Don't update any of the nodes if we are muted.
                if (self._muted) return self;
                // When using Web Audio, we just need to adjust the master gain.
                if (self.usingWebAudio) self.masterGain.gain.setValueAtTime(vol, Howler1.ctx.currentTime);
                // Loop through and change volume for all HTML5 audio nodes.
                for(var i = 0; i < self._howls.length; i++)if (!self._howls[i]._webAudio) {
                    // Get all of the sounds in this Howl group.
                    var ids = self._howls[i]._getSoundIds();
                    // Loop through all sounds and change the volumes.
                    for(var j = 0; j < ids.length; j++){
                        var sound = self._howls[i]._soundById(ids[j]);
                        if (sound && sound._node) sound._node.volume = sound._volume * vol;
                    }
                }
                return self;
            }
            return self._volume;
        },
        /**
     * Handle muting and unmuting globally.
     * @param  {Boolean} muted Is muted or not.
     */ mute: function(muted) {
            var self = this || Howler1;
            // If we don't have an AudioContext created yet, run the setup.
            if (!self.ctx) setupAudioContext();
            self._muted = muted;
            // With Web Audio, we just need to mute the master gain.
            if (self.usingWebAudio) self.masterGain.gain.setValueAtTime(muted ? 0 : self._volume, Howler1.ctx.currentTime);
            // Loop through and mute all HTML5 Audio nodes.
            for(var i = 0; i < self._howls.length; i++)if (!self._howls[i]._webAudio) {
                // Get all of the sounds in this Howl group.
                var ids = self._howls[i]._getSoundIds();
                // Loop through all sounds and mark the audio node as muted.
                for(var j = 0; j < ids.length; j++){
                    var sound = self._howls[i]._soundById(ids[j]);
                    if (sound && sound._node) sound._node.muted = muted ? true : sound._muted;
                }
            }
            return self;
        },
        /**
     * Handle stopping all sounds globally.
     */ stop: function() {
            var self = this || Howler1;
            // Loop through all Howls and stop them.
            for(var i = 0; i < self._howls.length; i++)self._howls[i].stop();
            return self;
        },
        /**
     * Unload and destroy all currently loaded Howl objects.
     * @return {Howler}
     */ unload: function() {
            var self = this || Howler1;
            for(var i = self._howls.length - 1; i >= 0; i--)self._howls[i].unload();
            // Create a new AudioContext to make sure it is fully reset.
            if (self.usingWebAudio && self.ctx && typeof self.ctx.close !== "undefined") {
                self.ctx.close();
                self.ctx = null;
                setupAudioContext();
            }
            return self;
        },
        /**
     * Check for codec support of specific extension.
     * @param  {String} ext Audio file extention.
     * @return {Boolean}
     */ codecs: function(ext) {
            return (this || Howler1)._codecs[ext.replace(/^x-/, "")];
        },
        /**
     * Setup various state values for global tracking.
     * @return {Howler}
     */ _setup: function() {
            var self = this || Howler1;
            // Keeps track of the suspend/resume state of the AudioContext.
            self.state = self.ctx ? self.ctx.state || "suspended" : "suspended";
            // Automatically begin the 30-second suspend process
            self._autoSuspend();
            // Check if audio is available.
            if (!self.usingWebAudio) {
                // No audio is available on this system if noAudio is set to true.
                if (typeof Audio !== "undefined") try {
                    var test = new Audio();
                    // Check if the canplaythrough event is available.
                    if (typeof test.oncanplaythrough === "undefined") self._canPlayEvent = "canplay";
                } catch (e) {
                    self.noAudio = true;
                }
                else self.noAudio = true;
            }
            // Test to make sure audio isn't disabled in Internet Explorer.
            try {
                var test = new Audio();
                if (test.muted) self.noAudio = true;
            } catch (e) {}
            // Check for supported codecs.
            if (!self.noAudio) self._setupCodecs();
            return self;
        },
        /**
     * Check for browser support for various codecs and cache the results.
     * @return {Howler}
     */ _setupCodecs: function() {
            var self = this || Howler1;
            var audioTest = null;
            // Must wrap in a try/catch because IE11 in server mode throws an error.
            try {
                audioTest = typeof Audio !== "undefined" ? new Audio() : null;
            } catch (err) {
                return self;
            }
            if (!audioTest || typeof audioTest.canPlayType !== "function") return self;
            var mpegTest = audioTest.canPlayType("audio/mpeg;").replace(/^no$/, "");
            // Opera version <33 has mixed MP3 support, so we need to check for and block it.
            var ua = self._navigator ? self._navigator.userAgent : "";
            var checkOpera = ua.match(/OPR\/([0-6].)/g);
            var isOldOpera = checkOpera && parseInt(checkOpera[0].split("/")[1], 10) < 33;
            var checkSafari = ua.indexOf("Safari") !== -1 && ua.indexOf("Chrome") === -1;
            var safariVersion = ua.match(/Version\/(.*?) /);
            var isOldSafari = checkSafari && safariVersion && parseInt(safariVersion[1], 10) < 15;
            self._codecs = {
                mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType("audio/mp3;").replace(/^no$/, ""))),
                mpeg: !!mpegTest,
                opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
                ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                oga: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                wav: !!(audioTest.canPlayType('audio/wav; codecs="1"') || audioTest.canPlayType("audio/wav")).replace(/^no$/, ""),
                aac: !!audioTest.canPlayType("audio/aac;").replace(/^no$/, ""),
                caf: !!audioTest.canPlayType("audio/x-caf;").replace(/^no$/, ""),
                m4a: !!(audioTest.canPlayType("audio/x-m4a;") || audioTest.canPlayType("audio/m4a;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
                m4b: !!(audioTest.canPlayType("audio/x-m4b;") || audioTest.canPlayType("audio/m4b;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
                mp4: !!(audioTest.canPlayType("audio/x-mp4;") || audioTest.canPlayType("audio/mp4;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
                weba: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
                webm: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
                dolby: !!audioTest.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
                flac: !!(audioTest.canPlayType("audio/x-flac;") || audioTest.canPlayType("audio/flac;")).replace(/^no$/, "")
            };
            return self;
        },
        /**
     * Some browsers/devices will only allow audio to be played after a user interaction.
     * Attempt to automatically unlock audio on the first user interaction.
     * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/
     * @return {Howler}
     */ _unlockAudio: function() {
            var self = this || Howler1;
            // Only run this if Web Audio is supported and it hasn't already been unlocked.
            if (self._audioUnlocked || !self.ctx) return;
            self._audioUnlocked = false;
            self.autoUnlock = false;
            // Some mobile devices/platforms have distortion issues when opening/closing tabs and/or web views.
            // Bugs in the browser (especially Mobile Safari) can cause the sampleRate to change from 44100 to 48000.
            // By calling Howler.unload(), we create a new AudioContext with the correct sampleRate.
            if (!self._mobileUnloaded && self.ctx.sampleRate !== 44100) {
                self._mobileUnloaded = true;
                self.unload();
            }
            // Scratch buffer for enabling iOS to dispose of web audio buffers correctly, as per:
            // http://stackoverflow.com/questions/24119684
            self._scratchBuffer = self.ctx.createBuffer(1, 1, 22050);
            // Call this method on touch start to create and play a buffer,
            // then check if the audio actually played to determine if
            // audio has now been unlocked on iOS, Android, etc.
            var unlock = function(e) {
                // Create a pool of unlocked HTML5 Audio objects that can
                // be used for playing sounds without user interaction. HTML5
                // Audio objects must be individually unlocked, as opposed
                // to the WebAudio API which only needs a single activation.
                // This must occur before WebAudio setup or the source.onended
                // event will not fire.
                while(self._html5AudioPool.length < self.html5PoolSize)try {
                    var audioNode = new Audio();
                    // Mark this Audio object as unlocked to ensure it can get returned
                    // to the unlocked pool when released.
                    audioNode._unlocked = true;
                    // Add the audio node to the pool.
                    self._releaseHtml5Audio(audioNode);
                } catch (e) {
                    self.noAudio = true;
                    break;
                }
                // Loop through any assigned audio nodes and unlock them.
                for(var i = 0; i < self._howls.length; i++)if (!self._howls[i]._webAudio) {
                    // Get all of the sounds in this Howl group.
                    var ids = self._howls[i]._getSoundIds();
                    // Loop through all sounds and unlock the audio nodes.
                    for(var j = 0; j < ids.length; j++){
                        var sound = self._howls[i]._soundById(ids[j]);
                        if (sound && sound._node && !sound._node._unlocked) {
                            sound._node._unlocked = true;
                            sound._node.load();
                        }
                    }
                }
                // Fix Android can not play in suspend state.
                self._autoResume();
                // Create an empty buffer.
                var source = self.ctx.createBufferSource();
                source.buffer = self._scratchBuffer;
                source.connect(self.ctx.destination);
                // Play the empty buffer.
                if (typeof source.start === "undefined") source.noteOn(0);
                else source.start(0);
                // Calling resume() on a stack initiated by user gesture is what actually unlocks the audio on Android Chrome >= 55.
                if (typeof self.ctx.resume === "function") self.ctx.resume();
                // Setup a timeout to check that we are unlocked on the next event loop.
                source.onended = function() {
                    source.disconnect(0);
                    // Update the unlocked state and prevent this check from happening again.
                    self._audioUnlocked = true;
                    // Remove the touch start listener.
                    document.removeEventListener("touchstart", unlock, true);
                    document.removeEventListener("touchend", unlock, true);
                    document.removeEventListener("click", unlock, true);
                    document.removeEventListener("keydown", unlock, true);
                    // Let all sounds know that audio has been unlocked.
                    for(var i = 0; i < self._howls.length; i++)self._howls[i]._emit("unlock");
                };
            };
            // Setup a touch start listener to attempt an unlock in.
            document.addEventListener("touchstart", unlock, true);
            document.addEventListener("touchend", unlock, true);
            document.addEventListener("click", unlock, true);
            document.addEventListener("keydown", unlock, true);
            return self;
        },
        /**
     * Get an unlocked HTML5 Audio object from the pool. If none are left,
     * return a new Audio object and throw a warning.
     * @return {Audio} HTML5 Audio object.
     */ _obtainHtml5Audio: function() {
            var self = this || Howler1;
            // Return the next object from the pool if one exists.
            if (self._html5AudioPool.length) return self._html5AudioPool.pop();
            //.Check if the audio is locked and throw a warning.
            var testPlay = new Audio().play();
            if (testPlay && typeof Promise !== "undefined" && (testPlay instanceof Promise || typeof testPlay.then === "function")) testPlay.catch(function() {
                console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.");
            });
            return new Audio();
        },
        /**
     * Return an activated HTML5 Audio object to the pool.
     * @return {Howler}
     */ _releaseHtml5Audio: function(audio) {
            var self = this || Howler1;
            // Don't add audio to the pool if we don't know if it has been unlocked.
            if (audio._unlocked) self._html5AudioPool.push(audio);
            return self;
        },
        /**
     * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.
     * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.
     * @return {Howler}
     */ _autoSuspend: function() {
            var self = this;
            if (!self.autoSuspend || !self.ctx || typeof self.ctx.suspend === "undefined" || !Howler1.usingWebAudio) return;
            // Check if any sounds are playing.
            for(var i = 0; i < self._howls.length; i++){
                if (self._howls[i]._webAudio) for(var j = 0; j < self._howls[i]._sounds.length; j++){
                    if (!self._howls[i]._sounds[j]._paused) return self;
                }
            }
            if (self._suspendTimer) clearTimeout(self._suspendTimer);
            // If no sound has played after 30 seconds, suspend the context.
            self._suspendTimer = setTimeout(function() {
                if (!self.autoSuspend) return;
                self._suspendTimer = null;
                self.state = "suspending";
                // Handle updating the state of the audio context after suspending.
                var handleSuspension = function() {
                    self.state = "suspended";
                    if (self._resumeAfterSuspend) {
                        delete self._resumeAfterSuspend;
                        self._autoResume();
                    }
                };
                // Either the state gets suspended or it is interrupted.
                // Either way, we need to update the state to suspended.
                self.ctx.suspend().then(handleSuspension, handleSuspension);
            }, 30000);
            return self;
        },
        /**
     * Automatically resume the Web Audio AudioContext when a new sound is played.
     * @return {Howler}
     */ _autoResume: function() {
            var self = this;
            if (!self.ctx || typeof self.ctx.resume === "undefined" || !Howler1.usingWebAudio) return;
            if (self.state === "running" && self.ctx.state !== "interrupted" && self._suspendTimer) {
                clearTimeout(self._suspendTimer);
                self._suspendTimer = null;
            } else if (self.state === "suspended" || self.state === "running" && self.ctx.state === "interrupted") {
                self.ctx.resume().then(function() {
                    self.state = "running";
                    // Emit to all Howls that the audio has resumed.
                    for(var i = 0; i < self._howls.length; i++)self._howls[i]._emit("resume");
                });
                if (self._suspendTimer) {
                    clearTimeout(self._suspendTimer);
                    self._suspendTimer = null;
                }
            } else if (self.state === "suspending") self._resumeAfterSuspend = true;
            return self;
        }
    };
    // Setup the global audio controller.
    var Howler1 = new HowlerGlobal1();
    /** Group Methods **/ /***************************************************************************/ /**
   * Create an audio group controller.
   * @param {Object} o Passed in properties for this group.
   */ var Howl1 = function(o) {
        var self = this;
        // Throw an error if no source is provided.
        if (!o.src || o.src.length === 0) {
            console.error("An array of source files must be passed with any new Howl.");
            return;
        }
        self.init(o);
    };
    Howl1.prototype = {
        /**
     * Initialize a new Howl group object.
     * @param  {Object} o Passed in properties for this group.
     * @return {Howl}
     */ init: function(o) {
            var self = this;
            // If we don't have an AudioContext created yet, run the setup.
            if (!Howler1.ctx) setupAudioContext();
            // Setup user-defined default properties.
            self._autoplay = o.autoplay || false;
            self._format = typeof o.format !== "string" ? o.format : [
                o.format
            ];
            self._html5 = o.html5 || false;
            self._muted = o.mute || false;
            self._loop = o.loop || false;
            self._pool = o.pool || 5;
            self._preload = typeof o.preload === "boolean" || o.preload === "metadata" ? o.preload : true;
            self._rate = o.rate || 1;
            self._sprite = o.sprite || {};
            self._src = typeof o.src !== "string" ? o.src : [
                o.src
            ];
            self._volume = o.volume !== undefined ? o.volume : 1;
            self._xhr = {
                method: o.xhr && o.xhr.method ? o.xhr.method : "GET",
                headers: o.xhr && o.xhr.headers ? o.xhr.headers : null,
                withCredentials: o.xhr && o.xhr.withCredentials ? o.xhr.withCredentials : false
            };
            // Setup all other default properties.
            self._duration = 0;
            self._state = "unloaded";
            self._sounds = [];
            self._endTimers = {};
            self._queue = [];
            self._playLock = false;
            // Setup event listeners.
            self._onend = o.onend ? [
                {
                    fn: o.onend
                }
            ] : [];
            self._onfade = o.onfade ? [
                {
                    fn: o.onfade
                }
            ] : [];
            self._onload = o.onload ? [
                {
                    fn: o.onload
                }
            ] : [];
            self._onloaderror = o.onloaderror ? [
                {
                    fn: o.onloaderror
                }
            ] : [];
            self._onplayerror = o.onplayerror ? [
                {
                    fn: o.onplayerror
                }
            ] : [];
            self._onpause = o.onpause ? [
                {
                    fn: o.onpause
                }
            ] : [];
            self._onplay = o.onplay ? [
                {
                    fn: o.onplay
                }
            ] : [];
            self._onstop = o.onstop ? [
                {
                    fn: o.onstop
                }
            ] : [];
            self._onmute = o.onmute ? [
                {
                    fn: o.onmute
                }
            ] : [];
            self._onvolume = o.onvolume ? [
                {
                    fn: o.onvolume
                }
            ] : [];
            self._onrate = o.onrate ? [
                {
                    fn: o.onrate
                }
            ] : [];
            self._onseek = o.onseek ? [
                {
                    fn: o.onseek
                }
            ] : [];
            self._onunlock = o.onunlock ? [
                {
                    fn: o.onunlock
                }
            ] : [];
            self._onresume = [];
            // Web Audio or HTML5 Audio?
            self._webAudio = Howler1.usingWebAudio && !self._html5;
            // Automatically try to enable audio.
            if (typeof Howler1.ctx !== "undefined" && Howler1.ctx && Howler1.autoUnlock) Howler1._unlockAudio();
            // Keep track of this Howl group in the global controller.
            Howler1._howls.push(self);
            // If they selected autoplay, add a play event to the load queue.
            if (self._autoplay) self._queue.push({
                event: "play",
                action: function() {
                    self.play();
                }
            });
            // Load the source file unless otherwise specified.
            if (self._preload && self._preload !== "none") self.load();
            return self;
        },
        /**
     * Load the audio file.
     * @return {Howler}
     */ load: function() {
            var self = this;
            var url = null;
            // If no audio is available, quit immediately.
            if (Howler1.noAudio) {
                self._emit("loaderror", null, "No audio support.");
                return;
            }
            // Make sure our source is in an array.
            if (typeof self._src === "string") self._src = [
                self._src
            ];
            // Loop through the sources and pick the first one that is compatible.
            for(var i = 0; i < self._src.length; i++){
                var ext, str;
                if (self._format && self._format[i]) // If an extension was specified, use that instead.
                ext = self._format[i];
                else {
                    // Make sure the source is a string.
                    str = self._src[i];
                    if (typeof str !== "string") {
                        self._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
                        continue;
                    }
                    // Extract the file extension from the URL or base64 data URI.
                    ext = /^data:audio\/([^;,]+);/i.exec(str);
                    if (!ext) ext = /\.([^.]+)$/.exec(str.split("?", 1)[0]);
                    if (ext) ext = ext[1].toLowerCase();
                }
                // Log a warning if no extension was found.
                if (!ext) console.warn('No file extension was found. Consider using the "format" property or specify an extension.');
                // Check if this extension is available.
                if (ext && Howler1.codecs(ext)) {
                    url = self._src[i];
                    break;
                }
            }
            if (!url) {
                self._emit("loaderror", null, "No codec support for selected audio sources.");
                return;
            }
            self._src = url;
            self._state = "loading";
            // If the hosting page is HTTPS and the source isn't,
            // drop down to HTML5 Audio to avoid Mixed Content errors.
            if (window.location.protocol === "https:" && url.slice(0, 5) === "http:") {
                self._html5 = true;
                self._webAudio = false;
            }
            // Create a new sound object and add it to the pool.
            new Sound1(self);
            // Load and decode the audio data for playback.
            if (self._webAudio) loadBuffer(self);
            return self;
        },
        /**
     * Play a sound or resume previous playback.
     * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.
     * @param  {Boolean} internal Internal Use: true prevents event firing.
     * @return {Number}          Sound ID.
     */ play: function(sprite, internal) {
            var self = this;
            var id = null;
            // Determine if a sprite, sound id or nothing was passed
            if (typeof sprite === "number") {
                id = sprite;
                sprite = null;
            } else if (typeof sprite === "string" && self._state === "loaded" && !self._sprite[sprite]) // If the passed sprite doesn't exist, do nothing.
            return null;
            else if (typeof sprite === "undefined") {
                // Use the default sound sprite (plays the full audio length).
                sprite = "__default";
                // Check if there is a single paused sound that isn't ended.
                // If there is, play that sound. If not, continue as usual.
                if (!self._playLock) {
                    var num = 0;
                    for(var i = 0; i < self._sounds.length; i++)if (self._sounds[i]._paused && !self._sounds[i]._ended) {
                        num++;
                        id = self._sounds[i]._id;
                    }
                    if (num === 1) sprite = null;
                    else id = null;
                }
            }
            // Get the selected node, or get one from the pool.
            var sound = id ? self._soundById(id) : self._inactiveSound();
            // If the sound doesn't exist, do nothing.
            if (!sound) return null;
            // Select the sprite definition.
            if (id && !sprite) sprite = sound._sprite || "__default";
            // If the sound hasn't loaded, we must wait to get the audio's duration.
            // We also need to wait to make sure we don't run into race conditions with
            // the order of function calls.
            if (self._state !== "loaded") {
                // Set the sprite value on this sound.
                sound._sprite = sprite;
                // Mark this sound as not ended in case another sound is played before this one loads.
                sound._ended = false;
                // Add the sound to the queue to be played on load.
                var soundId = sound._id;
                self._queue.push({
                    event: "play",
                    action: function() {
                        self.play(soundId);
                    }
                });
                return soundId;
            }
            // Don't play the sound if an id was passed and it is already playing.
            if (id && !sound._paused) {
                // Trigger the play event, in order to keep iterating through queue.
                if (!internal) self._loadQueue("play");
                return sound._id;
            }
            // Make sure the AudioContext isn't suspended, and resume it if it is.
            if (self._webAudio) Howler1._autoResume();
            // Determine how long to play for and where to start playing.
            var seek = Math.max(0, sound._seek > 0 ? sound._seek : self._sprite[sprite][0] / 1000);
            var duration = Math.max(0, (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000 - seek);
            var timeout = duration * 1000 / Math.abs(sound._rate);
            var start = self._sprite[sprite][0] / 1000;
            var stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000;
            sound._sprite = sprite;
            // Mark the sound as ended instantly so that this async playback
            // doesn't get grabbed by another call to play while this one waits to start.
            sound._ended = false;
            // Update the parameters of the sound.
            var setParams = function() {
                sound._paused = false;
                sound._seek = seek;
                sound._start = start;
                sound._stop = stop;
                sound._loop = !!(sound._loop || self._sprite[sprite][2]);
            };
            // End the sound instantly if seek is at the end.
            if (seek >= stop) {
                self._ended(sound);
                return;
            }
            // Begin the actual playback.
            var node = sound._node;
            if (self._webAudio) {
                // Fire this when the sound is ready to play to begin Web Audio playback.
                var playWebAudio = function() {
                    self._playLock = false;
                    setParams();
                    self._refreshBuffer(sound);
                    // Setup the playback params.
                    var vol = sound._muted || self._muted ? 0 : sound._volume;
                    node.gain.setValueAtTime(vol, Howler1.ctx.currentTime);
                    sound._playStart = Howler1.ctx.currentTime;
                    // Play the sound using the supported method.
                    if (typeof node.bufferSource.start === "undefined") sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);
                    else sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);
                    // Start a new timer if none is present.
                    if (timeout !== Infinity) self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
                    if (!internal) setTimeout(function() {
                        self._emit("play", sound._id);
                        self._loadQueue();
                    }, 0);
                };
                if (Howler1.state === "running" && Howler1.ctx.state !== "interrupted") playWebAudio();
                else {
                    self._playLock = true;
                    // Wait for the audio context to resume before playing.
                    self.once("resume", playWebAudio);
                    // Cancel the end timer.
                    self._clearTimer(sound._id);
                }
            } else {
                // Fire this when the sound is ready to play to begin HTML5 Audio playback.
                var playHtml5 = function() {
                    node.currentTime = seek;
                    node.muted = sound._muted || self._muted || Howler1._muted || node.muted;
                    node.volume = sound._volume * Howler1.volume();
                    node.playbackRate = sound._rate;
                    // Some browsers will throw an error if this is called without user interaction.
                    try {
                        var play = node.play();
                        // Support older browsers that don't support promises, and thus don't have this issue.
                        if (play && typeof Promise !== "undefined" && (play instanceof Promise || typeof play.then === "function")) {
                            // Implements a lock to prevent DOMException: The play() request was interrupted by a call to pause().
                            self._playLock = true;
                            // Set param values immediately.
                            setParams();
                            // Releases the lock and executes queued actions.
                            play.then(function() {
                                self._playLock = false;
                                node._unlocked = true;
                                if (!internal) self._emit("play", sound._id);
                                else self._loadQueue();
                            }).catch(function() {
                                self._playLock = false;
                                self._emit("playerror", sound._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                                // Reset the ended and paused values.
                                sound._ended = true;
                                sound._paused = true;
                            });
                        } else if (!internal) {
                            self._playLock = false;
                            setParams();
                            self._emit("play", sound._id);
                        }
                        // Setting rate before playing won't work in IE, so we set it again here.
                        node.playbackRate = sound._rate;
                        // If the node is still paused, then we can assume there was a playback issue.
                        if (node.paused) {
                            self._emit("playerror", sound._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                            return;
                        }
                        // Setup the end timer on sprites or listen for the ended event.
                        if (sprite !== "__default" || sound._loop) self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
                        else {
                            self._endTimers[sound._id] = function() {
                                // Fire ended on this audio node.
                                self._ended(sound);
                                // Clear this listener.
                                node.removeEventListener("ended", self._endTimers[sound._id], false);
                            };
                            node.addEventListener("ended", self._endTimers[sound._id], false);
                        }
                    } catch (err) {
                        self._emit("playerror", sound._id, err);
                    }
                };
                // If this is streaming audio, make sure the src is set and load again.
                if (node.src === "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA") {
                    node.src = self._src;
                    node.load();
                }
                // Play immediately if ready, or wait for the 'canplaythrough'e vent.
                var loadedNoReadyState = window && window.ejecta || !node.readyState && Howler1._navigator.isCocoonJS;
                if (node.readyState >= 3 || loadedNoReadyState) playHtml5();
                else {
                    self._playLock = true;
                    self._state = "loading";
                    var listener = function() {
                        self._state = "loaded";
                        // Begin playback.
                        playHtml5();
                        // Clear this listener.
                        node.removeEventListener(Howler1._canPlayEvent, listener, false);
                    };
                    node.addEventListener(Howler1._canPlayEvent, listener, false);
                    // Cancel the end timer.
                    self._clearTimer(sound._id);
                }
            }
            return sound._id;
        },
        /**
     * Pause playback and save current position.
     * @param  {Number} id The sound ID (empty to pause all in group).
     * @return {Howl}
     */ pause: function(id) {
            var self = this;
            // If the sound hasn't loaded or a play() promise is pending, add it to the load queue to pause when capable.
            if (self._state !== "loaded" || self._playLock) {
                self._queue.push({
                    event: "pause",
                    action: function() {
                        self.pause(id);
                    }
                });
                return self;
            }
            // If no id is passed, get all ID's to be paused.
            var ids = self._getSoundIds(id);
            for(var i = 0; i < ids.length; i++){
                // Clear the end timer.
                self._clearTimer(ids[i]);
                // Get the sound.
                var sound = self._soundById(ids[i]);
                if (sound && !sound._paused) {
                    // Reset the seek position.
                    sound._seek = self.seek(ids[i]);
                    sound._rateSeek = 0;
                    sound._paused = true;
                    // Stop currently running fades.
                    self._stopFade(ids[i]);
                    if (sound._node) {
                        if (self._webAudio) {
                            // Make sure the sound has been created.
                            if (!sound._node.bufferSource) continue;
                            if (typeof sound._node.bufferSource.stop === "undefined") sound._node.bufferSource.noteOff(0);
                            else sound._node.bufferSource.stop(0);
                            // Clean up the buffer source.
                            self._cleanBuffer(sound._node);
                        } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) sound._node.pause();
                    }
                }
                // Fire the pause event, unless `true` is passed as the 2nd argument.
                if (!arguments[1]) self._emit("pause", sound ? sound._id : null);
            }
            return self;
        },
        /**
     * Stop playback and reset to start.
     * @param  {Number} id The sound ID (empty to stop all in group).
     * @param  {Boolean} internal Internal Use: true prevents event firing.
     * @return {Howl}
     */ stop: function(id, internal) {
            var self = this;
            // If the sound hasn't loaded, add it to the load queue to stop when capable.
            if (self._state !== "loaded" || self._playLock) {
                self._queue.push({
                    event: "stop",
                    action: function() {
                        self.stop(id);
                    }
                });
                return self;
            }
            // If no id is passed, get all ID's to be stopped.
            var ids = self._getSoundIds(id);
            for(var i = 0; i < ids.length; i++){
                // Clear the end timer.
                self._clearTimer(ids[i]);
                // Get the sound.
                var sound = self._soundById(ids[i]);
                if (sound) {
                    // Reset the seek position.
                    sound._seek = sound._start || 0;
                    sound._rateSeek = 0;
                    sound._paused = true;
                    sound._ended = true;
                    // Stop currently running fades.
                    self._stopFade(ids[i]);
                    if (sound._node) {
                        if (self._webAudio) // Make sure the sound's AudioBufferSourceNode has been created.
                        {
                            if (sound._node.bufferSource) {
                                if (typeof sound._node.bufferSource.stop === "undefined") sound._node.bufferSource.noteOff(0);
                                else sound._node.bufferSource.stop(0);
                                // Clean up the buffer source.
                                self._cleanBuffer(sound._node);
                            }
                        } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
                            sound._node.currentTime = sound._start || 0;
                            sound._node.pause();
                            // If this is a live stream, stop download once the audio is stopped.
                            if (sound._node.duration === Infinity) self._clearSound(sound._node);
                        }
                    }
                    if (!internal) self._emit("stop", sound._id);
                }
            }
            return self;
        },
        /**
     * Mute/unmute a single sound or all sounds in this Howl group.
     * @param  {Boolean} muted Set to true to mute and false to unmute.
     * @param  {Number} id    The sound ID to update (omit to mute/unmute all).
     * @return {Howl}
     */ mute: function(muted, id) {
            var self = this;
            // If the sound hasn't loaded, add it to the load queue to mute when capable.
            if (self._state !== "loaded" || self._playLock) {
                self._queue.push({
                    event: "mute",
                    action: function() {
                        self.mute(muted, id);
                    }
                });
                return self;
            }
            // If applying mute/unmute to all sounds, update the group's value.
            if (typeof id === "undefined") {
                if (typeof muted === "boolean") self._muted = muted;
                else return self._muted;
            }
            // If no id is passed, get all ID's to be muted.
            var ids = self._getSoundIds(id);
            for(var i = 0; i < ids.length; i++){
                // Get the sound.
                var sound = self._soundById(ids[i]);
                if (sound) {
                    sound._muted = muted;
                    // Cancel active fade and set the volume to the end value.
                    if (sound._interval) self._stopFade(sound._id);
                    if (self._webAudio && sound._node) sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler1.ctx.currentTime);
                    else if (sound._node) sound._node.muted = Howler1._muted ? true : muted;
                    self._emit("mute", sound._id);
                }
            }
            return self;
        },
        /**
     * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.
     *   volume() -> Returns the group's volume value.
     *   volume(id) -> Returns the sound id's current volume.
     *   volume(vol) -> Sets the volume of all sounds in this Howl group.
     *   volume(vol, id) -> Sets the volume of passed sound id.
     * @return {Howl/Number} Returns self or current volume.
     */ volume: function() {
            var self = this;
            var args = arguments;
            var vol, id;
            // Determine the values based on arguments.
            if (args.length === 0) // Return the value of the groups' volume.
            return self._volume;
            else if (args.length === 1 || args.length === 2 && typeof args[1] === "undefined") {
                // First check if this is an ID, and if not, assume it is a new volume.
                var ids = self._getSoundIds();
                var index = ids.indexOf(args[0]);
                if (index >= 0) id = parseInt(args[0], 10);
                else vol = parseFloat(args[0]);
            } else if (args.length >= 2) {
                vol = parseFloat(args[0]);
                id = parseInt(args[1], 10);
            }
            // Update the volume or return the current volume.
            var sound;
            if (typeof vol !== "undefined" && vol >= 0 && vol <= 1) {
                // If the sound hasn't loaded, add it to the load queue to change volume when capable.
                if (self._state !== "loaded" || self._playLock) {
                    self._queue.push({
                        event: "volume",
                        action: function() {
                            self.volume.apply(self, args);
                        }
                    });
                    return self;
                }
                // Set the group volume.
                if (typeof id === "undefined") self._volume = vol;
                // Update one or all volumes.
                id = self._getSoundIds(id);
                for(var i = 0; i < id.length; i++){
                    // Get the sound.
                    sound = self._soundById(id[i]);
                    if (sound) {
                        sound._volume = vol;
                        // Stop currently running fades.
                        if (!args[2]) self._stopFade(id[i]);
                        if (self._webAudio && sound._node && !sound._muted) sound._node.gain.setValueAtTime(vol, Howler1.ctx.currentTime);
                        else if (sound._node && !sound._muted) sound._node.volume = vol * Howler1.volume();
                        self._emit("volume", sound._id);
                    }
                }
            } else {
                sound = id ? self._soundById(id) : self._sounds[0];
                return sound ? sound._volume : 0;
            }
            return self;
        },
        /**
     * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).
     * @param  {Number} from The value to fade from (0.0 to 1.0).
     * @param  {Number} to   The volume to fade to (0.0 to 1.0).
     * @param  {Number} len  Time in milliseconds to fade.
     * @param  {Number} id   The sound id (omit to fade all sounds).
     * @return {Howl}
     */ fade: function(from, to, len, id) {
            var self = this;
            // If the sound hasn't loaded, add it to the load queue to fade when capable.
            if (self._state !== "loaded" || self._playLock) {
                self._queue.push({
                    event: "fade",
                    action: function() {
                        self.fade(from, to, len, id);
                    }
                });
                return self;
            }
            // Make sure the to/from/len values are numbers.
            from = Math.min(Math.max(0, parseFloat(from)), 1);
            to = Math.min(Math.max(0, parseFloat(to)), 1);
            len = parseFloat(len);
            // Set the volume to the start position.
            self.volume(from, id);
            // Fade the volume of one or all sounds.
            var ids = self._getSoundIds(id);
            for(var i = 0; i < ids.length; i++){
                // Get the sound.
                var sound = self._soundById(ids[i]);
                // Create a linear fade or fall back to timeouts with HTML5 Audio.
                if (sound) {
                    // Stop the previous fade if no sprite is being used (otherwise, volume handles this).
                    if (!id) self._stopFade(ids[i]);
                    // If we are using Web Audio, let the native methods do the actual fade.
                    if (self._webAudio && !sound._muted) {
                        var currentTime = Howler1.ctx.currentTime;
                        var end = currentTime + len / 1000;
                        sound._volume = from;
                        sound._node.gain.setValueAtTime(from, currentTime);
                        sound._node.gain.linearRampToValueAtTime(to, end);
                    }
                    self._startFadeInterval(sound, from, to, len, ids[i], typeof id === "undefined");
                }
            }
            return self;
        },
        /**
     * Starts the internal interval to fade a sound.
     * @param  {Object} sound Reference to sound to fade.
     * @param  {Number} from The value to fade from (0.0 to 1.0).
     * @param  {Number} to   The volume to fade to (0.0 to 1.0).
     * @param  {Number} len  Time in milliseconds to fade.
     * @param  {Number} id   The sound id to fade.
     * @param  {Boolean} isGroup   If true, set the volume on the group.
     */ _startFadeInterval: function(sound, from, to, len, id, isGroup) {
            var self = this;
            var vol = from;
            var diff = to - from;
            var steps = Math.abs(diff / 0.01);
            var stepLen = Math.max(4, steps > 0 ? len / steps : len);
            var lastTick = Date.now();
            // Store the value being faded to.
            sound._fadeTo = to;
            // Update the volume value on each interval tick.
            sound._interval = setInterval(function() {
                // Update the volume based on the time since the last tick.
                var tick = (Date.now() - lastTick) / len;
                lastTick = Date.now();
                vol += diff * tick;
                // Round to within 2 decimal points.
                vol = Math.round(vol * 100) / 100;
                // Make sure the volume is in the right bounds.
                if (diff < 0) vol = Math.max(to, vol);
                else vol = Math.min(to, vol);
                // Change the volume.
                if (self._webAudio) sound._volume = vol;
                else self.volume(vol, sound._id, true);
                // Set the group's volume.
                if (isGroup) self._volume = vol;
                // When the fade is complete, stop it and fire event.
                if (to < from && vol <= to || to > from && vol >= to) {
                    clearInterval(sound._interval);
                    sound._interval = null;
                    sound._fadeTo = null;
                    self.volume(to, sound._id);
                    self._emit("fade", sound._id);
                }
            }, stepLen);
        },
        /**
     * Internal method that stops the currently playing fade when
     * a new fade starts, volume is changed or the sound is stopped.
     * @param  {Number} id The sound id.
     * @return {Howl}
     */ _stopFade: function(id) {
            var self = this;
            var sound = self._soundById(id);
            if (sound && sound._interval) {
                if (self._webAudio) sound._node.gain.cancelScheduledValues(Howler1.ctx.currentTime);
                clearInterval(sound._interval);
                sound._interval = null;
                self.volume(sound._fadeTo, id);
                sound._fadeTo = null;
                self._emit("fade", id);
            }
            return self;
        },
        /**
     * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.
     *   loop() -> Returns the group's loop value.
     *   loop(id) -> Returns the sound id's loop value.
     *   loop(loop) -> Sets the loop value for all sounds in this Howl group.
     *   loop(loop, id) -> Sets the loop value of passed sound id.
     * @return {Howl/Boolean} Returns self or current loop value.
     */ loop: function() {
            var self = this;
            var args = arguments;
            var loop, id, sound;
            // Determine the values for loop and id.
            if (args.length === 0) // Return the grou's loop value.
            return self._loop;
            else if (args.length === 1) {
                if (typeof args[0] === "boolean") {
                    loop = args[0];
                    self._loop = loop;
                } else {
                    // Return this sound's loop value.
                    sound = self._soundById(parseInt(args[0], 10));
                    return sound ? sound._loop : false;
                }
            } else if (args.length === 2) {
                loop = args[0];
                id = parseInt(args[1], 10);
            }
            // If no id is passed, get all ID's to be looped.
            var ids = self._getSoundIds(id);
            for(var i = 0; i < ids.length; i++){
                sound = self._soundById(ids[i]);
                if (sound) {
                    sound._loop = loop;
                    if (self._webAudio && sound._node && sound._node.bufferSource) {
                        sound._node.bufferSource.loop = loop;
                        if (loop) {
                            sound._node.bufferSource.loopStart = sound._start || 0;
                            sound._node.bufferSource.loopEnd = sound._stop;
                            // If playing, restart playback to ensure looping updates.
                            if (self.playing(ids[i])) {
                                self.pause(ids[i], true);
                                self.play(ids[i], true);
                            }
                        }
                    }
                }
            }
            return self;
        },
        /**
     * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.
     *   rate() -> Returns the first sound node's current playback rate.
     *   rate(id) -> Returns the sound id's current playback rate.
     *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.
     *   rate(rate, id) -> Sets the playback rate of passed sound id.
     * @return {Howl/Number} Returns self or the current playback rate.
     */ rate: function() {
            var self = this;
            var args = arguments;
            var rate, id;
            // Determine the values based on arguments.
            if (args.length === 0) // We will simply return the current rate of the first node.
            id = self._sounds[0]._id;
            else if (args.length === 1) {
                // First check if this is an ID, and if not, assume it is a new rate value.
                var ids = self._getSoundIds();
                var index = ids.indexOf(args[0]);
                if (index >= 0) id = parseInt(args[0], 10);
                else rate = parseFloat(args[0]);
            } else if (args.length === 2) {
                rate = parseFloat(args[0]);
                id = parseInt(args[1], 10);
            }
            // Update the playback rate or return the current value.
            var sound;
            if (typeof rate === "number") {
                // If the sound hasn't loaded, add it to the load queue to change playback rate when capable.
                if (self._state !== "loaded" || self._playLock) {
                    self._queue.push({
                        event: "rate",
                        action: function() {
                            self.rate.apply(self, args);
                        }
                    });
                    return self;
                }
                // Set the group rate.
                if (typeof id === "undefined") self._rate = rate;
                // Update one or all volumes.
                id = self._getSoundIds(id);
                for(var i = 0; i < id.length; i++){
                    // Get the sound.
                    sound = self._soundById(id[i]);
                    if (sound) {
                        // Keep track of our position when the rate changed and update the playback
                        // start position so we can properly adjust the seek position for time elapsed.
                        if (self.playing(id[i])) {
                            sound._rateSeek = self.seek(id[i]);
                            sound._playStart = self._webAudio ? Howler1.ctx.currentTime : sound._playStart;
                        }
                        sound._rate = rate;
                        // Change the playback rate.
                        if (self._webAudio && sound._node && sound._node.bufferSource) sound._node.bufferSource.playbackRate.setValueAtTime(rate, Howler1.ctx.currentTime);
                        else if (sound._node) sound._node.playbackRate = rate;
                        // Reset the timers.
                        var seek = self.seek(id[i]);
                        var duration = (self._sprite[sound._sprite][0] + self._sprite[sound._sprite][1]) / 1000 - seek;
                        var timeout = duration * 1000 / Math.abs(sound._rate);
                        // Start a new end timer if sound is already playing.
                        if (self._endTimers[id[i]] || !sound._paused) {
                            self._clearTimer(id[i]);
                            self._endTimers[id[i]] = setTimeout(self._ended.bind(self, sound), timeout);
                        }
                        self._emit("rate", sound._id);
                    }
                }
            } else {
                sound = self._soundById(id);
                return sound ? sound._rate : self._rate;
            }
            return self;
        },
        /**
     * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.
     *   seek() -> Returns the first sound node's current seek position.
     *   seek(id) -> Returns the sound id's current seek position.
     *   seek(seek) -> Sets the seek position of the first sound node.
     *   seek(seek, id) -> Sets the seek position of passed sound id.
     * @return {Howl/Number} Returns self or the current seek position.
     */ seek: function() {
            var self = this;
            var args = arguments;
            var seek, id;
            // Determine the values based on arguments.
            if (args.length === 0) // We will simply return the current position of the first node.
            {
                if (self._sounds.length) id = self._sounds[0]._id;
            } else if (args.length === 1) {
                // First check if this is an ID, and if not, assume it is a new seek position.
                var ids = self._getSoundIds();
                var index = ids.indexOf(args[0]);
                if (index >= 0) id = parseInt(args[0], 10);
                else if (self._sounds.length) {
                    id = self._sounds[0]._id;
                    seek = parseFloat(args[0]);
                }
            } else if (args.length === 2) {
                seek = parseFloat(args[0]);
                id = parseInt(args[1], 10);
            }
            // If there is no ID, bail out.
            if (typeof id === "undefined") return 0;
            // If the sound hasn't loaded, add it to the load queue to seek when capable.
            if (typeof seek === "number" && (self._state !== "loaded" || self._playLock)) {
                self._queue.push({
                    event: "seek",
                    action: function() {
                        self.seek.apply(self, args);
                    }
                });
                return self;
            }
            // Get the sound.
            var sound = self._soundById(id);
            if (sound) {
                if (typeof seek === "number" && seek >= 0) {
                    // Pause the sound and update position for restarting playback.
                    var playing = self.playing(id);
                    if (playing) self.pause(id, true);
                    // Move the position of the track and cancel timer.
                    sound._seek = seek;
                    sound._ended = false;
                    self._clearTimer(id);
                    // Update the seek position for HTML5 Audio.
                    if (!self._webAudio && sound._node && !isNaN(sound._node.duration)) sound._node.currentTime = seek;
                    // Seek and emit when ready.
                    var seekAndEmit = function() {
                        // Restart the playback if the sound was playing.
                        if (playing) self.play(id, true);
                        self._emit("seek", id);
                    };
                    // Wait for the play lock to be unset before emitting (HTML5 Audio).
                    if (playing && !self._webAudio) {
                        var emitSeek = function() {
                            if (!self._playLock) seekAndEmit();
                            else setTimeout(emitSeek, 0);
                        };
                        setTimeout(emitSeek, 0);
                    } else seekAndEmit();
                } else {
                    if (self._webAudio) {
                        var realTime = self.playing(id) ? Howler1.ctx.currentTime - sound._playStart : 0;
                        var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;
                        return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));
                    } else return sound._node.currentTime;
                }
            }
            return self;
        },
        /**
     * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.
     * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.
     * @return {Boolean} True if playing and false if not.
     */ playing: function(id) {
            var self = this;
            // Check the passed sound ID (if any).
            if (typeof id === "number") {
                var sound = self._soundById(id);
                return sound ? !sound._paused : false;
            }
            // Otherwise, loop through all sounds and check if any are playing.
            for(var i = 0; i < self._sounds.length; i++){
                if (!self._sounds[i]._paused) return true;
            }
            return false;
        },
        /**
     * Get the duration of this sound. Passing a sound id will return the sprite duration.
     * @param  {Number} id The sound id to check. If none is passed, return full source duration.
     * @return {Number} Audio duration in seconds.
     */ duration: function(id) {
            var self = this;
            var duration = self._duration;
            // If we pass an ID, get the sound and return the sprite length.
            var sound = self._soundById(id);
            if (sound) duration = self._sprite[sound._sprite][1] / 1000;
            return duration;
        },
        /**
     * Returns the current loaded state of this Howl.
     * @return {String} 'unloaded', 'loading', 'loaded'
     */ state: function() {
            return this._state;
        },
        /**
     * Unload and destroy the current Howl object.
     * This will immediately stop all sound instances attached to this group.
     */ unload: function() {
            var self = this;
            // Stop playing any active sounds.
            var sounds = self._sounds;
            for(var i = 0; i < sounds.length; i++){
                // Stop the sound if it is currently playing.
                if (!sounds[i]._paused) self.stop(sounds[i]._id);
                // Remove the source or disconnect.
                if (!self._webAudio) {
                    // Set the source to 0-second silence to stop any downloading (except in IE).
                    self._clearSound(sounds[i]._node);
                    // Remove any event listeners.
                    sounds[i]._node.removeEventListener("error", sounds[i]._errorFn, false);
                    sounds[i]._node.removeEventListener(Howler1._canPlayEvent, sounds[i]._loadFn, false);
                    sounds[i]._node.removeEventListener("ended", sounds[i]._endFn, false);
                    // Release the Audio object back to the pool.
                    Howler1._releaseHtml5Audio(sounds[i]._node);
                }
                // Empty out all of the nodes.
                delete sounds[i]._node;
                // Make sure all timers are cleared out.
                self._clearTimer(sounds[i]._id);
            }
            // Remove the references in the global Howler object.
            var index = Howler1._howls.indexOf(self);
            if (index >= 0) Howler1._howls.splice(index, 1);
            // Delete this sound from the cache (if no other Howl is using it).
            var remCache = true;
            for(i = 0; i < Howler1._howls.length; i++)if (Howler1._howls[i]._src === self._src || self._src.indexOf(Howler1._howls[i]._src) >= 0) {
                remCache = false;
                break;
            }
            if (cache && remCache) delete cache[self._src];
            // Clear global errors.
            Howler1.noAudio = false;
            // Clear out `self`.
            self._state = "unloaded";
            self._sounds = [];
            self = null;
            return null;
        },
        /**
     * Listen to a custom event.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to call.
     * @param  {Number}   id    (optional) Only listen to events for this sound.
     * @param  {Number}   once  (INTERNAL) Marks event to fire only once.
     * @return {Howl}
     */ on: function(event, fn, id, once) {
            var self = this;
            var events = self["_on" + event];
            if (typeof fn === "function") events.push(once ? {
                id: id,
                fn: fn,
                once: once
            } : {
                id: id,
                fn: fn
            });
            return self;
        },
        /**
     * Remove a custom event. Call without parameters to remove all events.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to remove. Leave empty to remove all.
     * @param  {Number}   id    (optional) Only remove events for this sound.
     * @return {Howl}
     */ off: function(event, fn, id) {
            var self = this;
            var events = self["_on" + event];
            var i = 0;
            // Allow passing just an event and ID.
            if (typeof fn === "number") {
                id = fn;
                fn = null;
            }
            if (fn || id) // Loop through event store and remove the passed function.
            for(i = 0; i < events.length; i++){
                var isId = id === events[i].id;
                if (fn === events[i].fn && isId || !fn && isId) {
                    events.splice(i, 1);
                    break;
                }
            }
            else if (event) // Clear out all events of this type.
            self["_on" + event] = [];
            else {
                // Clear out all events of every type.
                var keys = Object.keys(self);
                for(i = 0; i < keys.length; i++)if (keys[i].indexOf("_on") === 0 && Array.isArray(self[keys[i]])) self[keys[i]] = [];
            }
            return self;
        },
        /**
     * Listen to a custom event and remove it once fired.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to call.
     * @param  {Number}   id    (optional) Only listen to events for this sound.
     * @return {Howl}
     */ once: function(event, fn, id) {
            var self = this;
            // Setup the event listener.
            self.on(event, fn, id, 1);
            return self;
        },
        /**
     * Emit all events of a specific type and pass the sound id.
     * @param  {String} event Event name.
     * @param  {Number} id    Sound ID.
     * @param  {Number} msg   Message to go with event.
     * @return {Howl}
     */ _emit: function(event, id, msg) {
            var self = this;
            var events = self["_on" + event];
            // Loop through event store and fire all functions.
            for(var i = events.length - 1; i >= 0; i--)// Only fire the listener if the correct ID is used.
            if (!events[i].id || events[i].id === id || event === "load") {
                setTimeout((function(fn) {
                    fn.call(this, id, msg);
                }).bind(self, events[i].fn), 0);
                // If this event was setup with `once`, remove it.
                if (events[i].once) self.off(event, events[i].fn, events[i].id);
            }
            // Pass the event type into load queue so that it can continue stepping.
            self._loadQueue(event);
            return self;
        },
        /**
     * Queue of actions initiated before the sound has loaded.
     * These will be called in sequence, with the next only firing
     * after the previous has finished executing (even if async like play).
     * @return {Howl}
     */ _loadQueue: function(event) {
            var self = this;
            if (self._queue.length > 0) {
                var task = self._queue[0];
                // Remove this task if a matching event was passed.
                if (task.event === event) {
                    self._queue.shift();
                    self._loadQueue();
                }
                // Run the task if no event type is passed.
                if (!event) task.action();
            }
            return self;
        },
        /**
     * Fired when playback ends at the end of the duration.
     * @param  {Sound} sound The sound object to work with.
     * @return {Howl}
     */ _ended: function(sound) {
            var self = this;
            var sprite = sound._sprite;
            // If we are using IE and there was network latency we may be clipping
            // audio before it completes playing. Lets check the node to make sure it
            // believes it has completed, before ending the playback.
            if (!self._webAudio && sound._node && !sound._node.paused && !sound._node.ended && sound._node.currentTime < sound._stop) {
                setTimeout(self._ended.bind(self, sound), 100);
                return self;
            }
            // Should this sound loop?
            var loop = !!(sound._loop || self._sprite[sprite][2]);
            // Fire the ended event.
            self._emit("end", sound._id);
            // Restart the playback for HTML5 Audio loop.
            if (!self._webAudio && loop) self.stop(sound._id, true).play(sound._id);
            // Restart this timer if on a Web Audio loop.
            if (self._webAudio && loop) {
                self._emit("play", sound._id);
                sound._seek = sound._start || 0;
                sound._rateSeek = 0;
                sound._playStart = Howler1.ctx.currentTime;
                var timeout = (sound._stop - sound._start) * 1000 / Math.abs(sound._rate);
                self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
            }
            // Mark the node as paused.
            if (self._webAudio && !loop) {
                sound._paused = true;
                sound._ended = true;
                sound._seek = sound._start || 0;
                sound._rateSeek = 0;
                self._clearTimer(sound._id);
                // Clean up the buffer source.
                self._cleanBuffer(sound._node);
                // Attempt to auto-suspend AudioContext if no sounds are still playing.
                Howler1._autoSuspend();
            }
            // When using a sprite, end the track.
            if (!self._webAudio && !loop) self.stop(sound._id, true);
            return self;
        },
        /**
     * Clear the end timer for a sound playback.
     * @param  {Number} id The sound ID.
     * @return {Howl}
     */ _clearTimer: function(id) {
            var self = this;
            if (self._endTimers[id]) {
                // Clear the timeout or remove the ended listener.
                if (typeof self._endTimers[id] !== "function") clearTimeout(self._endTimers[id]);
                else {
                    var sound = self._soundById(id);
                    if (sound && sound._node) sound._node.removeEventListener("ended", self._endTimers[id], false);
                }
                delete self._endTimers[id];
            }
            return self;
        },
        /**
     * Return the sound identified by this ID, or return null.
     * @param  {Number} id Sound ID
     * @return {Object}    Sound object or null.
     */ _soundById: function(id) {
            var self = this;
            // Loop through all sounds and find the one with this ID.
            for(var i = 0; i < self._sounds.length; i++){
                if (id === self._sounds[i]._id) return self._sounds[i];
            }
            return null;
        },
        /**
     * Return an inactive sound from the pool or create a new one.
     * @return {Sound} Sound playback object.
     */ _inactiveSound: function() {
            var self = this;
            self._drain();
            // Find the first inactive node to recycle.
            for(var i = 0; i < self._sounds.length; i++){
                if (self._sounds[i]._ended) return self._sounds[i].reset();
            }
            // If no inactive node was found, create a new one.
            return new Sound1(self);
        },
        /**
     * Drain excess inactive sounds from the pool.
     */ _drain: function() {
            var self = this;
            var limit = self._pool;
            var cnt = 0;
            var i = 0;
            // If there are less sounds than the max pool size, we are done.
            if (self._sounds.length < limit) return;
            // Count the number of inactive sounds.
            for(i = 0; i < self._sounds.length; i++)if (self._sounds[i]._ended) cnt++;
            // Remove excess inactive sounds, going in reverse order.
            for(i = self._sounds.length - 1; i >= 0; i--){
                if (cnt <= limit) return;
                if (self._sounds[i]._ended) {
                    // Disconnect the audio source when using Web Audio.
                    if (self._webAudio && self._sounds[i]._node) self._sounds[i]._node.disconnect(0);
                    // Remove sounds until we have the pool size.
                    self._sounds.splice(i, 1);
                    cnt--;
                }
            }
        },
        /**
     * Get all ID's from the sounds pool.
     * @param  {Number} id Only return one ID if one is passed.
     * @return {Array}    Array of IDs.
     */ _getSoundIds: function(id) {
            var self = this;
            if (typeof id === "undefined") {
                var ids = [];
                for(var i = 0; i < self._sounds.length; i++)ids.push(self._sounds[i]._id);
                return ids;
            } else return [
                id
            ];
        },
        /**
     * Load the sound back into the buffer source.
     * @param  {Sound} sound The sound object to work with.
     * @return {Howl}
     */ _refreshBuffer: function(sound) {
            var self = this;
            // Setup the buffer source for playback.
            sound._node.bufferSource = Howler1.ctx.createBufferSource();
            sound._node.bufferSource.buffer = cache[self._src];
            // Connect to the correct node.
            if (sound._panner) sound._node.bufferSource.connect(sound._panner);
            else sound._node.bufferSource.connect(sound._node);
            // Setup looping and playback rate.
            sound._node.bufferSource.loop = sound._loop;
            if (sound._loop) {
                sound._node.bufferSource.loopStart = sound._start || 0;
                sound._node.bufferSource.loopEnd = sound._stop || 0;
            }
            sound._node.bufferSource.playbackRate.setValueAtTime(sound._rate, Howler1.ctx.currentTime);
            return self;
        },
        /**
     * Prevent memory leaks by cleaning up the buffer source after playback.
     * @param  {Object} node Sound's audio node containing the buffer source.
     * @return {Howl}
     */ _cleanBuffer: function(node) {
            var self = this;
            var isIOS = Howler1._navigator && Howler1._navigator.vendor.indexOf("Apple") >= 0;
            if (Howler1._scratchBuffer && node.bufferSource) {
                node.bufferSource.onended = null;
                node.bufferSource.disconnect(0);
                if (isIOS) try {
                    node.bufferSource.buffer = Howler1._scratchBuffer;
                } catch (e) {}
            }
            node.bufferSource = null;
            return self;
        },
        /**
     * Set the source to a 0-second silence to stop any downloading (except in IE).
     * @param  {Object} node Audio node to clear.
     */ _clearSound: function(node) {
            var checkIE = /MSIE |Trident\//.test(Howler1._navigator && Howler1._navigator.userAgent);
            if (!checkIE) node.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA";
        }
    };
    /** Single Sound Methods **/ /***************************************************************************/ /**
   * Setup the sound object, which each node attached to a Howl group is contained in.
   * @param {Object} howl The Howl parent group.
   */ var Sound1 = function(howl) {
        this._parent = howl;
        this.init();
    };
    Sound1.prototype = {
        /**
     * Initialize a new Sound object.
     * @return {Sound}
     */ init: function() {
            var self = this;
            var parent = self._parent;
            // Setup the default parameters.
            self._muted = parent._muted;
            self._loop = parent._loop;
            self._volume = parent._volume;
            self._rate = parent._rate;
            self._seek = 0;
            self._paused = true;
            self._ended = true;
            self._sprite = "__default";
            // Generate a unique ID for this sound.
            self._id = ++Howler1._counter;
            // Add itself to the parent's pool.
            parent._sounds.push(self);
            // Create the new node.
            self.create();
            return self;
        },
        /**
     * Create and setup a new sound object, whether HTML5 Audio or Web Audio.
     * @return {Sound}
     */ create: function() {
            var self = this;
            var parent = self._parent;
            var volume = Howler1._muted || self._muted || self._parent._muted ? 0 : self._volume;
            if (parent._webAudio) {
                // Create the gain node for controlling volume (the source will connect to this).
                self._node = typeof Howler1.ctx.createGain === "undefined" ? Howler1.ctx.createGainNode() : Howler1.ctx.createGain();
                self._node.gain.setValueAtTime(volume, Howler1.ctx.currentTime);
                self._node.paused = true;
                self._node.connect(Howler1.masterGain);
            } else if (!Howler1.noAudio) {
                // Get an unlocked Audio object from the pool.
                self._node = Howler1._obtainHtml5Audio();
                // Listen for errors (http://dev.w3.org/html5/spec-author-view/spec.html#mediaerror).
                self._errorFn = self._errorListener.bind(self);
                self._node.addEventListener("error", self._errorFn, false);
                // Listen for 'canplaythrough' event to let us know the sound is ready.
                self._loadFn = self._loadListener.bind(self);
                self._node.addEventListener(Howler1._canPlayEvent, self._loadFn, false);
                // Listen for the 'ended' event on the sound to account for edge-case where
                // a finite sound has a duration of Infinity.
                self._endFn = self._endListener.bind(self);
                self._node.addEventListener("ended", self._endFn, false);
                // Setup the new audio node.
                self._node.src = parent._src;
                self._node.preload = parent._preload === true ? "auto" : parent._preload;
                self._node.volume = volume * Howler1.volume();
                // Begin loading the source.
                self._node.load();
            }
            return self;
        },
        /**
     * Reset the parameters of this sound to the original state (for recycle).
     * @return {Sound}
     */ reset: function() {
            var self = this;
            var parent = self._parent;
            // Reset all of the parameters of this sound.
            self._muted = parent._muted;
            self._loop = parent._loop;
            self._volume = parent._volume;
            self._rate = parent._rate;
            self._seek = 0;
            self._rateSeek = 0;
            self._paused = true;
            self._ended = true;
            self._sprite = "__default";
            // Generate a new ID so that it isn't confused with the previous sound.
            self._id = ++Howler1._counter;
            return self;
        },
        /**
     * HTML5 Audio error listener callback.
     */ _errorListener: function() {
            var self = this;
            // Fire an error event and pass back the code.
            self._parent._emit("loaderror", self._id, self._node.error ? self._node.error.code : 0);
            // Clear the event listener.
            self._node.removeEventListener("error", self._errorFn, false);
        },
        /**
     * HTML5 Audio canplaythrough listener callback.
     */ _loadListener: function() {
            var self = this;
            var parent = self._parent;
            // Round up the duration to account for the lower precision in HTML5 Audio.
            parent._duration = Math.ceil(self._node.duration * 10) / 10;
            // Setup a sprite if none is defined.
            if (Object.keys(parent._sprite).length === 0) parent._sprite = {
                __default: [
                    0,
                    parent._duration * 1000
                ]
            };
            if (parent._state !== "loaded") {
                parent._state = "loaded";
                parent._emit("load");
                parent._loadQueue();
            }
            // Clear the event listener.
            self._node.removeEventListener(Howler1._canPlayEvent, self._loadFn, false);
        },
        /**
     * HTML5 Audio ended listener callback.
     */ _endListener: function() {
            var self = this;
            var parent = self._parent;
            // Only handle the `ended`` event if the duration is Infinity.
            if (parent._duration === Infinity) {
                // Update the parent duration to match the real audio duration.
                // Round up the duration to account for the lower precision in HTML5 Audio.
                parent._duration = Math.ceil(self._node.duration * 10) / 10;
                // Update the sprite that corresponds to the real duration.
                if (parent._sprite.__default[1] === Infinity) parent._sprite.__default[1] = parent._duration * 1000;
                // Run the regular ended method.
                parent._ended(self);
            }
            // Clear the event listener since the duration is now correct.
            self._node.removeEventListener("ended", self._endFn, false);
        }
    };
    /** Helper Methods **/ /***************************************************************************/ var cache = {};
    /**
   * Buffer a sound from URL, Data URI or cache and decode to audio source (Web Audio API).
   * @param  {Howl} self
   */ var loadBuffer = function(self) {
        var url = self._src;
        // Check if the buffer has already been cached and use it instead.
        if (cache[url]) {
            // Set the duration from the cache.
            self._duration = cache[url].duration;
            // Load the sound into this Howl.
            loadSound(self);
            return;
        }
        if (/^data:[^;]+;base64,/.test(url)) {
            // Decode the base64 data URI without XHR, since some browsers don't support it.
            var data = atob(url.split(",")[1]);
            var dataView = new Uint8Array(data.length);
            for(var i = 0; i < data.length; ++i)dataView[i] = data.charCodeAt(i);
            decodeAudioData(dataView.buffer, self);
        } else {
            // Load the buffer from the URL.
            var xhr = new XMLHttpRequest();
            xhr.open(self._xhr.method, url, true);
            xhr.withCredentials = self._xhr.withCredentials;
            xhr.responseType = "arraybuffer";
            // Apply any custom headers to the request.
            if (self._xhr.headers) Object.keys(self._xhr.headers).forEach(function(key) {
                xhr.setRequestHeader(key, self._xhr.headers[key]);
            });
            xhr.onload = function() {
                // Make sure we get a successful response back.
                var code = (xhr.status + "")[0];
                if (code !== "0" && code !== "2" && code !== "3") {
                    self._emit("loaderror", null, "Failed loading audio file with status: " + xhr.status + ".");
                    return;
                }
                decodeAudioData(xhr.response, self);
            };
            xhr.onerror = function() {
                // If there is an error, switch to HTML5 Audio.
                if (self._webAudio) {
                    self._html5 = true;
                    self._webAudio = false;
                    self._sounds = [];
                    delete cache[url];
                    self.load();
                }
            };
            safeXhrSend(xhr);
        }
    };
    /**
   * Send the XHR request wrapped in a try/catch.
   * @param  {Object} xhr XHR to send.
   */ var safeXhrSend = function(xhr) {
        try {
            xhr.send();
        } catch (e) {
            xhr.onerror();
        }
    };
    /**
   * Decode audio data from an array buffer.
   * @param  {ArrayBuffer} arraybuffer The audio data.
   * @param  {Howl}        self
   */ var decodeAudioData = function(arraybuffer, self) {
        // Fire a load error if something broke.
        var error = function() {
            self._emit("loaderror", null, "Decoding audio data failed.");
        };
        // Load the sound on success.
        var success = function(buffer) {
            if (buffer && self._sounds.length > 0) {
                cache[self._src] = buffer;
                loadSound(self, buffer);
            } else error();
        };
        // Decode the buffer into an audio source.
        if (typeof Promise !== "undefined" && Howler1.ctx.decodeAudioData.length === 1) Howler1.ctx.decodeAudioData(arraybuffer).then(success).catch(error);
        else Howler1.ctx.decodeAudioData(arraybuffer, success, error);
    };
    /**
   * Sound is now loaded, so finish setting everything up and fire the loaded event.
   * @param  {Howl} self
   * @param  {Object} buffer The decoded buffer sound source.
   */ var loadSound = function(self, buffer) {
        // Set the duration.
        if (buffer && !self._duration) self._duration = buffer.duration;
        // Setup a sprite if none is defined.
        if (Object.keys(self._sprite).length === 0) self._sprite = {
            __default: [
                0,
                self._duration * 1000
            ]
        };
        // Fire the loaded event.
        if (self._state !== "loaded") {
            self._state = "loaded";
            self._emit("load");
            self._loadQueue();
        }
    };
    /**
   * Setup the audio context when available, or switch to HTML5 Audio mode.
   */ var setupAudioContext = function() {
        // If we have already detected that Web Audio isn't supported, don't run this step again.
        if (!Howler1.usingWebAudio) return;
        // Check if we are using Web Audio and setup the AudioContext if we are.
        try {
            if (typeof AudioContext !== "undefined") Howler1.ctx = new AudioContext();
            else if (typeof webkitAudioContext !== "undefined") Howler1.ctx = new webkitAudioContext();
            else Howler1.usingWebAudio = false;
        } catch (e) {
            Howler1.usingWebAudio = false;
        }
        // If the audio context creation still failed, set using web audio to false.
        if (!Howler1.ctx) Howler1.usingWebAudio = false;
        // Check if a webview is being used on iOS8 or earlier (rather than the browser).
        // If it is, disable Web Audio as it causes crashing.
        var iOS = /iP(hone|od|ad)/.test(Howler1._navigator && Howler1._navigator.platform);
        var appVersion = Howler1._navigator && Howler1._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
        var version = appVersion ? parseInt(appVersion[1], 10) : null;
        if (iOS && version && version < 9) {
            var safari = /safari/.test(Howler1._navigator && Howler1._navigator.userAgent.toLowerCase());
            if (Howler1._navigator && !safari) Howler1.usingWebAudio = false;
        }
        // Create and expose the master GainNode when using Web Audio (useful for plugins or advanced usage).
        if (Howler1.usingWebAudio) {
            Howler1.masterGain = typeof Howler1.ctx.createGain === "undefined" ? Howler1.ctx.createGainNode() : Howler1.ctx.createGain();
            Howler1.masterGain.gain.setValueAtTime(Howler1._muted ? 0 : Howler1._volume, Howler1.ctx.currentTime);
            Howler1.masterGain.connect(Howler1.ctx.destination);
        }
        // Re-run the setup on Howler.
        Howler1._setup();
    };
    // Add support for AMD (Asynchronous Module Definition) libraries such as require.js.
    if (typeof define === "function" && define.amd) define([], function() {
        return {
            Howler: Howler1,
            Howl: Howl1
        };
    });
    exports.Howler = Howler1;
    exports.Howl = Howl1;
    // Add to global in Node.js (for testing, etc).
    if (typeof global !== "undefined") {
        global.HowlerGlobal = HowlerGlobal1;
        global.Howler = Howler1;
        global.Howl = Howl1;
        global.Sound = Sound1;
    } else if (typeof window !== "undefined") {
        window.HowlerGlobal = HowlerGlobal1;
        window.Howler = Howler1;
        window.Howl = Howl1;
        window.Sound = Sound1;
    }
})();
/*!
 *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
 *  
 *  howler.js v2.2.3
 *  howlerjs.com
 *
 *  (c) 2013-2020, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */ (function() {
    "use strict";
    // Setup default properties.
    HowlerGlobal.prototype._pos = [
        0,
        0,
        0
    ];
    HowlerGlobal.prototype._orientation = [
        0,
        0,
        -1,
        0,
        1,
        0
    ];
    /** Global Methods **/ /***************************************************************************/ /**
   * Helper method to update the stereo panning position of all current Howls.
   * Future Howls will not use this value unless explicitly set.
   * @param  {Number} pan A value of -1.0 is all the way left and 1.0 is all the way right.
   * @return {Howler/Number}     Self or current stereo panning value.
   */ HowlerGlobal.prototype.stereo = function(pan) {
        var self = this;
        // Stop right here if not using Web Audio.
        if (!self.ctx || !self.ctx.listener) return self;
        // Loop through all Howls and update their stereo panning.
        for(var i = self._howls.length - 1; i >= 0; i--)self._howls[i].stereo(pan);
        return self;
    };
    /**
   * Get/set the position of the listener in 3D cartesian space. Sounds using
   * 3D position will be relative to the listener's position.
   * @param  {Number} x The x-position of the listener.
   * @param  {Number} y The y-position of the listener.
   * @param  {Number} z The z-position of the listener.
   * @return {Howler/Array}   Self or current listener position.
   */ HowlerGlobal.prototype.pos = function(x, y, z) {
        var self = this;
        // Stop right here if not using Web Audio.
        if (!self.ctx || !self.ctx.listener) return self;
        // Set the defaults for optional 'y' & 'z'.
        y = typeof y !== "number" ? self._pos[1] : y;
        z = typeof z !== "number" ? self._pos[2] : z;
        if (typeof x === "number") {
            self._pos = [
                x,
                y,
                z
            ];
            if (typeof self.ctx.listener.positionX !== "undefined") {
                self.ctx.listener.positionX.setTargetAtTime(self._pos[0], Howler.ctx.currentTime, 0.1);
                self.ctx.listener.positionY.setTargetAtTime(self._pos[1], Howler.ctx.currentTime, 0.1);
                self.ctx.listener.positionZ.setTargetAtTime(self._pos[2], Howler.ctx.currentTime, 0.1);
            } else self.ctx.listener.setPosition(self._pos[0], self._pos[1], self._pos[2]);
        } else return self._pos;
        return self;
    };
    /**
   * Get/set the direction the listener is pointing in the 3D cartesian space.
   * A front and up vector must be provided. The front is the direction the
   * face of the listener is pointing, and up is the direction the top of the
   * listener is pointing. Thus, these values are expected to be at right angles
   * from each other.
   * @param  {Number} x   The x-orientation of the listener.
   * @param  {Number} y   The y-orientation of the listener.
   * @param  {Number} z   The z-orientation of the listener.
   * @param  {Number} xUp The x-orientation of the top of the listener.
   * @param  {Number} yUp The y-orientation of the top of the listener.
   * @param  {Number} zUp The z-orientation of the top of the listener.
   * @return {Howler/Array}     Returns self or the current orientation vectors.
   */ HowlerGlobal.prototype.orientation = function(x, y, z, xUp, yUp, zUp) {
        var self = this;
        // Stop right here if not using Web Audio.
        if (!self.ctx || !self.ctx.listener) return self;
        // Set the defaults for optional 'y' & 'z'.
        var or = self._orientation;
        y = typeof y !== "number" ? or[1] : y;
        z = typeof z !== "number" ? or[2] : z;
        xUp = typeof xUp !== "number" ? or[3] : xUp;
        yUp = typeof yUp !== "number" ? or[4] : yUp;
        zUp = typeof zUp !== "number" ? or[5] : zUp;
        if (typeof x === "number") {
            self._orientation = [
                x,
                y,
                z,
                xUp,
                yUp,
                zUp
            ];
            if (typeof self.ctx.listener.forwardX !== "undefined") {
                self.ctx.listener.forwardX.setTargetAtTime(x, Howler.ctx.currentTime, 0.1);
                self.ctx.listener.forwardY.setTargetAtTime(y, Howler.ctx.currentTime, 0.1);
                self.ctx.listener.forwardZ.setTargetAtTime(z, Howler.ctx.currentTime, 0.1);
                self.ctx.listener.upX.setTargetAtTime(xUp, Howler.ctx.currentTime, 0.1);
                self.ctx.listener.upY.setTargetAtTime(yUp, Howler.ctx.currentTime, 0.1);
                self.ctx.listener.upZ.setTargetAtTime(zUp, Howler.ctx.currentTime, 0.1);
            } else self.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);
        } else return or;
        return self;
    };
    /** Group Methods **/ /***************************************************************************/ /**
   * Add new properties to the core init.
   * @param  {Function} _super Core init method.
   * @return {Howl}
   */ Howl.prototype.init = function(_super) {
        return function(o) {
            var self = this;
            // Setup user-defined default properties.
            self._orientation = o.orientation || [
                1,
                0,
                0
            ];
            self._stereo = o.stereo || null;
            self._pos = o.pos || null;
            self._pannerAttr = {
                coneInnerAngle: typeof o.coneInnerAngle !== "undefined" ? o.coneInnerAngle : 360,
                coneOuterAngle: typeof o.coneOuterAngle !== "undefined" ? o.coneOuterAngle : 360,
                coneOuterGain: typeof o.coneOuterGain !== "undefined" ? o.coneOuterGain : 0,
                distanceModel: typeof o.distanceModel !== "undefined" ? o.distanceModel : "inverse",
                maxDistance: typeof o.maxDistance !== "undefined" ? o.maxDistance : 10000,
                panningModel: typeof o.panningModel !== "undefined" ? o.panningModel : "HRTF",
                refDistance: typeof o.refDistance !== "undefined" ? o.refDistance : 1,
                rolloffFactor: typeof o.rolloffFactor !== "undefined" ? o.rolloffFactor : 1
            };
            // Setup event listeners.
            self._onstereo = o.onstereo ? [
                {
                    fn: o.onstereo
                }
            ] : [];
            self._onpos = o.onpos ? [
                {
                    fn: o.onpos
                }
            ] : [];
            self._onorientation = o.onorientation ? [
                {
                    fn: o.onorientation
                }
            ] : [];
            // Complete initilization with howler.js core's init function.
            return _super.call(this, o);
        };
    }(Howl.prototype.init);
    /**
   * Get/set the stereo panning of the audio source for this sound or all in the group.
   * @param  {Number} pan  A value of -1.0 is all the way left and 1.0 is all the way right.
   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
   * @return {Howl/Number}    Returns self or the current stereo panning value.
   */ Howl.prototype.stereo = function(pan, id) {
        var self = this;
        // Stop right here if not using Web Audio.
        if (!self._webAudio) return self;
        // If the sound hasn't loaded, add it to the load queue to change stereo pan when capable.
        if (self._state !== "loaded") {
            self._queue.push({
                event: "stereo",
                action: function() {
                    self.stereo(pan, id);
                }
            });
            return self;
        }
        // Check for PannerStereoNode support and fallback to PannerNode if it doesn't exist.
        var pannerType = typeof Howler.ctx.createStereoPanner === "undefined" ? "spatial" : "stereo";
        // Setup the group's stereo panning if no ID is passed.
        if (typeof id === "undefined") {
            // Return the group's stereo panning if no parameters are passed.
            if (typeof pan === "number") {
                self._stereo = pan;
                self._pos = [
                    pan,
                    0,
                    0
                ];
            } else return self._stereo;
        }
        // Change the streo panning of one or all sounds in group.
        var ids = self._getSoundIds(id);
        for(var i = 0; i < ids.length; i++){
            // Get the sound.
            var sound = self._soundById(ids[i]);
            if (sound) {
                if (typeof pan === "number") {
                    sound._stereo = pan;
                    sound._pos = [
                        pan,
                        0,
                        0
                    ];
                    if (sound._node) {
                        // If we are falling back, make sure the panningModel is equalpower.
                        sound._pannerAttr.panningModel = "equalpower";
                        // Check if there is a panner setup and create a new one if not.
                        if (!sound._panner || !sound._panner.pan) setupPanner(sound, pannerType);
                        if (pannerType === "spatial") {
                            if (typeof sound._panner.positionX !== "undefined") {
                                sound._panner.positionX.setValueAtTime(pan, Howler.ctx.currentTime);
                                sound._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime);
                                sound._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime);
                            } else sound._panner.setPosition(pan, 0, 0);
                        } else sound._panner.pan.setValueAtTime(pan, Howler.ctx.currentTime);
                    }
                    self._emit("stereo", sound._id);
                } else return sound._stereo;
            }
        }
        return self;
    };
    /**
   * Get/set the 3D spatial position of the audio source for this sound or group relative to the global listener.
   * @param  {Number} x  The x-position of the audio source.
   * @param  {Number} y  The y-position of the audio source.
   * @param  {Number} z  The z-position of the audio source.
   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
   * @return {Howl/Array}    Returns self or the current 3D spatial position: [x, y, z].
   */ Howl.prototype.pos = function(x, y, z, id) {
        var self = this;
        // Stop right here if not using Web Audio.
        if (!self._webAudio) return self;
        // If the sound hasn't loaded, add it to the load queue to change position when capable.
        if (self._state !== "loaded") {
            self._queue.push({
                event: "pos",
                action: function() {
                    self.pos(x, y, z, id);
                }
            });
            return self;
        }
        // Set the defaults for optional 'y' & 'z'.
        y = typeof y !== "number" ? 0 : y;
        z = typeof z !== "number" ? -0.5 : z;
        // Setup the group's spatial position if no ID is passed.
        if (typeof id === "undefined") {
            // Return the group's spatial position if no parameters are passed.
            if (typeof x === "number") self._pos = [
                x,
                y,
                z
            ];
            else return self._pos;
        }
        // Change the spatial position of one or all sounds in group.
        var ids = self._getSoundIds(id);
        for(var i = 0; i < ids.length; i++){
            // Get the sound.
            var sound = self._soundById(ids[i]);
            if (sound) {
                if (typeof x === "number") {
                    sound._pos = [
                        x,
                        y,
                        z
                    ];
                    if (sound._node) {
                        // Check if there is a panner setup and create a new one if not.
                        if (!sound._panner || sound._panner.pan) setupPanner(sound, "spatial");
                        if (typeof sound._panner.positionX !== "undefined") {
                            sound._panner.positionX.setValueAtTime(x, Howler.ctx.currentTime);
                            sound._panner.positionY.setValueAtTime(y, Howler.ctx.currentTime);
                            sound._panner.positionZ.setValueAtTime(z, Howler.ctx.currentTime);
                        } else sound._panner.setPosition(x, y, z);
                    }
                    self._emit("pos", sound._id);
                } else return sound._pos;
            }
        }
        return self;
    };
    /**
   * Get/set the direction the audio source is pointing in the 3D cartesian coordinate
   * space. Depending on how direction the sound is, based on the `cone` attributes,
   * a sound pointing away from the listener can be quiet or silent.
   * @param  {Number} x  The x-orientation of the source.
   * @param  {Number} y  The y-orientation of the source.
   * @param  {Number} z  The z-orientation of the source.
   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
   * @return {Howl/Array}    Returns self or the current 3D spatial orientation: [x, y, z].
   */ Howl.prototype.orientation = function(x, y, z, id) {
        var self = this;
        // Stop right here if not using Web Audio.
        if (!self._webAudio) return self;
        // If the sound hasn't loaded, add it to the load queue to change orientation when capable.
        if (self._state !== "loaded") {
            self._queue.push({
                event: "orientation",
                action: function() {
                    self.orientation(x, y, z, id);
                }
            });
            return self;
        }
        // Set the defaults for optional 'y' & 'z'.
        y = typeof y !== "number" ? self._orientation[1] : y;
        z = typeof z !== "number" ? self._orientation[2] : z;
        // Setup the group's spatial orientation if no ID is passed.
        if (typeof id === "undefined") {
            // Return the group's spatial orientation if no parameters are passed.
            if (typeof x === "number") self._orientation = [
                x,
                y,
                z
            ];
            else return self._orientation;
        }
        // Change the spatial orientation of one or all sounds in group.
        var ids = self._getSoundIds(id);
        for(var i = 0; i < ids.length; i++){
            // Get the sound.
            var sound = self._soundById(ids[i]);
            if (sound) {
                if (typeof x === "number") {
                    sound._orientation = [
                        x,
                        y,
                        z
                    ];
                    if (sound._node) {
                        // Check if there is a panner setup and create a new one if not.
                        if (!sound._panner) {
                            // Make sure we have a position to setup the node with.
                            if (!sound._pos) sound._pos = self._pos || [
                                0,
                                0,
                                -0.5
                            ];
                            setupPanner(sound, "spatial");
                        }
                        if (typeof sound._panner.orientationX !== "undefined") {
                            sound._panner.orientationX.setValueAtTime(x, Howler.ctx.currentTime);
                            sound._panner.orientationY.setValueAtTime(y, Howler.ctx.currentTime);
                            sound._panner.orientationZ.setValueAtTime(z, Howler.ctx.currentTime);
                        } else sound._panner.setOrientation(x, y, z);
                    }
                    self._emit("orientation", sound._id);
                } else return sound._orientation;
            }
        }
        return self;
    };
    /**
   * Get/set the panner node's attributes for a sound or group of sounds.
   * This method can optionall take 0, 1 or 2 arguments.
   *   pannerAttr() -> Returns the group's values.
   *   pannerAttr(id) -> Returns the sound id's values.
   *   pannerAttr(o) -> Set's the values of all sounds in this Howl group.
   *   pannerAttr(o, id) -> Set's the values of passed sound id.
   *
   *   Attributes:
   *     coneInnerAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,
   *                      inside of which there will be no volume reduction.
   *     coneOuterAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,
   *                      outside of which the volume will be reduced to a constant value of `coneOuterGain`.
   *     coneOuterGain - (0 by default) A parameter for directional audio sources, this is the gain outside of the
   *                     `coneOuterAngle`. It is a linear value in the range `[0, 1]`.
   *     distanceModel - ('inverse' by default) Determines algorithm used to reduce volume as audio moves away from
   *                     listener. Can be `linear`, `inverse` or `exponential.
   *     maxDistance - (10000 by default) The maximum distance between source and listener, after which the volume
   *                   will not be reduced any further.
   *     refDistance - (1 by default) A reference distance for reducing volume as source moves further from the listener.
   *                   This is simply a variable of the distance model and has a different effect depending on which model
   *                   is used and the scale of your coordinates. Generally, volume will be equal to 1 at this distance.
   *     rolloffFactor - (1 by default) How quickly the volume reduces as source moves from listener. This is simply a
   *                     variable of the distance model and can be in the range of `[0, 1]` with `linear` and `[0, ∞]`
   *                     with `inverse` and `exponential`.
   *     panningModel - ('HRTF' by default) Determines which spatialization algorithm is used to position audio.
   *                     Can be `HRTF` or `equalpower`.
   *
   * @return {Howl/Object} Returns self or current panner attributes.
   */ Howl.prototype.pannerAttr = function() {
        var self = this;
        var args = arguments;
        var o, id, sound;
        // Stop right here if not using Web Audio.
        if (!self._webAudio) return self;
        // Determine the values based on arguments.
        if (args.length === 0) // Return the group's panner attribute values.
        return self._pannerAttr;
        else if (args.length === 1) {
            if (typeof args[0] === "object") {
                o = args[0];
                // Set the grou's panner attribute values.
                if (typeof id === "undefined") {
                    if (!o.pannerAttr) o.pannerAttr = {
                        coneInnerAngle: o.coneInnerAngle,
                        coneOuterAngle: o.coneOuterAngle,
                        coneOuterGain: o.coneOuterGain,
                        distanceModel: o.distanceModel,
                        maxDistance: o.maxDistance,
                        refDistance: o.refDistance,
                        rolloffFactor: o.rolloffFactor,
                        panningModel: o.panningModel
                    };
                    self._pannerAttr = {
                        coneInnerAngle: typeof o.pannerAttr.coneInnerAngle !== "undefined" ? o.pannerAttr.coneInnerAngle : self._coneInnerAngle,
                        coneOuterAngle: typeof o.pannerAttr.coneOuterAngle !== "undefined" ? o.pannerAttr.coneOuterAngle : self._coneOuterAngle,
                        coneOuterGain: typeof o.pannerAttr.coneOuterGain !== "undefined" ? o.pannerAttr.coneOuterGain : self._coneOuterGain,
                        distanceModel: typeof o.pannerAttr.distanceModel !== "undefined" ? o.pannerAttr.distanceModel : self._distanceModel,
                        maxDistance: typeof o.pannerAttr.maxDistance !== "undefined" ? o.pannerAttr.maxDistance : self._maxDistance,
                        refDistance: typeof o.pannerAttr.refDistance !== "undefined" ? o.pannerAttr.refDistance : self._refDistance,
                        rolloffFactor: typeof o.pannerAttr.rolloffFactor !== "undefined" ? o.pannerAttr.rolloffFactor : self._rolloffFactor,
                        panningModel: typeof o.pannerAttr.panningModel !== "undefined" ? o.pannerAttr.panningModel : self._panningModel
                    };
                }
            } else {
                // Return this sound's panner attribute values.
                sound = self._soundById(parseInt(args[0], 10));
                return sound ? sound._pannerAttr : self._pannerAttr;
            }
        } else if (args.length === 2) {
            o = args[0];
            id = parseInt(args[1], 10);
        }
        // Update the values of the specified sounds.
        var ids = self._getSoundIds(id);
        for(var i = 0; i < ids.length; i++){
            sound = self._soundById(ids[i]);
            if (sound) {
                // Merge the new values into the sound.
                var pa = sound._pannerAttr;
                pa = {
                    coneInnerAngle: typeof o.coneInnerAngle !== "undefined" ? o.coneInnerAngle : pa.coneInnerAngle,
                    coneOuterAngle: typeof o.coneOuterAngle !== "undefined" ? o.coneOuterAngle : pa.coneOuterAngle,
                    coneOuterGain: typeof o.coneOuterGain !== "undefined" ? o.coneOuterGain : pa.coneOuterGain,
                    distanceModel: typeof o.distanceModel !== "undefined" ? o.distanceModel : pa.distanceModel,
                    maxDistance: typeof o.maxDistance !== "undefined" ? o.maxDistance : pa.maxDistance,
                    refDistance: typeof o.refDistance !== "undefined" ? o.refDistance : pa.refDistance,
                    rolloffFactor: typeof o.rolloffFactor !== "undefined" ? o.rolloffFactor : pa.rolloffFactor,
                    panningModel: typeof o.panningModel !== "undefined" ? o.panningModel : pa.panningModel
                };
                // Update the panner values or create a new panner if none exists.
                var panner = sound._panner;
                if (panner) {
                    panner.coneInnerAngle = pa.coneInnerAngle;
                    panner.coneOuterAngle = pa.coneOuterAngle;
                    panner.coneOuterGain = pa.coneOuterGain;
                    panner.distanceModel = pa.distanceModel;
                    panner.maxDistance = pa.maxDistance;
                    panner.refDistance = pa.refDistance;
                    panner.rolloffFactor = pa.rolloffFactor;
                    panner.panningModel = pa.panningModel;
                } else {
                    // Make sure we have a position to setup the node with.
                    if (!sound._pos) sound._pos = self._pos || [
                        0,
                        0,
                        -0.5
                    ];
                    // Create a new panner node.
                    setupPanner(sound, "spatial");
                }
            }
        }
        return self;
    };
    /** Single Sound Methods **/ /***************************************************************************/ /**
   * Add new properties to the core Sound init.
   * @param  {Function} _super Core Sound init method.
   * @return {Sound}
   */ Sound.prototype.init = function(_super) {
        return function() {
            var self = this;
            var parent = self._parent;
            // Setup user-defined default properties.
            self._orientation = parent._orientation;
            self._stereo = parent._stereo;
            self._pos = parent._pos;
            self._pannerAttr = parent._pannerAttr;
            // Complete initilization with howler.js core Sound's init function.
            _super.call(this);
            // If a stereo or position was specified, set it up.
            if (self._stereo) parent.stereo(self._stereo);
            else if (self._pos) parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
        };
    }(Sound.prototype.init);
    /**
   * Override the Sound.reset method to clean up properties from the spatial plugin.
   * @param  {Function} _super Sound reset method.
   * @return {Sound}
   */ Sound.prototype.reset = function(_super) {
        return function() {
            var self = this;
            var parent = self._parent;
            // Reset all spatial plugin properties on this sound.
            self._orientation = parent._orientation;
            self._stereo = parent._stereo;
            self._pos = parent._pos;
            self._pannerAttr = parent._pannerAttr;
            // If a stereo or position was specified, set it up.
            if (self._stereo) parent.stereo(self._stereo);
            else if (self._pos) parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
            else if (self._panner) {
                // Disconnect the panner.
                self._panner.disconnect(0);
                self._panner = undefined;
                parent._refreshBuffer(self);
            }
            // Complete resetting of the sound.
            return _super.call(this);
        };
    }(Sound.prototype.reset);
    /** Helper Methods **/ /***************************************************************************/ /**
   * Create a new panner node and save it on the sound.
   * @param  {Sound} sound Specific sound to setup panning on.
   * @param {String} type Type of panner to create: 'stereo' or 'spatial'.
   */ var setupPanner = function(sound, type) {
        type = type || "spatial";
        // Create the new panner node.
        if (type === "spatial") {
            sound._panner = Howler.ctx.createPanner();
            sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;
            sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;
            sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;
            sound._panner.distanceModel = sound._pannerAttr.distanceModel;
            sound._panner.maxDistance = sound._pannerAttr.maxDistance;
            sound._panner.refDistance = sound._pannerAttr.refDistance;
            sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;
            sound._panner.panningModel = sound._pannerAttr.panningModel;
            if (typeof sound._panner.positionX !== "undefined") {
                sound._panner.positionX.setValueAtTime(sound._pos[0], Howler.ctx.currentTime);
                sound._panner.positionY.setValueAtTime(sound._pos[1], Howler.ctx.currentTime);
                sound._panner.positionZ.setValueAtTime(sound._pos[2], Howler.ctx.currentTime);
            } else sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);
            if (typeof sound._panner.orientationX !== "undefined") {
                sound._panner.orientationX.setValueAtTime(sound._orientation[0], Howler.ctx.currentTime);
                sound._panner.orientationY.setValueAtTime(sound._orientation[1], Howler.ctx.currentTime);
                sound._panner.orientationZ.setValueAtTime(sound._orientation[2], Howler.ctx.currentTime);
            } else sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);
        } else {
            sound._panner = Howler.ctx.createStereoPanner();
            sound._panner.pan.setValueAtTime(sound._stereo, Howler.ctx.currentTime);
        }
        sound._panner.connect(sound._node);
        // Update the connections.
        if (!sound._paused) sound._parent.pause(sound._id, true).play(sound._id, true);
    };
})();

},{}],"ezFly":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * Noop function (do nothing)
 */ var noop = exports.noop = function noop() {};

},{}],"dyTgj":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _interopDefault(ex) {
    return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
}
var React = require("73a55c8e0472ebef");
var React__default = _interopDefault(React);
var UAParser = require("2f11173caf5d46d2");
var ClientUAInstance = new UAParser();
var browser = ClientUAInstance.getBrowser();
var cpu = ClientUAInstance.getCPU();
var device = ClientUAInstance.getDevice();
var engine = ClientUAInstance.getEngine();
var os = ClientUAInstance.getOS();
var ua = ClientUAInstance.getUA();
var setUa = function setUa(userAgentString) {
    return ClientUAInstance.setUA(userAgentString);
};
var parseUserAgent = function parseUserAgent(userAgent) {
    if (!userAgent) {
        console.error("No userAgent string was provided");
        return;
    }
    var UserAgentInstance = new UAParser(userAgent);
    return {
        UA: UserAgentInstance,
        browser: UserAgentInstance.getBrowser(),
        cpu: UserAgentInstance.getCPU(),
        device: UserAgentInstance.getDevice(),
        engine: UserAgentInstance.getEngine(),
        os: UserAgentInstance.getOS(),
        ua: UserAgentInstance.getUA(),
        setUserAgent: function setUserAgent(userAgentString) {
            return UserAgentInstance.setUA(userAgentString);
        }
    };
};
var UAHelper = /*#__PURE__*/ Object.freeze({
    ClientUAInstance: ClientUAInstance,
    browser: browser,
    cpu: cpu,
    device: device,
    engine: engine,
    os: os,
    ua: ua,
    setUa: setUa,
    parseUserAgent: parseUserAgent
});
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread2(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
        });
        else if (Object.getOwnPropertyDescriptors) Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        else ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function(obj) {
        return typeof obj;
    };
    else _typeof = function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function _extends() {
    _extends = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) return call;
    else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(self);
}
function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
}
function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var DeviceTypes = {
    Mobile: "mobile",
    Tablet: "tablet",
    SmartTv: "smarttv",
    Console: "console",
    Wearable: "wearable",
    Embedded: "embedded",
    Browser: undefined
};
var BrowserTypes = {
    Chrome: "Chrome",
    Firefox: "Firefox",
    Opera: "Opera",
    Yandex: "Yandex",
    Safari: "Safari",
    InternetExplorer: "Internet Explorer",
    Edge: "Edge",
    Chromium: "Chromium",
    Ie: "IE",
    MobileSafari: "Mobile Safari",
    EdgeChromium: "Edge Chromium",
    MIUI: "MIUI Browser",
    SamsungBrowser: "Samsung Browser"
};
var OsTypes = {
    IOS: "iOS",
    Android: "Android",
    WindowsPhone: "Windows Phone",
    Windows: "Windows",
    MAC_OS: "Mac OS"
};
var InitialDeviceTypes = {
    isMobile: false,
    isTablet: false,
    isBrowser: false,
    isSmartTV: false,
    isConsole: false,
    isWearable: false
};
var checkDeviceType = function checkDeviceType(type) {
    switch(type){
        case DeviceTypes.Mobile:
            return {
                isMobile: true
            };
        case DeviceTypes.Tablet:
            return {
                isTablet: true
            };
        case DeviceTypes.SmartTv:
            return {
                isSmartTV: true
            };
        case DeviceTypes.Console:
            return {
                isConsole: true
            };
        case DeviceTypes.Wearable:
            return {
                isWearable: true
            };
        case DeviceTypes.Browser:
            return {
                isBrowser: true
            };
        case DeviceTypes.Embedded:
            return {
                isEmbedded: true
            };
        default:
            return InitialDeviceTypes;
    }
};
var setUserAgent = function setUserAgent(userAgent) {
    return setUa(userAgent);
};
var setDefaults = function setDefaults(p) {
    var d = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "none";
    return p ? p : d;
};
var getNavigatorInstance = function getNavigatorInstance() {
    if (typeof window !== "undefined") {
        if (window.navigator || navigator) return window.navigator || navigator;
    }
    return false;
};
var isIOS13Check = function isIOS13Check(type) {
    var nav = getNavigatorInstance();
    return nav && nav.platform && (nav.platform.indexOf(type) !== -1 || nav.platform === "MacIntel" && nav.maxTouchPoints > 1 && !window.MSStream);
};
var browserPayload = function browserPayload(isBrowser, browser, engine, os, ua) {
    return {
        isBrowser: isBrowser,
        browserMajorVersion: setDefaults(browser.major),
        browserFullVersion: setDefaults(browser.version),
        browserName: setDefaults(browser.name),
        engineName: setDefaults(engine.name),
        engineVersion: setDefaults(engine.version),
        osName: setDefaults(os.name),
        osVersion: setDefaults(os.version),
        userAgent: setDefaults(ua)
    };
};
var mobilePayload = function mobilePayload(type, device, os, ua) {
    return _objectSpread2({}, type, {
        vendor: setDefaults(device.vendor),
        model: setDefaults(device.model),
        os: setDefaults(os.name),
        osVersion: setDefaults(os.version),
        ua: setDefaults(ua)
    });
};
var smartTvPayload = function smartTvPayload(isSmartTV, engine, os, ua) {
    return {
        isSmartTV: isSmartTV,
        engineName: setDefaults(engine.name),
        engineVersion: setDefaults(engine.version),
        osName: setDefaults(os.name),
        osVersion: setDefaults(os.version),
        userAgent: setDefaults(ua)
    };
};
var consolePayload = function consolePayload(isConsole, engine, os, ua) {
    return {
        isConsole: isConsole,
        engineName: setDefaults(engine.name),
        engineVersion: setDefaults(engine.version),
        osName: setDefaults(os.name),
        osVersion: setDefaults(os.version),
        userAgent: setDefaults(ua)
    };
};
var wearablePayload = function wearablePayload(isWearable, engine, os, ua) {
    return {
        isWearable: isWearable,
        engineName: setDefaults(engine.name),
        engineVersion: setDefaults(engine.version),
        osName: setDefaults(os.name),
        osVersion: setDefaults(os.version),
        userAgent: setDefaults(ua)
    };
};
var embeddedPayload = function embeddedPayload(isEmbedded, device, engine, os, ua) {
    return {
        isEmbedded: isEmbedded,
        vendor: setDefaults(device.vendor),
        model: setDefaults(device.model),
        engineName: setDefaults(engine.name),
        engineVersion: setDefaults(engine.version),
        osName: setDefaults(os.name),
        osVersion: setDefaults(os.version),
        userAgent: setDefaults(ua)
    };
};
function deviceDetect(userAgent) {
    var _ref = userAgent ? parseUserAgent(userAgent) : UAHelper, device = _ref.device, browser = _ref.browser, engine = _ref.engine, os = _ref.os, ua = _ref.ua;
    var type = checkDeviceType(device.type);
    var isBrowser = type.isBrowser, isMobile = type.isMobile, isTablet = type.isTablet, isSmartTV = type.isSmartTV, isConsole = type.isConsole, isWearable = type.isWearable, isEmbedded = type.isEmbedded;
    if (isBrowser) return browserPayload(isBrowser, browser, engine, os, ua);
    if (isSmartTV) return smartTvPayload(isSmartTV, engine, os, ua);
    if (isConsole) return consolePayload(isConsole, engine, os, ua);
    if (isMobile) return mobilePayload(type, device, os, ua);
    if (isTablet) return mobilePayload(type, device, os, ua);
    if (isWearable) return wearablePayload(isWearable, engine, os, ua);
    if (isEmbedded) return embeddedPayload(isEmbedded, device, engine, os, ua);
}
var isMobileType = function isMobileType(_ref) {
    var type = _ref.type;
    return type === DeviceTypes.Mobile;
};
var isTabletType = function isTabletType(_ref2) {
    var type = _ref2.type;
    return type === DeviceTypes.Tablet;
};
var isMobileAndTabletType = function isMobileAndTabletType(_ref3) {
    var type = _ref3.type;
    return type === DeviceTypes.Mobile || type === DeviceTypes.Tablet;
};
var isSmartTVType = function isSmartTVType(_ref4) {
    var type = _ref4.type;
    return type === DeviceTypes.SmartTv;
};
var isBrowserType = function isBrowserType(_ref5) {
    var type = _ref5.type;
    return type === DeviceTypes.Browser;
};
var isWearableType = function isWearableType(_ref6) {
    var type = _ref6.type;
    return type === DeviceTypes.Wearable;
};
var isConsoleType = function isConsoleType(_ref7) {
    var type = _ref7.type;
    return type === DeviceTypes.Console;
};
var isEmbeddedType = function isEmbeddedType(_ref8) {
    var type = _ref8.type;
    return type === DeviceTypes.Embedded;
};
var getMobileVendor = function getMobileVendor(_ref9) {
    var vendor = _ref9.vendor;
    return setDefaults(vendor);
};
var getMobileModel = function getMobileModel(_ref10) {
    var model = _ref10.model;
    return setDefaults(model);
};
var getDeviceType = function getDeviceType(_ref11) {
    var type = _ref11.type;
    return setDefaults(type, "browser");
}; // os types
var isAndroidType = function isAndroidType(_ref12) {
    var name = _ref12.name;
    return name === OsTypes.Android;
};
var isWindowsType = function isWindowsType(_ref13) {
    var name = _ref13.name;
    return name === OsTypes.Windows;
};
var isMacOsType = function isMacOsType(_ref14) {
    var name = _ref14.name;
    return name === OsTypes.MAC_OS;
};
var isWinPhoneType = function isWinPhoneType(_ref15) {
    var name = _ref15.name;
    return name === OsTypes.WindowsPhone;
};
var isIOSType = function isIOSType(_ref16) {
    var name = _ref16.name;
    return name === OsTypes.IOS;
};
var getOsVersion = function getOsVersion(_ref17) {
    var version = _ref17.version;
    return setDefaults(version);
};
var getOsName = function getOsName(_ref18) {
    var name = _ref18.name;
    return setDefaults(name);
}; // browser types
var isChromeType = function isChromeType(_ref19) {
    var name = _ref19.name;
    return name === BrowserTypes.Chrome;
};
var isFirefoxType = function isFirefoxType(_ref20) {
    var name = _ref20.name;
    return name === BrowserTypes.Firefox;
};
var isChromiumType = function isChromiumType(_ref21) {
    var name = _ref21.name;
    return name === BrowserTypes.Chromium;
};
var isEdgeType = function isEdgeType(_ref22) {
    var name = _ref22.name;
    return name === BrowserTypes.Edge;
};
var isYandexType = function isYandexType(_ref23) {
    var name = _ref23.name;
    return name === BrowserTypes.Yandex;
};
var isSafariType = function isSafariType(_ref24) {
    var name = _ref24.name;
    return name === BrowserTypes.Safari || name === BrowserTypes.MobileSafari;
};
var isMobileSafariType = function isMobileSafariType(_ref25) {
    var name = _ref25.name;
    return name === BrowserTypes.MobileSafari;
};
var isOperaType = function isOperaType(_ref26) {
    var name = _ref26.name;
    return name === BrowserTypes.Opera;
};
var isIEType = function isIEType(_ref27) {
    var name = _ref27.name;
    return name === BrowserTypes.InternetExplorer || name === BrowserTypes.Ie;
};
var isMIUIType = function isMIUIType(_ref28) {
    var name = _ref28.name;
    return name === BrowserTypes.MIUI;
};
var isSamsungBrowserType = function isSamsungBrowserType(_ref29) {
    var name = _ref29.name;
    return name === BrowserTypes.SamsungBrowser;
};
var getBrowserFullVersion = function getBrowserFullVersion(_ref30) {
    var version = _ref30.version;
    return setDefaults(version);
};
var getBrowserVersion = function getBrowserVersion(_ref31) {
    var major = _ref31.major;
    return setDefaults(major);
};
var getBrowserName = function getBrowserName(_ref32) {
    var name = _ref32.name;
    return setDefaults(name);
}; // engine types
var getEngineName = function getEngineName(_ref33) {
    var name = _ref33.name;
    return setDefaults(name);
};
var getEngineVersion = function getEngineVersion(_ref34) {
    var version = _ref34.version;
    return setDefaults(version);
};
var isElectronType = function isElectronType() {
    var nav = getNavigatorInstance();
    var ua = nav && nav.userAgent && nav.userAgent.toLowerCase();
    return typeof ua === "string" ? /electron/.test(ua) : false;
};
var isEdgeChromiumType = function isEdgeChromiumType(ua) {
    return typeof ua === "string" && ua.indexOf("Edg/") !== -1;
};
var getIOS13 = function getIOS13() {
    var nav = getNavigatorInstance();
    return nav && (/iPad|iPhone|iPod/.test(nav.platform) || nav.platform === "MacIntel" && nav.maxTouchPoints > 1) && !window.MSStream;
};
var getIPad13 = function getIPad13() {
    return isIOS13Check("iPad");
};
var getIphone13 = function getIphone13() {
    return isIOS13Check("iPhone");
};
var getIPod13 = function getIPod13() {
    return isIOS13Check("iPod");
};
var getUseragent = function getUseragent(userAg) {
    return setDefaults(userAg);
};
function buildSelectorsObject(options) {
    var _ref = options ? options : UAHelper, device = _ref.device, browser = _ref.browser, os = _ref.os, engine = _ref.engine, ua = _ref.ua;
    return {
        isSmartTV: isSmartTVType(device),
        isConsole: isConsoleType(device),
        isWearable: isWearableType(device),
        isEmbedded: isEmbeddedType(device),
        isMobileSafari: isMobileSafariType(browser) || getIPad13(),
        isChromium: isChromiumType(browser),
        isMobile: isMobileAndTabletType(device) || getIPad13(),
        isMobileOnly: isMobileType(device),
        isTablet: isTabletType(device) || getIPad13(),
        isBrowser: isBrowserType(device),
        isDesktop: isBrowserType(device),
        isAndroid: isAndroidType(os),
        isWinPhone: isWinPhoneType(os),
        isIOS: isIOSType(os) || getIPad13(),
        isChrome: isChromeType(browser),
        isFirefox: isFirefoxType(browser),
        isSafari: isSafariType(browser),
        isOpera: isOperaType(browser),
        isIE: isIEType(browser),
        osVersion: getOsVersion(os),
        osName: getOsName(os),
        fullBrowserVersion: getBrowserFullVersion(browser),
        browserVersion: getBrowserVersion(browser),
        browserName: getBrowserName(browser),
        mobileVendor: getMobileVendor(device),
        mobileModel: getMobileModel(device),
        engineName: getEngineName(engine),
        engineVersion: getEngineVersion(engine),
        getUA: getUseragent(ua),
        isEdge: isEdgeType(browser) || isEdgeChromiumType(ua),
        isYandex: isYandexType(browser),
        deviceType: getDeviceType(device),
        isIOS13: getIOS13(),
        isIPad13: getIPad13(),
        isIPhone13: getIphone13(),
        isIPod13: getIPod13(),
        isElectron: isElectronType(),
        isEdgeChromium: isEdgeChromiumType(ua),
        isLegacyEdge: isEdgeType(browser) && !isEdgeChromiumType(ua),
        isWindows: isWindowsType(os),
        isMacOs: isMacOsType(os),
        isMIUI: isMIUIType(browser),
        isSamsungBrowser: isSamsungBrowserType(browser)
    };
}
var isSmartTV = isSmartTVType(device);
var isConsole = isConsoleType(device);
var isWearable = isWearableType(device);
var isEmbedded = isEmbeddedType(device);
var isMobileSafari = isMobileSafariType(browser) || getIPad13();
var isChromium = isChromiumType(browser);
var isMobile = isMobileAndTabletType(device) || getIPad13();
var isMobileOnly = isMobileType(device);
var isTablet = isTabletType(device) || getIPad13();
var isBrowser = isBrowserType(device);
var isDesktop = isBrowserType(device);
var isAndroid = isAndroidType(os);
var isWinPhone = isWinPhoneType(os);
var isIOS = isIOSType(os) || getIPad13();
var isChrome = isChromeType(browser);
var isFirefox = isFirefoxType(browser);
var isSafari = isSafariType(browser);
var isOpera = isOperaType(browser);
var isIE = isIEType(browser);
var osVersion = getOsVersion(os);
var osName = getOsName(os);
var fullBrowserVersion = getBrowserFullVersion(browser);
var browserVersion = getBrowserVersion(browser);
var browserName = getBrowserName(browser);
var mobileVendor = getMobileVendor(device);
var mobileModel = getMobileModel(device);
var engineName = getEngineName(engine);
var engineVersion = getEngineVersion(engine);
var getUA = getUseragent(ua);
var isEdge = isEdgeType(browser) || isEdgeChromiumType(ua);
var isYandex = isYandexType(browser);
var deviceType = getDeviceType(device);
var isIOS13 = getIOS13();
var isIPad13 = getIPad13();
var isIPhone13 = getIphone13();
var isIPod13 = getIPod13();
var isElectron = isElectronType();
var isEdgeChromium = isEdgeChromiumType(ua);
var isLegacyEdge = isEdgeType(browser) && !isEdgeChromiumType(ua);
var isWindows = isWindowsType(os);
var isMacOs = isMacOsType(os);
var isMIUI = isMIUIType(browser);
var isSamsungBrowser = isSamsungBrowserType(browser);
var getSelectorsByUserAgent = function getSelectorsByUserAgent(userAgent) {
    if (!userAgent || typeof userAgent !== "string") {
        console.error("No valid user agent string was provided");
        return;
    }
    var _UAHelper$parseUserAg = parseUserAgent(userAgent), device = _UAHelper$parseUserAg.device, browser = _UAHelper$parseUserAg.browser, os = _UAHelper$parseUserAg.os, engine = _UAHelper$parseUserAg.engine, ua = _UAHelper$parseUserAg.ua;
    return buildSelectorsObject({
        device: device,
        browser: browser,
        os: os,
        engine: engine,
        ua: ua
    });
};
var AndroidView = function AndroidView(_ref) {
    var renderWithFragment = _ref.renderWithFragment, children = _ref.children, props = _objectWithoutProperties(_ref, [
        "renderWithFragment",
        "children"
    ]);
    return isAndroid ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
};
var BrowserView = function BrowserView(_ref2) {
    var renderWithFragment = _ref2.renderWithFragment, children = _ref2.children, props = _objectWithoutProperties(_ref2, [
        "renderWithFragment",
        "children"
    ]);
    return isBrowser ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
};
var IEView = function IEView(_ref3) {
    var renderWithFragment = _ref3.renderWithFragment, children = _ref3.children, props = _objectWithoutProperties(_ref3, [
        "renderWithFragment",
        "children"
    ]);
    return isIE ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
};
var IOSView = function IOSView(_ref4) {
    var renderWithFragment = _ref4.renderWithFragment, children = _ref4.children, props = _objectWithoutProperties(_ref4, [
        "renderWithFragment",
        "children"
    ]);
    return isIOS ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
};
var MobileView = function MobileView(_ref5) {
    var renderWithFragment = _ref5.renderWithFragment, children = _ref5.children, props = _objectWithoutProperties(_ref5, [
        "renderWithFragment",
        "children"
    ]);
    return isMobile ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
};
var TabletView = function TabletView(_ref6) {
    var renderWithFragment = _ref6.renderWithFragment, children = _ref6.children, props = _objectWithoutProperties(_ref6, [
        "renderWithFragment",
        "children"
    ]);
    return isTablet ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
};
var WinPhoneView = function WinPhoneView(_ref7) {
    var renderWithFragment = _ref7.renderWithFragment, children = _ref7.children, props = _objectWithoutProperties(_ref7, [
        "renderWithFragment",
        "children"
    ]);
    return isWinPhone ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
};
var MobileOnlyView = function MobileOnlyView(_ref8) {
    var renderWithFragment = _ref8.renderWithFragment, children = _ref8.children, viewClassName = _ref8.viewClassName, style = _ref8.style, props = _objectWithoutProperties(_ref8, [
        "renderWithFragment",
        "children",
        "viewClassName",
        "style"
    ]);
    return isMobileOnly ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
};
var SmartTVView = function SmartTVView(_ref9) {
    var renderWithFragment = _ref9.renderWithFragment, children = _ref9.children, props = _objectWithoutProperties(_ref9, [
        "renderWithFragment",
        "children"
    ]);
    return isSmartTV ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
};
var ConsoleView = function ConsoleView(_ref10) {
    var renderWithFragment = _ref10.renderWithFragment, children = _ref10.children, props = _objectWithoutProperties(_ref10, [
        "renderWithFragment",
        "children"
    ]);
    return isConsole ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
};
var WearableView = function WearableView(_ref11) {
    var renderWithFragment = _ref11.renderWithFragment, children = _ref11.children, props = _objectWithoutProperties(_ref11, [
        "renderWithFragment",
        "children"
    ]);
    return isWearable ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
};
var CustomView = function CustomView(_ref12) {
    var renderWithFragment = _ref12.renderWithFragment, children = _ref12.children, viewClassName = _ref12.viewClassName, style = _ref12.style, condition = _ref12.condition, props = _objectWithoutProperties(_ref12, [
        "renderWithFragment",
        "children",
        "viewClassName",
        "style",
        "condition"
    ]);
    return condition ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
};
function withOrientationChange(WrappedComponent) {
    return /*#__PURE__*/ function(_React$Component) {
        _inherits(_class, _React$Component);
        function _class(props) {
            var _this;
            _classCallCheck(this, _class);
            _this = _possibleConstructorReturn(this, _getPrototypeOf(_class).call(this, props));
            _this.isEventListenerAdded = false;
            _this.handleOrientationChange = _this.handleOrientationChange.bind(_assertThisInitialized(_this));
            _this.onOrientationChange = _this.onOrientationChange.bind(_assertThisInitialized(_this));
            _this.onPageLoad = _this.onPageLoad.bind(_assertThisInitialized(_this));
            _this.state = {
                isLandscape: false,
                isPortrait: false
            };
            return _this;
        }
        _createClass(_class, [
            {
                key: "handleOrientationChange",
                value: function handleOrientationChange() {
                    if (!this.isEventListenerAdded) this.isEventListenerAdded = true;
                    var orientation = window.innerWidth > window.innerHeight ? 90 : 0;
                    this.setState({
                        isPortrait: orientation === 0,
                        isLandscape: orientation === 90
                    });
                }
            },
            {
                key: "onOrientationChange",
                value: function onOrientationChange() {
                    this.handleOrientationChange();
                }
            },
            {
                key: "onPageLoad",
                value: function onPageLoad() {
                    this.handleOrientationChange();
                }
            },
            {
                key: "componentDidMount",
                value: function componentDidMount() {
                    if ((typeof window === "undefined" ? "undefined" : _typeof(window)) !== undefined && isMobile) {
                        if (!this.isEventListenerAdded) {
                            this.handleOrientationChange();
                            window.addEventListener("load", this.onPageLoad, false);
                        } else window.removeEventListener("load", this.onPageLoad, false);
                        window.addEventListener("resize", this.onOrientationChange, false);
                    }
                }
            },
            {
                key: "componentWillUnmount",
                value: function componentWillUnmount() {
                    window.removeEventListener("resize", this.onOrientationChange, false);
                }
            },
            {
                key: "render",
                value: function render() {
                    return React__default.createElement(WrappedComponent, _extends({}, this.props, {
                        isLandscape: this.state.isLandscape,
                        isPortrait: this.state.isPortrait
                    }));
                }
            }
        ]);
        return _class;
    }(React__default.Component);
}
function useMobileOrientation() {
    var _useState = React.useState(function() {
        var orientation = window.innerWidth > window.innerHeight ? 90 : 0;
        return {
            isPortrait: orientation === 0,
            isLandscape: orientation === 90,
            orientation: orientation === 0 ? "portrait" : "landscape"
        };
    }), _useState2 = _slicedToArray(_useState, 2), state = _useState2[0], setState = _useState2[1];
    var handleOrientationChange = React.useCallback(function() {
        var orientation = window.innerWidth > window.innerHeight ? 90 : 0;
        var next = {
            isPortrait: orientation === 0,
            isLandscape: orientation === 90,
            orientation: orientation === 0 ? "portrait" : "landscape"
        };
        state.orientation !== next.orientation && setState(next);
    }, [
        state.orientation
    ]);
    React.useEffect(function() {
        if ((typeof window === "undefined" ? "undefined" : _typeof(window)) !== undefined && isMobile) {
            handleOrientationChange();
            window.addEventListener("load", handleOrientationChange, false);
            window.addEventListener("resize", handleOrientationChange, false);
        }
        return function() {
            window.removeEventListener("resize", handleOrientationChange, false);
            window.removeEventListener("load", handleOrientationChange, false);
        };
    }, [
        handleOrientationChange
    ]);
    return state;
}
function useDeviceData(userAgent) {
    var hookUserAgent = userAgent ? userAgent : window.navigator.userAgent;
    return parseUserAgent(hookUserAgent);
}
function useDeviceSelectors(userAgent) {
    var hookUserAgent = userAgent ? userAgent : window.navigator.userAgent;
    var deviceData = useDeviceData(hookUserAgent);
    var selectors = buildSelectorsObject(deviceData);
    return [
        selectors,
        deviceData
    ];
}
exports.AndroidView = AndroidView;
exports.BrowserTypes = BrowserTypes;
exports.BrowserView = BrowserView;
exports.ConsoleView = ConsoleView;
exports.CustomView = CustomView;
exports.IEView = IEView;
exports.IOSView = IOSView;
exports.MobileOnlyView = MobileOnlyView;
exports.MobileView = MobileView;
exports.OsTypes = OsTypes;
exports.SmartTVView = SmartTVView;
exports.TabletView = TabletView;
exports.WearableView = WearableView;
exports.WinPhoneView = WinPhoneView;
exports.browserName = browserName;
exports.browserVersion = browserVersion;
exports.deviceDetect = deviceDetect;
exports.deviceType = deviceType;
exports.engineName = engineName;
exports.engineVersion = engineVersion;
exports.fullBrowserVersion = fullBrowserVersion;
exports.getSelectorsByUserAgent = getSelectorsByUserAgent;
exports.getUA = getUA;
exports.isAndroid = isAndroid;
exports.isBrowser = isBrowser;
exports.isChrome = isChrome;
exports.isChromium = isChromium;
exports.isConsole = isConsole;
exports.isDesktop = isDesktop;
exports.isEdge = isEdge;
exports.isEdgeChromium = isEdgeChromium;
exports.isElectron = isElectron;
exports.isEmbedded = isEmbedded;
exports.isFirefox = isFirefox;
exports.isIE = isIE;
exports.isIOS = isIOS;
exports.isIOS13 = isIOS13;
exports.isIPad13 = isIPad13;
exports.isIPhone13 = isIPhone13;
exports.isIPod13 = isIPod13;
exports.isLegacyEdge = isLegacyEdge;
exports.isMIUI = isMIUI;
exports.isMacOs = isMacOs;
exports.isMobile = isMobile;
exports.isMobileOnly = isMobileOnly;
exports.isMobileSafari = isMobileSafari;
exports.isOpera = isOpera;
exports.isSafari = isSafari;
exports.isSamsungBrowser = isSamsungBrowser;
exports.isSmartTV = isSmartTV;
exports.isTablet = isTablet;
exports.isWearable = isWearable;
exports.isWinPhone = isWinPhone;
exports.isWindows = isWindows;
exports.isYandex = isYandex;
exports.mobileModel = mobileModel;
exports.mobileVendor = mobileVendor;
exports.osName = osName;
exports.osVersion = osVersion;
exports.parseUserAgent = parseUserAgent;
exports.setUserAgent = setUserAgent;
exports.useDeviceData = useDeviceData;
exports.useDeviceSelectors = useDeviceSelectors;
exports.useMobileOrientation = useMobileOrientation;
exports.withOrientationChange = withOrientationChange;

},{"73a55c8e0472ebef":"2kGyk","2f11173caf5d46d2":"5qllO"}],"5qllO":[function(require,module,exports) {
/* UAParser.js v1.0.33
   Copyright © 2012-2021 Faisal Salman <f@faisalman.com>
   MIT License */ (function(window1, undefined) {
    "use strict";
    var LIBVERSION = "0.7.33", EMPTY = "", UNKNOWN = "?", FUNC_TYPE = "function", UNDEF_TYPE = "undefined", OBJ_TYPE = "object", STR_TYPE = "string", MAJOR = "major", MODEL = "model", NAME = "name", TYPE = "type", VENDOR = "vendor", VERSION = "version", ARCHITECTURE = "architecture", CONSOLE = "console", MOBILE = "mobile", TABLET = "tablet", SMARTTV = "smarttv", WEARABLE = "wearable", EMBEDDED = "embedded", UA_MAX_LENGTH = 350;
    var AMAZON = "Amazon", APPLE = "Apple", ASUS = "ASUS", BLACKBERRY = "BlackBerry", BROWSER = "Browser", CHROME = "Chrome", EDGE = "Edge", FIREFOX = "Firefox", GOOGLE = "Google", HUAWEI = "Huawei", LG = "LG", MICROSOFT = "Microsoft", MOTOROLA = "Motorola", OPERA = "Opera", SAMSUNG = "Samsung", SHARP = "Sharp", SONY = "Sony", XIAOMI = "Xiaomi", ZEBRA = "Zebra", FACEBOOK = "Facebook";
    var extend = function(regexes, extensions) {
        var mergedRegexes = {};
        for(var i in regexes)if (extensions[i] && extensions[i].length % 2 === 0) mergedRegexes[i] = extensions[i].concat(regexes[i]);
        else mergedRegexes[i] = regexes[i];
        return mergedRegexes;
    }, enumerize = function(arr) {
        var enums = {};
        for(var i = 0; i < arr.length; i++)enums[arr[i].toUpperCase()] = arr[i];
        return enums;
    }, has = function(str1, str2) {
        return typeof str1 === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false;
    }, lowerize = function(str) {
        return str.toLowerCase();
    }, majorize = function(version) {
        return typeof version === STR_TYPE ? version.replace(/[^\d\.]/g, EMPTY).split(".")[0] : undefined;
    }, trim = function(str, len) {
        if (typeof str === STR_TYPE) {
            str = str.replace(/^\s\s*/, EMPTY);
            return typeof len === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);
        }
    };
    var rgxMapper = function(ua, arrays) {
        var i = 0, j, k, p, q, matches, match;
        while(i < arrays.length && !matches){
            var regex = arrays[i], props = arrays[i + 1];
            j = k = 0;
            while(j < regex.length && !matches){
                matches = regex[j++].exec(ua);
                if (!!matches) for(p = 0; p < props.length; p++){
                    match = matches[++k];
                    q = props[p];
                    if (typeof q === OBJ_TYPE && q.length > 0) {
                        if (q.length === 2) {
                            if (typeof q[1] == FUNC_TYPE) this[q[0]] = q[1].call(this, match);
                            else this[q[0]] = q[1];
                        } else if (q.length === 3) {
                            if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined;
                            else this[q[0]] = match ? match.replace(q[1], q[2]) : undefined;
                        } else if (q.length === 4) this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined;
                    } else this[q] = match ? match : undefined;
                }
            }
            i += 2;
        }
    }, strMapper = function(str, map) {
        for(var i in map){
            if (typeof map[i] === OBJ_TYPE && map[i].length > 0) for(var j = 0; j < map[i].length; j++){
                if (has(map[i][j], str)) return i === UNKNOWN ? undefined : i;
            }
            else if (has(map[i], str)) return i === UNKNOWN ? undefined : i;
        }
        return str;
    };
    var oldSafariMap = {
        "1.0": "/8",
        1.2: "/1",
        1.3: "/3",
        "2.0": "/412",
        "2.0.2": "/416",
        "2.0.3": "/417",
        "2.0.4": "/419",
        "?": "/"
    }, windowsVersionMap = {
        ME: "4.90",
        "NT 3.11": "NT3.51",
        "NT 4.0": "NT4.0",
        2e3: "NT 5.0",
        XP: [
            "NT 5.1",
            "NT 5.2"
        ],
        Vista: "NT 6.0",
        7: "NT 6.1",
        8: "NT 6.2",
        8.1: "NT 6.3",
        10: [
            "NT 6.4",
            "NT 10.0"
        ],
        RT: "ARM"
    };
    var regexes = {
        browser: [
            [
                /\b(?:crmo|crios)\/([\w\.]+)/i
            ],
            [
                VERSION,
                [
                    NAME,
                    "Chrome"
                ]
            ],
            [
                /edg(?:e|ios|a)?\/([\w\.]+)/i
            ],
            [
                VERSION,
                [
                    NAME,
                    "Edge"
                ]
            ],
            [
                /(opera mini)\/([-\w\.]+)/i,
                /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,
                /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i
            ],
            [
                NAME,
                VERSION
            ],
            [
                /opios[\/ ]+([\w\.]+)/i
            ],
            [
                VERSION,
                [
                    NAME,
                    OPERA + " Mini"
                ]
            ],
            [
                /\bopr\/([\w\.]+)/i
            ],
            [
                VERSION,
                [
                    NAME,
                    OPERA
                ]
            ],
            [
                /(kindle)\/([\w\.]+)/i,
                /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i,
                /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i,
                /(ba?idubrowser)[\/ ]?([\w\.]+)/i,
                /(?:ms|\()(ie) ([\w\.]+)/i,
                /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i,
                /(weibo)__([\d\.]+)/i
            ],
            [
                NAME,
                VERSION
            ],
            [
                /(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i
            ],
            [
                VERSION,
                [
                    NAME,
                    "UC" + BROWSER
                ]
            ],
            [
                /microm.+\bqbcore\/([\w\.]+)/i,
                /\bqbcore\/([\w\.]+).+microm/i
            ],
            [
                VERSION,
                [
                    NAME,
                    "WeChat(Win) Desktop"
                ]
            ],
            [
                /micromessenger\/([\w\.]+)/i
            ],
            [
                VERSION,
                [
                    NAME,
                    "WeChat"
                ]
            ],
            [
                /konqueror\/([\w\.]+)/i
            ],
            [
                VERSION,
                [
                    NAME,
                    "Konqueror"
                ]
            ],
            [
                /trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i
            ],
            [
                VERSION,
                [
                    NAME,
                    "IE"
                ]
            ],
            [
                /yabrowser\/([\w\.]+)/i
            ],
            [
                VERSION,
                [
                    NAME,
                    "Yandex"
                ]
            ],
            [
                /(avast|avg)\/([\w\.]+)/i
            ],
            [
                [
                    NAME,
                    /(.+)/,
                    "$1 Secure " + BROWSER
                ],
                VERSION
            ],
            [
                /\bfocus\/([\w\.]+)/i
            ],
            [
                VERSION,
                [
                    NAME,
                    FIREFOX + " Focus"
                ]
            ],
            [
                /\bopt\/([\w\.]+)/i
            ],
            [
                VERSION,
                [
                    NAME,
                    OPERA + " Touch"
                ]
            ],
            [
                /coc_coc\w+\/([\w\.]+)/i
            ],
            [
                VERSION,
                [
                    NAME,
                    "Coc Coc"
                ]
            ],
            [
                /dolfin\/([\w\.]+)/i
            ],
            [
                VERSION,
                [
                    NAME,
                    "Dolphin"
                ]
            ],
            [
                /coast\/([\w\.]+)/i
            ],
            [
                VERSION,
                [
                    NAME,
                    OPERA + " Coast"
                ]
            ],
            [
                /miuibrowser\/([\w\.]+)/i
            ],
            [
                VERSION,
                [
                    NAME,
                    "MIUI " + BROWSER
                ]
            ],
            [
                /fxios\/([-\w\.]+)/i
            ],
            [
                VERSION,
                [
                    NAME,
                    FIREFOX
                ]
            ],
            [
                /\bqihu|(qi?ho?o?|360)browser/i
            ],
            [
                [
                    NAME,
                    "360 " + BROWSER
                ]
            ],
            [
                /(oculus|samsung|sailfish|huawei)browser\/([\w\.]+)/i
            ],
            [
                [
                    NAME,
                    /(.+)/,
                    "$1 " + BROWSER
                ],
                VERSION
            ],
            [
                /(comodo_dragon)\/([\w\.]+)/i
            ],
            [
                [
                    NAME,
                    /_/g,
                    " "
                ],
                VERSION
            ],
            [
                /(electron)\/([\w\.]+) safari/i,
                /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,
                /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i
            ],
            [
                NAME,
                VERSION
            ],
            [
                /(metasr)[\/ ]?([\w\.]+)/i,
                /(lbbrowser)/i,
                /\[(linkedin)app\]/i
            ],
            [
                NAME
            ],
            [
                /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i
            ],
            [
                [
                    NAME,
                    FACEBOOK
                ],
                VERSION
            ],
            [
                /safari (line)\/([\w\.]+)/i,
                /\b(line)\/([\w\.]+)\/iab/i,
                /(chromium|instagram)[\/ ]([-\w\.]+)/i
            ],
            [
                NAME,
                VERSION
            ],
            [
                /\bgsa\/([\w\.]+) .*safari\//i
            ],
            [
                VERSION,
                [
                    NAME,
                    "GSA"
                ]
            ],
            [
                /headlesschrome(?:\/([\w\.]+)| )/i
            ],
            [
                VERSION,
                [
                    NAME,
                    CHROME + " Headless"
                ]
            ],
            [
                / wv\).+(chrome)\/([\w\.]+)/i
            ],
            [
                [
                    NAME,
                    CHROME + " WebView"
                ],
                VERSION
            ],
            [
                /droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i
            ],
            [
                VERSION,
                [
                    NAME,
                    "Android " + BROWSER
                ]
            ],
            [
                /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i
            ],
            [
                NAME,
                VERSION
            ],
            [
                /version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i
            ],
            [
                VERSION,
                [
                    NAME,
                    "Mobile Safari"
                ]
            ],
            [
                /version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i
            ],
            [
                VERSION,
                NAME
            ],
            [
                /webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i
            ],
            [
                NAME,
                [
                    VERSION,
                    strMapper,
                    oldSafariMap
                ]
            ],
            [
                /(webkit|khtml)\/([\w\.]+)/i
            ],
            [
                NAME,
                VERSION
            ],
            [
                /(navigator|netscape\d?)\/([-\w\.]+)/i
            ],
            [
                [
                    NAME,
                    "Netscape"
                ],
                VERSION
            ],
            [
                /mobile vr; rv:([\w\.]+)\).+firefox/i
            ],
            [
                VERSION,
                [
                    NAME,
                    FIREFOX + " Reality"
                ]
            ],
            [
                /ekiohf.+(flow)\/([\w\.]+)/i,
                /(swiftfox)/i,
                /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i,
                /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
                /(firefox)\/([\w\.]+)/i,
                /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,
                /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
                /(links) \(([\w\.]+)/i
            ],
            [
                NAME,
                VERSION
            ],
            [
                /(cobalt)\/([\w\.]+)/i
            ],
            [
                NAME,
                [
                    VERSION,
                    /master.|lts./,
                    ""
                ]
            ]
        ],
        cpu: [
            [
                /(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i
            ],
            [
                [
                    ARCHITECTURE,
                    "amd64"
                ]
            ],
            [
                /(ia32(?=;))/i
            ],
            [
                [
                    ARCHITECTURE,
                    lowerize
                ]
            ],
            [
                /((?:i[346]|x)86)[;\)]/i
            ],
            [
                [
                    ARCHITECTURE,
                    "ia32"
                ]
            ],
            [
                /\b(aarch64|arm(v?8e?l?|_?64))\b/i
            ],
            [
                [
                    ARCHITECTURE,
                    "arm64"
                ]
            ],
            [
                /\b(arm(?:v[67])?ht?n?[fl]p?)\b/i
            ],
            [
                [
                    ARCHITECTURE,
                    "armhf"
                ]
            ],
            [
                /windows (ce|mobile); ppc;/i
            ],
            [
                [
                    ARCHITECTURE,
                    "arm"
                ]
            ],
            [
                /((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i
            ],
            [
                [
                    ARCHITECTURE,
                    /ower/,
                    EMPTY,
                    lowerize
                ]
            ],
            [
                /(sun4\w)[;\)]/i
            ],
            [
                [
                    ARCHITECTURE,
                    "sparc"
                ]
            ],
            [
                /((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i
            ],
            [
                [
                    ARCHITECTURE,
                    lowerize
                ]
            ]
        ],
        device: [
            [
                /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    SAMSUNG
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /\b((?:s[cgp]h|gt|sm)-\w+|galaxy nexus)/i,
                /samsung[- ]([-\w]+)/i,
                /sec-(sgh\w+)/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    SAMSUNG
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /\((ip(?:hone|od)[\w ]*);/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    APPLE
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /\((ipad);[-\w\),; ]+apple/i,
                /applecoremedia\/[\w\.]+ \((ipad)/i,
                /\b(ipad)\d\d?,\d\d?[;\]].+ios/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    APPLE
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /(macintosh);/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    APPLE
                ]
            ],
            [
                /\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    HUAWEI
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /(?:huawei|honor)([-\w ]+)[;\)]/i,
                /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    HUAWEI
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /\b(poco[\w ]+)(?: bui|\))/i,
                /\b; (\w+) build\/hm\1/i,
                /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,
                /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,
                /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i
            ],
            [
                [
                    MODEL,
                    /_/g,
                    " "
                ],
                [
                    VENDOR,
                    XIAOMI
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i
            ],
            [
                [
                    MODEL,
                    /_/g,
                    " "
                ],
                [
                    VENDOR,
                    XIAOMI
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /; (\w+) bui.+ oppo/i,
                /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "OPPO"
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /vivo (\w+)(?: bui|\))/i,
                /\b(v[12]\d{3}\w?[at])(?: bui|;)/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Vivo"
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /\b(rmx[12]\d{3})(?: bui|;|\))/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Realme"
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
                /\bmot(?:orola)?[- ](\w*)/i,
                /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    MOTOROLA
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /\b(mz60\d|xoom[2 ]{0,2}) build\//i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    MOTOROLA
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    LG
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
                /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i,
                /\blg-?([\d\w]+) bui/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    LG
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /(ideatab[-\w ]+)/i,
                /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Lenovo"
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /(?:maemo|nokia).*(n900|lumia \d+)/i,
                /nokia[-_ ]?([-\w\.]*)/i
            ],
            [
                [
                    MODEL,
                    /_/g,
                    " "
                ],
                [
                    VENDOR,
                    "Nokia"
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /(pixel c)\b/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    GOOGLE
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    GOOGLE
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    SONY
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /sony tablet [ps]/i,
                /\b(?:sony)?sgp\w+(?: bui|\))/i
            ],
            [
                [
                    MODEL,
                    "Xperia Tablet"
                ],
                [
                    VENDOR,
                    SONY
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                / (kb2005|in20[12]5|be20[12][59])\b/i,
                /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "OnePlus"
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /(alexa)webm/i,
                /(kf[a-z]{2}wi)( bui|\))/i,
                /(kf[a-z]+)( bui|\)).+silk\//i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    AMAZON
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i
            ],
            [
                [
                    MODEL,
                    /(.+)/g,
                    "Fire Phone $1"
                ],
                [
                    VENDOR,
                    AMAZON
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /(playbook);[-\w\),; ]+(rim)/i
            ],
            [
                MODEL,
                VENDOR,
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /\b((?:bb[a-f]|st[hv])100-\d)/i,
                /\(bb10; (\w+)/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    BLACKBERRY
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    ASUS
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                / (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    ASUS
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /(nexus 9)/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "HTC"
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,
                /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
                /(alcatel|geeksphone|nexian|panasonic|sony(?!-bra))[-_ ]?([-\w]*)/i
            ],
            [
                VENDOR,
                [
                    MODEL,
                    /_/g,
                    " "
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /droid.+; ([ab][1-7]-?[0178a]\d\d?)/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Acer"
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /droid.+; (m[1-5] note) bui/i,
                /\bmz-([-\w]{2,})/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Meizu"
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /\b(sh-?[altvz]?\d\d[a-ekm]?)/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    SHARP
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i,
                /(hp) ([\w ]+\w)/i,
                /(asus)-?(\w+)/i,
                /(microsoft); (lumia[\w ]+)/i,
                /(lenovo)[-_ ]?([-\w]+)/i,
                /(jolla)/i,
                /(oppo) ?([\w ]+) bui/i
            ],
            [
                VENDOR,
                MODEL,
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /(archos) (gamepad2?)/i,
                /(hp).+(touchpad(?!.+tablet)|tablet)/i,
                /(kindle)\/([\w\.]+)/i,
                /(nook)[\w ]+build\/(\w+)/i,
                /(dell) (strea[kpr\d ]*[\dko])/i,
                /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,
                /(trinity)[- ]*(t\d{3}) bui/i,
                /(gigaset)[- ]+(q\w{1,9}) bui/i,
                /(vodafone) ([\w ]+)(?:\)| bui)/i
            ],
            [
                VENDOR,
                MODEL,
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /(surface duo)/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    MICROSOFT
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /droid [\d\.]+; (fp\du?)(?: b|\))/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Fairphone"
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /(u304aa)/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "AT&T"
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /\bsie-(\w*)/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Siemens"
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /\b(rct\w+) b/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "RCA"
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /\b(venue[\d ]{2,7}) b/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Dell"
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /\b(q(?:mv|ta)\w+) b/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Verizon"
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Barnes & Noble"
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /\b(tm\d{3}\w+) b/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "NuVision"
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /\b(k88) b/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "ZTE"
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /\b(nx\d{3}j) b/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "ZTE"
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /\b(gen\d{3}) b.+49h/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Swiss"
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /\b(zur\d{3}) b/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Swiss"
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /\b((zeki)?tb.*\b) b/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Zeki"
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /\b([yr]\d{2}) b/i,
                /\b(dragon[- ]+touch |dt)(\w{5}) b/i
            ],
            [
                [
                    VENDOR,
                    "Dragon Touch"
                ],
                MODEL,
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /\b(ns-?\w{0,9}) b/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Insignia"
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /\b((nxa|next)-?\w{0,9}) b/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "NextBook"
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i
            ],
            [
                [
                    VENDOR,
                    "Voice"
                ],
                MODEL,
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /\b(lvtel\-)?(v1[12]) b/i
            ],
            [
                [
                    VENDOR,
                    "LvTel"
                ],
                MODEL,
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /\b(ph-1) /i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Essential"
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /\b(v(100md|700na|7011|917g).*\b) b/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Envizen"
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /\b(trio[-\w\. ]+) b/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "MachSpeed"
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /\btu_(1491) b/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Rotor"
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /(shield[\w ]+) b/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Nvidia"
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /(sprint) (\w+)/i
            ],
            [
                VENDOR,
                MODEL,
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /(kin\.[onetw]{3})/i
            ],
            [
                [
                    MODEL,
                    /\./g,
                    " "
                ],
                [
                    VENDOR,
                    MICROSOFT
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    ZEBRA
                ],
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    ZEBRA
                ],
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /(ouya)/i,
                /(nintendo) ([wids3utch]+)/i
            ],
            [
                VENDOR,
                MODEL,
                [
                    TYPE,
                    CONSOLE
                ]
            ],
            [
                /droid.+; (shield) bui/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Nvidia"
                ],
                [
                    TYPE,
                    CONSOLE
                ]
            ],
            [
                /(playstation [345portablevi]+)/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    SONY
                ],
                [
                    TYPE,
                    CONSOLE
                ]
            ],
            [
                /\b(xbox(?: one)?(?!; xbox))[\); ]/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    MICROSOFT
                ],
                [
                    TYPE,
                    CONSOLE
                ]
            ],
            [
                /smart-tv.+(samsung)/i
            ],
            [
                VENDOR,
                [
                    TYPE,
                    SMARTTV
                ]
            ],
            [
                /hbbtv.+maple;(\d+)/i
            ],
            [
                [
                    MODEL,
                    /^/,
                    "SmartTV"
                ],
                [
                    VENDOR,
                    SAMSUNG
                ],
                [
                    TYPE,
                    SMARTTV
                ]
            ],
            [
                /(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i
            ],
            [
                [
                    VENDOR,
                    LG
                ],
                [
                    TYPE,
                    SMARTTV
                ]
            ],
            [
                /(apple) ?tv/i
            ],
            [
                VENDOR,
                [
                    MODEL,
                    APPLE + " TV"
                ],
                [
                    TYPE,
                    SMARTTV
                ]
            ],
            [
                /crkey/i
            ],
            [
                [
                    MODEL,
                    CHROME + "cast"
                ],
                [
                    VENDOR,
                    GOOGLE
                ],
                [
                    TYPE,
                    SMARTTV
                ]
            ],
            [
                /droid.+aft(\w)( bui|\))/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    AMAZON
                ],
                [
                    TYPE,
                    SMARTTV
                ]
            ],
            [
                /\(dtv[\);].+(aquos)/i,
                /(aquos-tv[\w ]+)\)/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    SHARP
                ],
                [
                    TYPE,
                    SMARTTV
                ]
            ],
            [
                /(bravia[\w ]+)( bui|\))/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    SONY
                ],
                [
                    TYPE,
                    SMARTTV
                ]
            ],
            [
                /(mitv-\w{5}) bui/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    XIAOMI
                ],
                [
                    TYPE,
                    SMARTTV
                ]
            ],
            [
                /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,
                /hbbtv\/\d+\.\d+\.\d+ +\([\w ]*; *(\w[^;]*);([^;]*)/i
            ],
            [
                [
                    VENDOR,
                    trim
                ],
                [
                    MODEL,
                    trim
                ],
                [
                    TYPE,
                    SMARTTV
                ]
            ],
            [
                /\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i
            ],
            [
                [
                    TYPE,
                    SMARTTV
                ]
            ],
            [
                /((pebble))app/i
            ],
            [
                VENDOR,
                MODEL,
                [
                    TYPE,
                    WEARABLE
                ]
            ],
            [
                /droid.+; (glass) \d/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    GOOGLE
                ],
                [
                    TYPE,
                    WEARABLE
                ]
            ],
            [
                /droid.+; (wt63?0{2,3})\)/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    ZEBRA
                ],
                [
                    TYPE,
                    WEARABLE
                ]
            ],
            [
                /(quest( 2)?)/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    FACEBOOK
                ],
                [
                    TYPE,
                    WEARABLE
                ]
            ],
            [
                /(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i
            ],
            [
                VENDOR,
                [
                    TYPE,
                    EMBEDDED
                ]
            ],
            [
                /droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i
            ],
            [
                MODEL,
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i
            ],
            [
                MODEL,
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i
            ],
            [
                [
                    TYPE,
                    TABLET
                ]
            ],
            [
                /(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i
            ],
            [
                [
                    TYPE,
                    MOBILE
                ]
            ],
            [
                /(android[-\w\. ]{0,9});.+buil/i
            ],
            [
                MODEL,
                [
                    VENDOR,
                    "Generic"
                ]
            ]
        ],
        engine: [
            [
                /windows.+ edge\/([\w\.]+)/i
            ],
            [
                VERSION,
                [
                    NAME,
                    EDGE + "HTML"
                ]
            ],
            [
                /webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i
            ],
            [
                VERSION,
                [
                    NAME,
                    "Blink"
                ]
            ],
            [
                /(presto)\/([\w\.]+)/i,
                /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i,
                /ekioh(flow)\/([\w\.]+)/i,
                /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,
                /(icab)[\/ ]([23]\.[\d\.]+)/i
            ],
            [
                NAME,
                VERSION
            ],
            [
                /rv\:([\w\.]{1,9})\b.+(gecko)/i
            ],
            [
                VERSION,
                NAME
            ]
        ],
        os: [
            [
                /microsoft (windows) (vista|xp)/i
            ],
            [
                NAME,
                VERSION
            ],
            [
                /(windows) nt 6\.2; (arm)/i,
                /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i,
                /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i
            ],
            [
                NAME,
                [
                    VERSION,
                    strMapper,
                    windowsVersionMap
                ]
            ],
            [
                /(win(?=3|9|n)|win 9x )([nt\d\.]+)/i
            ],
            [
                [
                    NAME,
                    "Windows"
                ],
                [
                    VERSION,
                    strMapper,
                    windowsVersionMap
                ]
            ],
            [
                /ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i,
                /cfnetwork\/.+darwin/i
            ],
            [
                [
                    VERSION,
                    /_/g,
                    "."
                ],
                [
                    NAME,
                    "iOS"
                ]
            ],
            [
                /(mac os x) ?([\w\. ]*)/i,
                /(macintosh|mac_powerpc\b)(?!.+haiku)/i
            ],
            [
                [
                    NAME,
                    "Mac OS"
                ],
                [
                    VERSION,
                    /_/g,
                    "."
                ]
            ],
            [
                /droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i
            ],
            [
                VERSION,
                NAME
            ],
            [
                /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i,
                /(blackberry)\w*\/([\w\.]*)/i,
                /(tizen|kaios)[\/ ]([\w\.]+)/i,
                /\((series40);/i
            ],
            [
                NAME,
                VERSION
            ],
            [
                /\(bb(10);/i
            ],
            [
                VERSION,
                [
                    NAME,
                    BLACKBERRY
                ]
            ],
            [
                /(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i
            ],
            [
                VERSION,
                [
                    NAME,
                    "Symbian"
                ]
            ],
            [
                /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i
            ],
            [
                VERSION,
                [
                    NAME,
                    FIREFOX + " OS"
                ]
            ],
            [
                /web0s;.+rt(tv)/i,
                /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i
            ],
            [
                VERSION,
                [
                    NAME,
                    "webOS"
                ]
            ],
            [
                /crkey\/([\d\.]+)/i
            ],
            [
                VERSION,
                [
                    NAME,
                    CHROME + "cast"
                ]
            ],
            [
                /(cros) [\w]+ ([\w\.]+\w)/i
            ],
            [
                [
                    NAME,
                    "Chromium OS"
                ],
                VERSION
            ],
            [
                /(nintendo|playstation) ([wids345portablevuch]+)/i,
                /(xbox); +xbox ([^\);]+)/i,
                /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,
                /(mint)[\/\(\) ]?(\w*)/i,
                /(mageia|vectorlinux)[; ]/i,
                /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
                /(hurd|linux) ?([\w\.]*)/i,
                /(gnu) ?([\w\.]*)/i,
                /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,
                /(haiku) (\w+)/i
            ],
            [
                NAME,
                VERSION
            ],
            [
                /(sunos) ?([\w\.\d]*)/i
            ],
            [
                [
                    NAME,
                    "Solaris"
                ],
                VERSION
            ],
            [
                /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,
                /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,
                /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i,
                /(unix) ?([\w\.]*)/i
            ],
            [
                NAME,
                VERSION
            ]
        ]
    };
    var UAParser = function(ua, extensions) {
        if (typeof ua === OBJ_TYPE) {
            extensions = ua;
            ua = undefined;
        }
        if (!(this instanceof UAParser)) return new UAParser(ua, extensions).getResult();
        var _ua = ua || (typeof window1 !== UNDEF_TYPE && window1.navigator && window1.navigator.userAgent ? window1.navigator.userAgent : EMPTY);
        var _rgxmap = extensions ? extend(regexes, extensions) : regexes;
        this.getBrowser = function() {
            var _browser = {};
            _browser[NAME] = undefined;
            _browser[VERSION] = undefined;
            rgxMapper.call(_browser, _ua, _rgxmap.browser);
            _browser.major = majorize(_browser.version);
            return _browser;
        };
        this.getCPU = function() {
            var _cpu = {};
            _cpu[ARCHITECTURE] = undefined;
            rgxMapper.call(_cpu, _ua, _rgxmap.cpu);
            return _cpu;
        };
        this.getDevice = function() {
            var _device = {};
            _device[VENDOR] = undefined;
            _device[MODEL] = undefined;
            _device[TYPE] = undefined;
            rgxMapper.call(_device, _ua, _rgxmap.device);
            return _device;
        };
        this.getEngine = function() {
            var _engine = {};
            _engine[NAME] = undefined;
            _engine[VERSION] = undefined;
            rgxMapper.call(_engine, _ua, _rgxmap.engine);
            return _engine;
        };
        this.getOS = function() {
            var _os = {};
            _os[NAME] = undefined;
            _os[VERSION] = undefined;
            rgxMapper.call(_os, _ua, _rgxmap.os);
            return _os;
        };
        this.getResult = function() {
            return {
                ua: this.getUA(),
                browser: this.getBrowser(),
                engine: this.getEngine(),
                os: this.getOS(),
                device: this.getDevice(),
                cpu: this.getCPU()
            };
        };
        this.getUA = function() {
            return _ua;
        };
        this.setUA = function(ua) {
            _ua = typeof ua === STR_TYPE && ua.length > UA_MAX_LENGTH ? trim(ua, UA_MAX_LENGTH) : ua;
            return this;
        };
        this.setUA(_ua);
        return this;
    };
    UAParser.VERSION = LIBVERSION;
    UAParser.BROWSER = enumerize([
        NAME,
        VERSION,
        MAJOR
    ]);
    UAParser.CPU = enumerize([
        ARCHITECTURE
    ]);
    UAParser.DEVICE = enumerize([
        MODEL,
        VENDOR,
        TYPE,
        CONSOLE,
        MOBILE,
        SMARTTV,
        TABLET,
        WEARABLE,
        EMBEDDED
    ]);
    UAParser.ENGINE = UAParser.OS = enumerize([
        NAME,
        VERSION
    ]);
    if ("object" !== UNDEF_TYPE) {
        if ("object" !== UNDEF_TYPE && module.exports) exports = module.exports = UAParser;
        exports.UAParser = UAParser;
    } else {
        if (typeof define === FUNC_TYPE && define.amd) define(function() {
            return UAParser;
        });
        else if (typeof window1 !== UNDEF_TYPE) window1.UAParser = UAParser;
    }
    var $ = typeof window1 !== UNDEF_TYPE && (window1.jQuery || window1.Zepto);
    if ($ && !$.ua) {
        var parser = new UAParser;
        $.ua = parser.getResult();
        $.ua.get = function() {
            return parser.getUA();
        };
        $.ua.set = function(ua) {
            parser.setUA(ua);
            var result = parser.getResult();
            for(var prop in result)$.ua[prop] = result[prop];
        };
    }
})(typeof window === "object" ? window : this);

},{}]},["h9ZBw","bzv6s"], "bzv6s", "parcelRequire98c1")

//# sourceMappingURL=menu.js.map
